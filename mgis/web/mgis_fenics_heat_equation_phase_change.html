<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-EN" xml:lang="en-EN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Transient heat equation with phase change</title>
        <meta name="author" content="Jérémy Bleyer" />
        <meta name="author" content="Thomas Helfer" />
            <meta name="date" content="2020-01-01" />
        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
    <style type="text/css">code{white-space: pre;}</style>
            <style type="text/css">
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f8f8f8; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ef2929; } /* Alert */
      code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #204a87; } /* Attribute */
      code span.bn { color: #0000cf; } /* BaseN */
      code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4e9a06; } /* Char */
      code span.cn { color: #8f5902; } /* Constant */
      code span.co { color: #8f5902; font-style: italic; } /* Comment */
      code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
      code span.dt { color: #204a87; } /* DataType */
      code span.dv { color: #0000cf; } /* DecVal */
      code span.er { color: #a40000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #0000cf; } /* Float */
      code span.fu { color: #204a87; font-weight: bold; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
      code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
      code span.ot { color: #8f5902; } /* Other */
      code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
      code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
      code span.ss { color: #4e9a06; } /* SpecialString */
      code span.st { color: #4e9a06; } /* String */
      code span.va { color: #000000; } /* Variable */
      code span.vs { color: #4e9a06; } /* VerbatimString */
      code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
    </style>
            <link rel="stylesheet" href="/home/th202608/codes/mgis/master/src/MFrontGenericInterfaceSupport/docs/web/css/main.css" />
        <link rel="stylesheet" href="css/normalize.css"/>
    <link rel="stylesheet" href="css/main.css"/>
        <script
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
        type="text/javascript"></script>
          </head>
  <body>
    <!--[if lt IE 7]>
        <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]-->
        <header>
      <ul id="nav">
	<li><a href="index.html">Overview</a></li>
	<li><a>Documentation</a>
	  <ul>
	    <li><a href="https://www.theoj.org/joss-papers/joss.02003/10.21105.joss.02003.pdf"> JOSS paper</a></li>
	    <li><a href="bindings-cxx.html">Description of the C++ library</a></li>
	    <li><a href="install.html">Installation guide</a></li>
	    <li><a>Bindings</a>
	        <ul>
		  <li><a>python</a>
	            <ul>
		       <li><a href="bindings-python-finite_strain.html">Interacting with a finite-strain `MFront` behaviour</a></li>
		       <li><a href="bindings-python-small_strain.html">Interacting with a small-strain `MFront` behaviour</a></li>
	            </ul>
                   </li>
	        </ul>
	    </li>
	    <li><a href="mgis_fenics.html">mgis.fenics</a>
	      <ul>
		<li><a href="mgis_fenics.html">Overview of mgis.fenics</a></li>
		<li><a href="mgis_fenics_nonlinear_heat_transfer.html">Stationnary non-linear heat transfer</a></li>
		<li><a href="mgis_fenics_nonlinear_heat_transfer_3D.html">Stationnary non-linear heat transfer: 3D problem and performance comparisons</a></li>
		<li><a href="mgis_fenics_heat_equation_phase_change.html">Transient heat equation with phase change</a></li>
		<li><a href="mgis_fenics_monolithic_transient_thermoelasticity.html">Monolithic transient thermoelasticity</a></li>
		<li><a href="mgis_fenics_small_strain_elastoplasticity.html">Small-strain von Mises elastoplasticity</a></li>
		<li><a href="mgis_fenics_finite_strain_elastoplasticity.html">Finite-strain elastoplasticity within the logarithmic strain framework</a></li>
		<li><a href="mgis_fenics_multiphase_model.html">Multiphase model for fiber-reinforced materials</a></li>
		<li><a href="mgis_fenics_phase_field.html">Phase-field approach to brittle fracture</a></li>
	      </ul>
	    </li>
	    <li><a>Release notes</a>
	      <ul>
		<li><a>Version 1.0.x</a>
		  <ul>
		    <li><a href="release-notes-1.0.2.html">Version 1.0.2</a></li>
		  </ul>
		</li>
		<li><a>Version 1.1.x</a>
		  <ul>
		    <li><a href="release-notes-1.1.html">Version 1.1</a></li>
		    <li><a href="release-notes-1.1.1.html">Version 1.1.1</a></li>
		  </ul>
		</li>
		<li><a>Version 1.2.x</a>
		  <ul>
		    <li><a href="release-notes-1.2.html">Version 1.2</a></li>
		    <li><a href="release-notes-1.2.1.html">Version 1.2.1</a></li>
		    <li><a href="release-notes-1.2.2.html">Version 1.2.2</a></li>
		    <li><a href="release-notes-1.2.3.html">Version 1.2.3</a></li>
		  </ul>
		</li>
		<li><a>Version 2.0.x</a>
		  <ul>
		    <li><a href="release-notes-2.0.html">Version 2.0</a></li>
		  </ul>
		<li><a>Version 2.1.x</a>
		  <ul>
		    <li><a href="release-notes-2.1.html">Version 2.1</a></li>
		  </ul>
		<li><a>Version 2.2.x</a>
		  <ul>
		    <li><a href="release-notes-2.2.html">Version 2.2</a></li>
		    <li><a href="release-notes-2.2.1.html">Version 2.2.1</a></li>
		  </ul>
		</li>
		<li><a>Version 3.0.x</a>
		  <ul>
		    <li><a href="release-notes-3.0.html">Version 3.0</a></li>
		    <li><a href="release-notes-3.0.1.html">Version 3.0.1</a></li>
		  </ul>
		</li>
		<li><a>Version 3.1.x</a>
		  <ul>
		    <li><a href="release-notes-3.1.html">Version 3.1</a></li>
		  </ul>
		</li>
	      </ul>
	    </li>
	    <li><a>Specific topics</a>
	      <ul>
		<li><a href="orthotropic-behaviours.html">Support for orthotropic behaviours</a></li>
	      </ul>
	    </li>
	    <li><a href="faq.html">FAQ</a></li>
	    <li><a href="about.html">About</a></li>
	  </ul>
	</li>
	<li><a>Contributing</a>
	  <ul>
	    <li><a href="contributing.html">Contributing guidelines</a></li>
	    <li><a href="https://github.com/thelfer/MFrontGenericInterfaceSupport/issues">Report bugs</a></li>
	  </ul>
	</li>
	<li><a>Getting Help</a>
	  <ul>
	    <li><a href="https://github.com/thelfer/MFrontGenericInterfaceSupport/issues">Forum</a></li>
	    <li><a href="mailto:tfel-contact@cea.fr">Contact</a></li>
	  </ul>
	</li>
      </ul>
    </header>
    <br></br>
<div id="header">
<h1 class="title">Transient heat equation with phase change</h1>
<h2 class="author">Jérémy Bleyer</h2>
<h2 class="author">Thomas Helfer</h2>
<h3 class="date">2020</h3>
</div>
<div id="TOC">
true
</div>
<!--
pandoc --pdf-engine=xelatex -F pandoc-crossref -F pandoc-citeproc --highlight-style=tango mgis_fenics_heat_equation_phase_change.md -o mgis_fenics_heat_equation_phase_change.pdf 
-->
<p>In this demo, we expand on the <a
href="https://thelfer.github.io/mgis/web/mgis_fenics_nonlinear_heat_transfer.html">stationnary
nonlinear heat transfer demo</a> and consider a transient heat equation
with non-linear heat transfer law including solid/liquid phase change.
This demo corresponds to the <a
href="https://www.code-aster.org/V2/doc/default/fr/man_v/v4/v4.22.002.pdf">TTNL02
elementary test case</a> of the <a
href="https://www.code-aster.org"><code>code_aster</code> finite-element
software</a>.</p>
<!--
<p align="center">
<img src="img/solidification_front.gif" width="500">
</p>
-->
<blockquote>
<p><strong>Source files:</strong></p>
<ul>
<li>Jupyter notebook: <a
href="https://gitlab.enpc.fr/navier-fenics/mgis-fenics-demos/raw/master/demos/heat_equation_phase_change/mgis_fenics_heat_equation_phase_change.ipynb">mgis_fenics_heat_equation_phase_change.ipynb</a></li>
<li>Python file: <a
href="https://gitlab.enpc.fr/navier-fenics/mgis-fenics-demos/raw/master/demos/heat_equation_phase_change/mgis_fenics_heat_equation_phase_change.py">mgis_fenics_heat_equation_phase_change.py</a></li>
<li>MFront behaviour file: <a
href="https://gitlab.enpc.fr/navier-fenics/mgis-fenics-demos/raw/master/demos/heat_equation_phase_change/HeatTransferPhaseChange.mfront">HeatTransferPhaseChange.mfront</a></li>
</ul>
</blockquote>
<h1 id="transient-heat-equation-using-an-enthalpy-formulation">Transient
heat equation using an enthalpy formulation</h1>
<p>The transient heat equation writes:</p>
<p><span class="math display">\[
\rho C_p \dfrac{\partial T}{\partial t} = r-\operatorname{div}\mathbf{j}
\]</span></p>
<p>where <span class="math inline">\(\rho\)</span> is the material
density, <span class="math inline">\(C_p\)</span> the heat capacity (at
constant pressure) per unit of mass, <span
class="math inline">\(r\)</span> represents heat sources and <span
class="math inline">\(\mathbf{j}\)</span> is the heat flux.</p>
<p>In the case of phase changes, the heat capacity exhibits large
discontinuities near the transition temperature. It is therefore more
suitable to work with the enthalpy density defined as:</p>
<p><span class="math display">\[
h(T) = \int_{T_0}^{T} \rho C_p dT
\]</span></p>
<p>yielding the following heat equation: <span class="math display">\[
\dfrac{\partial h}{\partial t} = r-\operatorname{div}\mathbf{j}
\]</span></p>
<h1
id="description-of-the-non-linear-heat-transfer-law-with-phase-change">Description
of the non-linear heat transfer law with phase change</h1>
<p>The thermal material is described by the following non linear Fourier
Law:</p>
<p><span class="math display">\[
\mathbf{j}=-k\left(T\right)\,\mathbf{\nabla} T
\]</span></p>
<p>where the thermal conductivity <span class="math inline">\(k\)</span>
is initially assumed to be given by:</p>
<p><span class="math display">\[
k\left(T\right)=\begin{cases}
k_s &amp; \text{if }T &lt; T_m \\
k_l &amp; \text{if }T &gt; T_m
\end{cases}
\]</span> where <span class="math inline">\(k_s\)</span> (resp. <span
class="math inline">\(k_l\)</span>) denotes the solid (resp. liquid)
phase conductivity and <span class="math inline">\(T_m\)</span> is the
solid/liquid transition temperature.</p>
<p>The enthalpy is assumed to be given by:</p>
<p><span class="math display">\[
h\left(T\right)=\begin{cases}
c_sT &amp; \text{if }T &lt; T_m \\
c_l(T-T_m)+c_sT_m+\Delta h_{s/l} &amp; \text{if }T &gt; T_m
\end{cases}
\]</span></p>
<p>where <span class="math inline">\(c_s=\rho_sC_{p,s}\)</span> (resp.
<span class="math inline">\(c_l=\rho_lC_{p,l}\)</span>) is the volumic
heat capacity of the solid (resp. liquid) phase. It can be observed that
the enthalpy exhibits a discontinuity at the phase transition equal to
<span class="math inline">\(\Delta h_{s/l}\)</span> which represents the
latent heat of fusion per unit volume.</p>
<p align="center">
<img src="img/phase_change_law.svg" width="500">
</p>
<h1 id="a-smoothed-version">A smoothed version</h1>
<p>The enthalpy discontinuity <span class="math inline">\(\Delta
h_{s/l}\)</span> poses convergence difficulties for the Newton
resolution. A classical remedy consists in considering a smoothed
version of the previous law, such as:</p>
<p><span class="math display">\[
k\left(T\right)=\begin{cases}
k_s &amp; \text{if }T &lt; T_s \\
k_s + (k_l-k_s)\dfrac{T-T_s}{T_\text{smooth}} &amp; \text{if } T_s \leq
T \leq T_l\\
k_l &amp; \text{if }T &gt; T_l
\end{cases}
\]</span> and <span class="math display">\[
h\left(T\right)=\begin{cases}
c_sT &amp; \text{if }T &lt; T_s \\
c_sT_s+\left(\dfrac{cs+cl}{2}+\dfrac{\Delta
h_{s/l}}{T_\text{smooth}}\right)(T-T_s) &amp; \text{if } T_s \leq T \leq
T_l \\
c_l(T-T_l)+c_sT_s+\dfrac{cs+cl}{2}T_\text{smooth}+\Delta h_{s/l} &amp;
\text{if }T &gt; T_l
\end{cases}
\]</span> where <span class="math inline">\(T_{smooth}=T_l-T_s\)</span>
is a small transition temperature interval between <span
class="math inline">\(T_s=T_m-T_\text{smooth}/2\)</span> the solidus
temperature and <span
class="math inline">\(T_l=T_m+T_\text{smooth}/2\)</span> the liquidus
temperature.</p>
<h1 id="mfront-implementation"><code>MFront</code> implementation</h1>
<h2 id="gradient-flux-and-tangent-operator-blocks">Gradient, flux and
tangent operator blocks</h2>
<p>Similarly to the <a
href="mgis_fenics_nonlinear_heat_transfer.html">stationnary nonlinear
heat transfer demo</a>, the <code>MFront</code> implementation relies on
the <code>DefaultGenericBehaviour</code> DSL and declares the pair of
temperature gradient and heat flux. In addition, the volumic enthalpy
<span class="math inline">\(h\)</span> is also declared as an internal
state variable. In addition to the two tangent operator blocks
<code>∂j∕∂Δ∇T</code> and <code>∂j∕∂ΔT</code> already discussed in the
first demo, we also declare the additional block <code>∂h∕∂ΔT</code>,
referring to the fact that the enthalpy will vary with the temperature
and will enter the transient heat equation.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>DSL DefaultGenericBehaviour<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Behaviour HeatTransferPhaseChange<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Author Thomas Helfer <span class="op">/</span> Jérémy Bleyer<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Date <span class="dv">15</span> <span class="op">/</span> <span class="bn">02</span> <span class="op">/</span> <span class="dv">2019</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Gradient TemperatureGradient ∇T<span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>∇T<span class="op">.</span>setGlossaryName<span class="op">(</span><span class="st">&quot;TemperatureGradient&quot;</span><span class="op">);</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Flux HeatFlux j<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>j<span class="op">.</span>setGlossaryName<span class="op">(</span><span class="st">&quot;HeatFlux&quot;</span><span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>StateVariable real h<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>h<span class="op">.</span>setEntryName<span class="op">(</span><span class="st">&quot;Enthalpy&quot;</span><span class="op">);</span> <span class="co">//per unit of volume</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>AdditionalTangentOperatorBlock ∂j∕∂ΔT<span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>AdditionalTangentOperatorBlock ∂h∕∂ΔT<span class="op">;</span></span></code></pre></div>
<h2 id="material-parameters-and-local-variables">Material parameters and
local variables</h2>
<p>We now declare the various material properties corresponding to those
of aluminium. The material parameters are assumed to be uniform for both
phases. Finally, we also introduce the smoothing temperature width <span
class="math inline">\(T_\text{smooth}\)</span>.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Parameter Tₘ <span class="op">=</span> <span class="fl">933.15</span><span class="op">;</span>        <span class="co">// [K]</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>Tₘ<span class="op">.</span>setEntryName<span class="op">(</span><span class="st">&quot;MeltingTemperature&quot;</span><span class="op">);</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Parameter kₛ <span class="op">=</span> <span class="dv">210</span><span class="op">;</span>           <span class="co">// [W/m/K]</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>kₛ<span class="op">.</span>setEntryName<span class="op">(</span><span class="st">&quot;SolidConductivity&quot;</span><span class="op">);</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Parameter cₛ <span class="op">=</span> <span class="fl">3.e6</span><span class="op">;</span>          <span class="co">// [J/m^3/K]</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>cₛ<span class="op">.</span>setEntryName<span class="op">(</span><span class="st">&quot;SolidHeatCapacity&quot;</span><span class="op">);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Parameter kₗ <span class="op">=</span> <span class="dv">95</span><span class="op">;</span>            <span class="co">// [W/m/K]</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>kₗ<span class="op">.</span>setEntryName<span class="op">(</span><span class="st">&quot;LiquidConductivity&quot;</span><span class="op">);</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Parameter cₗ <span class="op">=</span> <span class="fl">2.58e6</span><span class="op">;</span>        <span class="co">// [J/m^3/K]</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>cₗ<span class="op">.</span>setEntryName<span class="op">(</span><span class="st">&quot;LiquidHeatCapacity&quot;</span><span class="op">);</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Parameter Δhₛₗ <span class="op">=</span> <span class="fl">1.08048e9</span><span class="op">;</span>   <span class="co">// [J/m^3]</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>Δhₛₗ<span class="op">.</span>setEntryName<span class="op">(</span><span class="st">&quot;FusionEnthalpy&quot;</span><span class="op">);</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Parameter Tₛₘₒₒₜₕ <span class="op">=</span> <span class="fl">0.1</span><span class="op">;</span>      <span class="co">// smoothing temperature width [K]</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>Tₛₘₒₒₜₕ<span class="op">.</span>setEntryName<span class="op">(</span><span class="st">&quot;Tsmooth&quot;</span><span class="op">);</span></span></code></pre></div>
<p>We define some local variables corresponding to the values of the
conductivity <span class="math inline">\(k\)</span>, the volumic heat
capacity <span class="math inline">\(c\)</span> and the derivative of
the heat conductivity with respect to the temperature.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>LocalVariable thermalconductivity k<span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>LocalVariable real c<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>LocalVariable real ∂k∕∂T<span class="op">;</span></span></code></pre></div>
<h2 id="integration-of-the-behaviour">Integration of the behaviour</h2>
<p>Again, the behaviour integration is straightforward: after computing
the temperature at the end of the time step <code>T_</code>, we compute
the thermal conductivity, its derivative with respect to the
temperature, the volumic enthalpy and the volumic heat capacity
depending on whether <code>T_</code> belongs to the solid state (<span
class="math inline">\(T\leq T_s\)</span>), the liquid state (<span
class="math inline">\(T\geq T_l\)</span>) or to the transition region
(<span class="math inline">\(T_s \leq T \leq T_l\)</span>). We finish by
computing the heat flux.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Integrator <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> T_ <span class="op">=</span> T <span class="op">+</span> ΔT<span class="op">;</span>     <span class="co">// current temperature</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> Tₛ <span class="op">=</span> Tₘ<span class="op">-</span>Tₛₘₒₒₜₕ<span class="op">/</span><span class="dv">2</span><span class="op">;</span> <span class="co">// solidus temperature</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> Tₗ <span class="op">=</span> Tₘ<span class="op">+</span>Tₛₘₒₒₜₕ<span class="op">/</span><span class="dv">2</span><span class="op">;</span> <span class="co">// liquidus temperature</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span><span class="op">(</span>T_<span class="op">&lt;</span>Tₛ<span class="op">){</span>                  <span class="co">// solid state</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> kₛ<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> cₛ<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> cₛ<span class="op">*</span>T_<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    ∂k∕∂T <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>T_ <span class="op">&gt;</span> Tₗ<span class="op">)</span> <span class="op">{</span>        <span class="co">// liquid state</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> kₗ<span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> cₗ<span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> cₗ<span class="op">*(</span>T_<span class="op">-</span>Tₗ<span class="op">)+</span>Δhₛₗ<span class="op">+</span>cₛ<span class="op">*</span>Tₛ<span class="op">+(</span>cₛ<span class="op">+</span>cₗ<span class="op">)*</span>Tₛₘₒₒₜₕ<span class="op">/</span><span class="dv">2</span><span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    ∂k∕∂T <span class="op">=</span> <span class="fl">0.</span><span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span>                    <span class="co">// solid/liquid smooth transition</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    k <span class="op">=</span> kₛ <span class="op">+</span> <span class="op">(</span>kₗ<span class="op">-</span>kₛ<span class="op">)*(</span>T_<span class="op">-</span>Tₛ<span class="op">)/</span>Tₛₘₒₒₜₕ<span class="op">;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    h <span class="op">=</span> cₛ<span class="op">*</span>Tₛ<span class="op">+((</span>cₛ<span class="op">+</span>cₗ<span class="op">)/</span><span class="dv">2</span><span class="op">+</span>Δhₛₗ<span class="op">/</span>Tₛₘₒₒₜₕ<span class="op">)*(</span>T_<span class="op">-</span>Tₛ<span class="op">);</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> Δhₛₗ<span class="op">/(</span>Tₗ<span class="op">-</span>Tₛ<span class="op">);</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    ∂k∕∂T <span class="op">=</span> <span class="op">-(</span>kₗ<span class="op">-</span>kₛ<span class="op">)/</span>Tₛₘₒₒₜₕ<span class="op">;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">// heat flux</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  j <span class="op">=</span> <span class="op">-</span>k ⋅ <span class="op">(</span>∇T <span class="op">+</span> Δ∇T<span class="op">);</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// end of @Integrator</span></span></code></pre></div>
<h1 id="tangent-operator">Tangent operator</h1>
<p>The computation of the tangent operator blocks is then
straightforward:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>TangentOperator <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  ∂j∕∂Δ∇T <span class="op">=</span> <span class="op">-</span>k <span class="op">*</span> tmatrix<span class="op">&lt;</span>N<span class="op">,</span> N<span class="op">,</span> real<span class="op">&gt;::</span>Id<span class="op">();</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  ∂j∕∂ΔT <span class="op">=</span> ∂k∕∂T <span class="op">*</span> <span class="op">(</span>∇T <span class="op">+</span> Δ∇T<span class="op">);</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  ∂h∕∂ΔT <span class="op">=</span> c<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span>  <span class="co">// end of @TangentOperator</span></span></code></pre></div>
<h1 id="fenics-implementation">FEniCS implementation</h1>
<h2 id="geometry-and-material">Geometry and material</h2>
<p>We consider a rectanglar domain of length 0.1 with imposed
temperatures <code>T0</code> (resp. <code>Ti</code>) on the left (resp.
right) boundaries. We look here for the temperature field <code>T</code>
using a <span class="math inline">\(P^2\)</span>-interpolation which is
initially at the uniform temperature <code>Ti</code>.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib notebook</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfin <span class="im">import</span> <span class="op">*</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> mgis.fenics <span class="im">as</span> mf</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>length <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>width <span class="op">=</span> <span class="fl">0.01</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>Nx <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>Ny <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>mesh <span class="op">=</span> RectangleMesh(Point(<span class="fl">0.</span>, <span class="fl">0.</span>), Point(length, width), Nx, Ny, <span class="st">&quot;crossed&quot;</span>)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.linspace(<span class="dv">0</span>, length, Nx)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> FunctionSpace(mesh, <span class="st">&quot;CG&quot;</span>, <span class="dv">2</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> Function(V, name<span class="op">=</span><span class="st">&quot;Temperature&quot;</span>)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> left(x, on_boundary):</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> near(x[<span class="dv">0</span>], <span class="dv">0</span>) <span class="kw">and</span> on_boundary</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> right(x, on_boundary):</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> near(x[<span class="dv">0</span>], length) <span class="kw">and</span> on_boundary</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>T0 <span class="op">=</span> Constant(<span class="fl">853.15</span>)</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>Ti <span class="op">=</span> Constant(<span class="fl">1013.15</span>)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>T.interpolate(Ti)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>bc <span class="op">=</span> [DirichletBC(V, T0, left),</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>      DirichletBC(V, Ti, right)]</span></code></pre></div>
<p>We now load the material behaviour
<code>HeatTransferPhaseChange</code> and also change the default value
of <code>Tsmooth</code> to a slightly larger one (but still sufficiently
small). Note that the mesh must be sufficiently refined to use a smaller
value. Indeed, the spatial resolution must be able to capture with a few
elements the sharp transition which will occur during the phase change.
We also verify that 3 different tangent blocks have indeed been defined,
the last one involving the internal state variable <code>Enthalpy</code>
with respect to the temperature.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>material <span class="op">=</span> mf.MFrontNonlinearMaterial(<span class="st">&quot;./src/libBehaviour.so&quot;</span>,</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>                                      <span class="st">&quot;HeatTransferPhaseChange&quot;</span>,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>                                      hypothesis<span class="op">=</span><span class="st">&quot;plane_strain&quot;</span>,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>                                       parameters<span class="op">=</span>{<span class="st">&quot;Tsmooth&quot;</span>: <span class="fl">1.</span>})</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>([<span class="st">&quot;d</span><span class="sc">{}</span><span class="st">_d</span><span class="sc">{}</span><span class="st">&quot;</span>.<span class="bu">format</span>(<span class="op">*</span>t) <span class="cf">for</span> t <span class="kw">in</span> material.get_tangent_block_names()])</span></code></pre></div>
<pre><code>[&#39;dHeatFlux_dTemperatureGradient&#39;, &#39;dHeatFlux_dTemperature&#39;, &#39;dEnthalpy_dTemperature&#39;]</code></pre>
<h2 id="time-discretization-of-the-heat-equation">Time discretization of
the heat equation</h2>
<p>The heat equation must also be discretized in time. We use here the
<span class="math inline">\(\theta\)</span>-method and approximate:</p>
<p><span class="math display">\[
\left.\dfrac{\partial h}{\partial t}\right|_{t=t_{n+\theta}} \approx
\dfrac{h_{t=t_{n+1}}-h_{t=t_{n}}}{\Delta t} =
r_{t=t_{n+\theta}}-\operatorname{div}\mathbf{j}_{t=t_{n+\theta}}
\]</span></p>
<p>where <span class="math inline">\(\star_{t=t_{n+\theta}}=
\theta\star_{t=t_{n+1}}+(1-\theta)\star_{t=t_{n}}\)</span>.</p>
<p>The weak formulation therefore reads (in the absence of source
terms):</p>
<p>Find <span class="math inline">\(T\in V\)</span> such that: <span
class="math display">\[
\int_\Omega \left((h_{t=t_{n+1}}(T)-h_{t=t_{n}})\widehat{T} - \Delta t
(\theta\mathbf{j}_{t=t_{n+1}}(T, \nabla
T)+(1-\theta)\mathbf{j}_{t=t_{n}})\cdot \nabla \widehat{T} \right)\text{
dx} = 0
\]</span></p>
<p>in which, at time <span class="math inline">\(t_{n+1}\)</span>, both
the enthalpy <span class="math inline">\(h_{t=t_{n+1}}\)</span> and the
heat flux <span class="math inline">\(\mathbf{j}_{t=t_{n+1}}\)</span>
are non-linear functions of the unknown temperature.</p>
<h2 id="problem-formulation">Problem formulation</h2>
<p>We therefore see that the above non-linear problem does not fit into
the default form of a <code>MFrontNonlinearProblem</code> residual. We
will therefore have to specify its form manually. To do so, we need to
get the functions <code>h</code> and <code>j</code> associated to the
current values of the enthalpy and the heat flux.</p>
<p>Second, we must call the <code>initialize</code> method which
initializes the functions associated with gradients, fluxes, external
and internal state variables objects and the corresponding tangent
blocks. All gradients and external state variables must have been
registered before calling this method. In this case, we rely on the
automatic registration of the temperature and its gradient.</p>
<p>Finally, to implement the <span class="math inline">\(\theta\)</span>
time discretization scheme, we will also need to keep track of the
enthalpy and heat flux values at the previous time step. We can simply
define these new functions as deep copies of <code>h</code> and
<code>j</code>. Doing so, <code>h_old</code> and <code>j_old</code> will
also be Quadrature functions.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> mf.MFrontNonlinearProblem(T, material, quadrature_degree<span class="op">=</span><span class="dv">2</span>, bcs<span class="op">=</span>bc)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> problem.get_state_variable(<span class="st">&quot;Enthalpy&quot;</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>j <span class="op">=</span> problem.get_flux(<span class="st">&quot;HeatFlux&quot;</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>problem.initialize()</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>j_old <span class="op">=</span> j.copy(deepcopy<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>h_old <span class="op">=</span> h.copy(deepcopy<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
<pre><code>    Automatic registration of &#39;TemperatureGradient&#39; as grad(Temperature).
    
    Automatic registration of &#39;Temperature&#39; as an external state variable.</code></pre>
<h2 id="residual-definition-and-tangent-form-computation">Residual
definition and tangent form computation</h2>
<p>We are now ready to define the expression of the above residual. Note
that we must use the integration measure <code>dx</code> associated with
the <code>MFrontNonlinearProblem</code> containing the correct
quadrature degree matching that of the various Quadrature functions.
Finally, the tangent form can be automatically computed using the
<code>compute_tangent_form</code> method from the residual expression
and the structure of the different tangent blocks.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> Constant(<span class="fl">0.</span>)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>theta <span class="op">=</span> Constant(<span class="fl">1.</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>T_ <span class="op">=</span> TestFunction(V)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>j_theta <span class="op">=</span> theta<span class="op">*</span>j <span class="op">+</span> (<span class="dv">1</span><span class="op">-</span>theta)<span class="op">*</span>j_old</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>problem.residual <span class="op">=</span> (T_<span class="op">*</span>(h <span class="op">-</span> h_old)<span class="op">-</span>dt<span class="op">*</span>dot(grad(T_), j_theta))<span class="op">*</span>problem.dx</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>problem.compute_tangent_form()</span></code></pre></div>
<h2
id="time-stepping-loop-and-comparison-with-code_aster-results">Time-stepping
loop and comparison with <code>code_aster</code> results</h2>
<p>We now implement the time-stepping loop which simply solves the
non-linear problem and update the fields corresponding to the values at
the previous time step. We also load the values of the one-dimensional
temperature field <span class="math inline">\(T(x, t)\)</span> given in
the <code>code_aster</code> test-case and compare them with what we
obtain every second.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>cA_results <span class="op">=</span> np.loadtxt(<span class="st">&quot;results_code_Aster.csv&quot;</span>, delimiter<span class="op">=</span><span class="st">&quot;,&quot;</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>code_Aster_times <span class="op">=</span> np.arange(<span class="dv">1</span>, <span class="dv">7</span>)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>Nsteps <span class="op">=</span> <span class="dv">60</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>times <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="fl">6.</span>, Nsteps<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (t, delta_t) <span class="kw">in</span> <span class="bu">zip</span>(times[<span class="dv">1</span>:], np.diff(times)):</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    dt.assign(Constant(delta_t))</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    problem.solve(T.vector())</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    h_old.assign(h) <span class="co"># update enthalpy</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    j_old.assign(j) <span class="co"># update heat flux</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    sol_time <span class="op">=</span> np.isclose(t, code_Aster_times)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">any</span>(sol_time):</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        plt.figure()</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        plt.title(<span class="st">&quot;Time </span><span class="sc">{:0.1f}</span><span class="st">s&quot;</span>.<span class="bu">format</span>(t), fontsize<span class="op">=</span><span class="dv">16</span>)</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        ax1 <span class="op">=</span> plt.gca()</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>        ax1.set_xlabel(<span class="st">&#39;$x$ coordinate&#39;</span>)</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        ax1.set_ylabel(<span class="st">&#39;Temperature [°C]&#39;</span>)</span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>        ax1.plot(x, np.array([T(xi, width<span class="op">/</span><span class="dv">2</span>)<span class="op">-</span><span class="fl">273.15</span> <span class="cf">for</span> xi <span class="kw">in</span> x]), <span class="st">&quot;-b&quot;</span>, label<span class="op">=</span><span class="st">&quot;FEniCS/MFront&quot;</span>)</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        ax1.plot(cA_results[:, <span class="dv">0</span>], cA_results[:, np.where(sol_time)[<span class="dv">0</span>]<span class="op">+</span><span class="dv">1</span>], <span class="st">&quot;or&quot;</span>, label<span class="op">=</span><span class="st">&quot;Code\_Aster&quot;</span>)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        Tm <span class="op">=</span> material.get_parameter(<span class="st">&quot;MeltingTemperature&quot;</span>) <span class="op">-</span> <span class="fl">273.15</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>        ax1.plot(x, Tm <span class="op">+</span> <span class="dv">0</span><span class="op">*</span>x, <span class="st">&quot;--k&quot;</span>)</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>        ax1.annotate(<span class="st">&quot;liquid</span><span class="ch">\n</span><span class="st">solid&quot;</span>, xy<span class="op">=</span>(<span class="fl">0.08</span>, Tm), fontsize<span class="op">=</span><span class="dv">16</span>, va<span class="op">=</span><span class="st">&quot;center&quot;</span>)</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>        plt.legend()</span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>        plt.show()</span></code></pre></div>
<pre><code>    &lt;IPython.core.display.Javascript object&gt;</code></pre>
<p><img src="img/HeatEquationPhaseChange-1.png"
style="width:75.0%" /></p>
<pre><code>    &lt;IPython.core.display.Javascript object&gt;</code></pre>
<p><img src="img/HeatEquationPhaseChange-2.png"
style="width:75.0%" /></p>
<pre><code>    &lt;IPython.core.display.Javascript object&gt;</code></pre>
<p><img src="img/HeatEquationPhaseChange-3.png"
style="width:75.0%" /></p>
<pre><code>    &lt;IPython.core.display.Javascript object&gt;</code></pre>
<p><img src="img/HeatEquationPhaseChange-4.png"
style="width:75.0%" /></p>
<pre><code>    &lt;IPython.core.display.Javascript object&gt;</code></pre>
<p><img src="img/HeatEquationPhaseChange-5.png"
style="width:75.0%" /></p>
<pre><code>    &lt;IPython.core.display.Javascript object&gt;</code></pre>
<p><img src="img/HeatEquationPhaseChange-6.png"
style="width:75.0%" /></p>
</body>
</html>
