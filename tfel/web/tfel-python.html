

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-EN" xml:lang="en-EN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Overview of the TFEL modules</title>
        <meta name="author" content="Thomas Helfer" />
            <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
    <style type="text/css">code{white-space: pre;}</style>
            <style type="text/css">
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f8f8f8; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ef2929; } /* Alert */
      code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #204a87; } /* Attribute */
      code span.bn { color: #0000cf; } /* BaseN */
      code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4e9a06; } /* Char */
      code span.cn { color: #8f5902; } /* Constant */
      code span.co { color: #8f5902; font-style: italic; } /* Comment */
      code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
      code span.dt { color: #204a87; } /* DataType */
      code span.dv { color: #0000cf; } /* DecVal */
      code span.er { color: #a40000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #0000cf; } /* Float */
      code span.fu { color: #204a87; font-weight: bold; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
      code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
      code span.ot { color: #8f5902; } /* Other */
      code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
      code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
      code span.ss { color: #4e9a06; } /* SpecialString */
      code span.st { color: #4e9a06; } /* String */
      code span.va { color: #000000; } /* Variable */
      code span.vs { color: #4e9a06; } /* VerbatimString */
      code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
    </style>
            <link rel="stylesheet" href="css/normalize.css"/>
    <link rel="stylesheet" href="css/main.css"/>
        <script
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
        type="text/javascript"></script>
            
      </head>
  <body>
    <!--[if lt IE 7]>
        <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]-->
        <header>
      <ul id="nav">
	<li><a href="news.html">News</a></li>
	<li><a href="index.html">Overview</a>
	  <ul>
	    <li><a>Domain specific languages</a>
	      <ul>
		<li><a href="material-properties.html">Material properties</a></li>
		<li><a href="behaviours.html">Mechanical behaviours</a></li>
		<li><a href="models.html">Models</a></li>
	      </ul>
            </li>
	    <li><a href="interfaces.html">Available interfaces</a></li>
	    <li><a href="associated-projects.html">Associated projects</a></li>
     	    <li><a>Tools</a>
	      <ul>
	        <li><a href="mfront-doc.html">mfront-doc</a></li>
	        <li><a href="mtest.html">mtest</a></li>
	        <li><a href="mfm.html">mfm</a></li>
	        <li><a href="mfm-test-generator.html">mfm-test-generator</a></li>
	        <li><a href="tfel-check.html">tfel-check</a></li>
	      </ul>
	    </li>
	  </ul>
	</li>
	<li><a>Getting started</a>
	  <ul>
	    <li><a href="https://github.com/thelfer/tfel/">Github repository</a></li>
	    <li><a href="https://github.com/thelfer/tfel/releases">Download</a></li>
	    <li><a href="release-notes.html">Release notes</a>
	      <ul>
		<li><a>Versions 2.0.x</a>
                  <ul>
                    <li><a href="release-notes.html">Versions prior to 2.0.5</a></li>
	 	    <li><a href="release-notes-2.0.5.html">Version 2.0.5</a></li>
                  </ul>
		</li>
		<li><a>Versions 3.0.x</a>
                  <ul>
		    <li><a href="release-notes-3.0.html">Version 3.0.0</a></li>
		    <li><a href="release-notes-3.0.1.html">Version 3.0.1</a></li>
		    <li><a href="release-notes-3.0.2.html">Version 3.0.2</a></li>
		    <li><a href="release-notes-3.0.3.html">Version 3.0.3</a></li>
		    <li><a href="release-notes-3.0.4.html">Version 3.0.4</a></li>
		    <li><a href="release-notes-3.0.5.html">Version 3.0.5</a></li>
		    <li><a href="release-notes-3.0.6.html">Version 3.0.6</a></li>
		    <li><a href="release-notes-3.0.7.html">Version 3.0.7</a></li>
		    <li><a href="release-notes-3.0.8.html">Version 3.0.8</a></li>
		    <li><a href="release-notes-3.0.9.html">Version 3.0.9</a></li>
		    <li><a href="release-notes-3.0.10.html">Version 3.0.10</a></li>
		    <li><a href="release-notes-3.0.11.html">Version 3.0.11</a></li>
		    <li><a href="release-notes-3.0.12.html">Version 3.0.12</a></li>
		    <li><a href="release-notes-3.0.13.html">Version 3.0.13</a></li>
		    <li><a href="release-notes-3.0.14.html">Version 3.0.14</a></li>
		    <li><a href="release-notes-3.0.15.html">Version 3.0.15</a></li>
		    <li><a href="release-notes-3.0.16.html">Version 3.0.16</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.1.x</a>
		  <ul>
		    <li><a href="release-notes-3.1.html">Version 3.1.0</a></li>
		    <li><a href="release-notes-3.1.1.html">Version 3.1.1</a></li>
		    <li><a href="release-notes-3.1.2.html">Version 3.1.2</a></li>
		    <li><a href="release-notes-3.1.3.html">Version 3.1.3</a></li>
		    <li><a href="release-notes-3.1.4.html">Version 3.1.4</a></li>
		    <li><a href="release-notes-3.1.5.html">Version 3.1.5</a></li>
		    <li><a href="release-notes-3.1.6.html">Version 3.1.6</a></li>
		    <li><a href="release-notes-3.1.7.html">Version 3.1.7</a></li>
		    <li><a href="release-notes-3.1.8.html">Version 3.1.8</a></li>
		    <li><a href="release-notes-3.1.9.html">Version 3.1.9</a></li>
		    <li><a href="release-notes-3.1.10.html">Version 3.1.10</a></li>
		    <li><a href="release-notes-3.1.11.html">Version 3.1.11</a></li>
		    <li><a href="release-notes-3.1.12.html">Version 3.1.12</a></li>
		    <li><a href="release-notes-3.1.13.html">Version 3.1.13</a></li>
		    <li><a href="release-notes-3.1.14.html">Version 3.1.14</a></li>
		    <li><a href="release-notes-3.1.15.html">Version 3.1.15</a></li>
		    <li><a href="release-notes-3.1.16.html">Version 3.1.16</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.2.x</a>
		  <ul>
		    <li><a href="release-notes-3.2.html">Version 3.2.0</a></li>
		    <li><a href="release-notes-3.2.1.html">Version 3.2.1</a></li>
		    <li><a href="release-notes-3.2.2.html">Version 3.2.2</a></li>
		    <li><a href="release-notes-3.2.3.html">Version 3.2.3</a></li>
		    <li><a href="release-notes-3.2.4.html">Version 3.2.4</a></li>
		    <li><a href="release-notes-3.2.5.html">Version 3.2.5</a></li>
		    <li><a href="release-notes-3.2.6.html">Version 3.2.6</a></li>
		    <li><a href="release-notes-3.2.7.html">Version 3.2.7</a></li>
		    <li><a href="release-notes-3.2.8.html">Version 3.2.8</a></li>
		    <li><a href="release-notes-3.2.9.html">Version 3.2.9</a></li>
		    <li><a href="release-notes-3.2.10.html">Version 3.2.10</a></li>
		    <li><a href="release-notes-3.2.11.html">Version 3.2.11</a></li>
		    <li><a href="release-notes-3.2.12.html">Version 3.2.12</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.3.x</a>
		  <ul>
		    <li><a href="release-notes-3.3.html">Version 3.3.0</a></li>
		    <li><a href="release-notes-3.3.1.html">Version 3.3.1</a></li>
		    <li><a href="release-notes-3.3.1.html">Version 3.3.2</a></li>
		    <li><a href="release-notes-3.3.2.html">Version 3.3.2</a></li>
		    <li><a href="release-notes-3.3.3.html">Version 3.3.3</a></li>
		    <li><a href="release-notes-3.3.4.html">Version 3.3.4</a></li>
		    <li><a href="release-notes-3.3.5.html">Version 3.3.5</a></li>
		    <li><a href="release-notes-3.3.6.html">Version 3.3.6</a></li>
		    <li><a href="release-notes-3.3.7.html">Version 3.3.7</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.4.x</a>
		  <ul>
		    <li><a href="release-notes-3.4.html">Version 3.4.0</a></li>
		    <li><a href="release-notes-3.4.1.html">Version 3.4.1</a></li>
		    <li><a href="release-notes-3.4.2.html">Version 3.4.2</a></li>
		    <li><a href="release-notes-3.4.3.html">Version 3.4.3</a></li>
		    <li><a href="release-notes-3.4.4.html">Version 3.4.4</a></li>
		    <li><a href="release-notes-3.4.5.html">Version 3.4.5</a></li>
		    <li><a href="release-notes-3.4.6.html">Version 3.4.6</a></li>
		    <li><a href="release-notes-3.4.7.html">Version 3.4.7</a></li>
		    <li><a href="release-notes-3.4.8.html">Version 3.4.8</a></li>
		    <li><a href="release-notes-3.4.9.html">Version 3.4.9</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.0.x</a>
		  <ul>
		    <li><a href="release-notes-4.0.html">Version 4.0.0</a></li>
		    <li><a href="release-notes-4.0.1.html">Version 4.0.1</a></li>
		    <li><a href="release-notes-4.0.2.html">Version 4.0.2</a></li>
		    <li><a href="release-notes-4.0.3.html">Version 4.0.3</a></li>
		    <li><a href="release-notes-4.0.4.html">Version 4.0.4</a></li>
		    <li><a href="release-notes-4.0.5.html">Version 4.0.5</a></li>
		    <li><a href="release-notes-4.0.6.html">Version 4.0.6</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.1.x</a>
		  <ul>
		    <li><a href="release-notes-4.1.html">Version 4.1.0</a></li>
		    <li><a href="release-notes-4.1.1.html">Version 4.1.1</a></li>
		    <li><a href="release-notes-4.1.2.html">Version 4.1.2</a></li>
		    <li><a href="release-notes-4.1.3.html">Version 4.1.3</a></li>
		    <li><a href="release-notes-4.1.4.html">Version 4.1.4</a></li>
		    <li><a href="release-notes-4.1.5.html">Version 4.1.5</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.2.x</a>
		  <ul>
		    <li><a href="release-notes-4.2.html">Version 4.2.0</a></li>
		    <li><a href="release-notes-4.2.1.html">Version 4.2.1</a></li>
		    <li><a href="release-notes-4.2.2.html">Version 4.2.2</a></li>
		    <li><a href="release-notes-4.2.3.html">Version 4.2.3</a></li>
		  </ul>
		</li>
		<li><a>Versions 5.0.x</a>
		  <ul>
		    <li><a href="release-notes-5.0.html">Version 5.0.0</a></li>
		    <li><a href="release-notes-5.0.1.html">Version 5.0.1</a></li>
		    <li><a href="release-notes-5.0.2.html">Version 5.0.2</a></li>
		  </ul>
		</li>
		<li><a>Versions 5.1.x</a>
		  <ul>
		    <li><a href="release-notes-5.1.html">Version 5.1.0</a></li>
		  </ul>
		</li>
	      </ul>
	    </li>
	    <li><a href="coverity-scan.html">Coverity scan</a></li>
	    <li><a href="install.html">Installation</a></li>
	  </ul>
	</li>
	<li><a>Documentation</a>
	  <ul>
	    <li><a href="documentations.html">General documentation</a></li>
	    <li><a href="gallery.html">Gallery</a></li>
<!--	    
	    <li><a href="http://tfel.sourceforge.net/doxygen/index.html">Doxygen documentation</a></li>
-->
	    <li><a>Behaviours</a>
	      <ul>
		<li><a href="tutorial.html">Tutorial</a></li>
		<li><a href="implicit-dsl.html">The Implicit DSL</a></li>
		<li><a href="benchmark.html">Benchmark</a></li>
		<li><a href="parameters.html">Parameters</a></li>
		<li><a href="BehaviourBricks.html">Behaviour bricks</a></li>
		<li><a href="interfaces.html">Solver interfaces</a>
		  <ul>
		    <li><a href="castem.html">Cast3M</a></li>
		    <li><a href="amitex.html">AMITEX_FFTP</a></li>
		    <li><a href="aster.html">Code-Aster</a></li>
    		    <li><a href="abaqus.html">Abaqus</a></li>
		    <li><a href="zmat.html">ZeBuLoN</a></li>
   		    <li><a href="calculix.html">CalculiX</a></li>
		    <!-- <li><a >TMFFT</a></li> -->
		    <li><a href="cyrano.html">Cyrano</a></li>
   		    <li><a href="generic-material-property-interface.html">Generic interface for material properties</a></li>
   		    <li><a href="generic-behaviours-interface.html">Generic interface for behaviours</a></li>
		  </ul>
		</li>
	      </ul>
	    </li>
	    <li><a>TFEL libraries</a>
	      <ul>
		<li><a href="libraries_usage.html">Usage of the TFEL libraries in C++</a></li>
		<li><a href="tfel-math.html">TFEL/Math</a></li>
		<li><a href="tfel-material.html">TFEL/Material</a></li>
		<li><a href="tfel-mfront-database.html">TFELMFrontDatabase</a></li>
	      </ul>
	    </li>
	    <li><a>Python modules</a>
	      <ul>
		<li><a href="tfel-python.html">TFEL modules</a></li>
		<li><a href="mfront-python.html">mfront module</a></li>
		<li><a href="mtest-python.html">mtest module</a></li>
	      </ul>
	    </li>
	    <li><a>MFront keywords</a>
	      <ul>
	        <li><a href="Default-keywords.html">Default</a></li>
	        <li><a href="DefaultCZM-keywords.html">DefaultCZM</a></li>
	        <li><a href="DefaultFiniteStrain-keywords.html">DefaultFiniteStrain</a></li>
	        <li><a href="DefaultGenericBehaviour-keywords.html">DefaultGenericBehaviour</a></li>
	        <li><a href="DefaultModel-keywords.html">DefaultModel</a></li>
	        <li><a href="Implicit-keywords.html">Implicit</a></li>
	        <li><a href="ImplicitCZM-keywords.html">ImplicitCZM</a></li>
	        <li><a href="ImplicitFiniteStrain-keywords.html">ImplicitFiniteStrain</a></li>
	        <li><a href="ImplicitGenericBehaviour-keywords.html">ImplicitGenericBehaviour</a></li>
	        <li><a href="ImplicitModel-keywords.html">ImplicitModel</a></li>
	        <li><a href="ImplicitII-keywords.html">ImplicitII</a></li>
	        <li><a href="IsotropicMisesCreep-keywords.html">IsotropicMisesCreep</a></li>
	        <li><a href="IsotropicMisesPlasticFlow-keywords.html">IsotropicMisesPlasticFlow</a></li>
	        <li><a href="IsotropicPlasticMisesFlow-keywords.html">IsotropicPlasticMisesFlow</a></li>
	        <li><a href="IsotropicStrainHardeningMisesCreep-keywords.html">IsotropicStrainHardeningMisesCreep</a></li>
	        <li><a href="MaterialLaw-keywords.html">MaterialLaw</a></li>
	        <li><a href="MaterialProperty-keywords.html">MaterialProperty</a></li>
	        <li><a href="Model-keywords.html">Model</a></li>
	        <li><a href="MultipleIsotropicMisesFlows-keywords.html">MultipleIsotropicMisesFlows</a></li>
	        <li><a href="RungeKutta-keywords.html">RungeKutta</a></li>
	        <li><a href="RungeKuttaFiniteStrain-keywords.html">RungeKuttaFiniteStrain</a></li>
	        <li><a href="RungeKuttaGenericBehaviour-keywords.html">RungeKuttaGenericBehaviour</a></li>
	        <li><a href="RungeKuttaModel-keywords.html">RungeKuttaModel</a></li>
	      </ul>
	    </li>
	    <li><a href="MTest-keywords.html">MTest keywords</a></li>
	    <li><a href="physical-constants.html">Physical constants</a></li>
	    <li><a href="glossary.html">Glossary</a></li>
	    <li><a href="publications.html">Publications</a></li>
	    <li><a href="faq.html">FAQ</a></li>
	    <li><a href="about.html">About</a></li>
	  </ul>
	</li>
	<li><a>Contributing</a>
	  <ul>
	    <li><a href="https://github.com/thelfer/tfel">Access to sources</a></li>
	    <li><a href="contributing.html">Contributing guidelines</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Report bugs</a></li>
	  </ul>
	</li>
	<li><a>Getting Help</a>
	  <ul>
	    <li><a href="search.html">Search on this site</a></li>
	    <li><a href="https://github.com/thelfer/tfel/discussions">Forum</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Bug report</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Feature request</a></li>
	    <li><a href="mailto:tfel-contact@cea.fr">Contact</a></li>
	  </ul>
	</li>
      </ul>
    </header>
<div id="header">
<h1 class="title">Overview of the <code>TFEL</code> modules</h1>
<h2 class="author">Thomas Helfer</h2>
<h3 class="date">19/12/2017</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#the-tfel.math-module" id="toc-the-tfel.math-module">The
<code>tfel.math</code> module</a>
<ul>
<li><a href="#bindings-related-to-the-tvector-class"
id="toc-bindings-related-to-the-tvector-class">Bindings related to the
<code>tvector</code> class</a></li>
<li><a href="#bindings-related-to-the-stensor-class"
id="toc-bindings-related-to-the-stensor-class">Bindings related to the
<code>stensor</code> class</a></li>
<li><a href="#bindings-related-to-the-st2tost2-class"
id="toc-bindings-related-to-the-st2tost2-class">Bindings related to the
<code>st2tost2</code> class</a></li>
</ul></li>
<li><a href="#the-tfel.material-module"
id="toc-the-tfel.material-module">The <code>tfel.material</code>
module</a>
<ul>
<li><a href="#bindings-related-to-the-pi-plane"
id="toc-bindings-related-to-the-pi-plane">Bindings related to the <span
class="math inline">\(\pi\)</span>-plane</a></li>
<li><a href="#bindings-related-to-the-hosford-equivalent-stress"
id="toc-bindings-related-to-the-hosford-equivalent-stress">Bindings
related to the Hosford equivalent stress</a></li>
<li><a href="#bindings-related-to-the-barlat-equivalent-stress"
id="toc-bindings-related-to-the-barlat-equivalent-stress">Bindings
related to the Barlat equivalent stress</a></li>
<li><a href="#bindings-related-to-the-isotropicmoduli"
id="toc-bindings-related-to-the-isotropicmoduli">Bindings related to the
<code>IsotropicModuli</code></a></li>
<li><a href="#the-tfel.material.homogenization-module"
id="toc-the-tfel.material.homogenization-module">The
<code>tfel.material.homogenization</code> module</a>
<ul>
<li><a href="#hill-tensors" id="toc-hill-tensors">Hill tensors</a></li>
<li><a href="#localisation-tensors"
id="toc-localisation-tensors">Localisation tensors</a></li>
<li><a href="#homogenization-schemes-in-biphasic-media"
id="toc-homogenization-schemes-in-biphasic-media">Homogenization schemes
in biphasic media</a></li>
<li><a href="#homogenization-bounds"
id="toc-homogenization-bounds">Homogenization bounds</a></li>
<li><a href="#homogenization-of-general-microstructures"
id="toc-homogenization-of-general-microstructures">Homogenization of
general microstructures</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<p>This page describes the <code>python</code> modules based on the
<code>TFEL</code> libraries.</p>
<h1 id="the-tfel.math-module">The <code>tfel.math</code> module</h1>
<h2 id="bindings-related-to-the-tvector-class">Bindings related to the
<code>tvector</code> class</h2>
<p>Three classes standing for vectors are available:
<code>TVector1D</code>, <code>TVector2D</code> and
<code>TVector3D</code>. These <code>class</code> can be
initialized/modified as follows:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tfel.math <span class="im">as</span> tm</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>n1<span class="op">=</span>tm.TVector3D([<span class="fl">1.</span>,<span class="fl">0.</span>,<span class="fl">0.</span>])</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>n2<span class="op">=</span>tm.TVector3D()</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>n2[<span class="dv">0</span>]<span class="op">=</span><span class="fl">1.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>n3_<span class="op">=</span>np.array([<span class="fl">1.</span>,<span class="fl">0.</span>,<span class="fl">0.</span>])</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>n3<span class="op">=</span>tm.TVector3D(n3_)</span></code></pre></div>
<h2 id="bindings-related-to-the-stensor-class">Bindings related to the
<code>stensor</code> class</h2>
<p>Three classes standing for symmetric tensors are available:
<code>Stensor1D</code>, <code>Stensor2D</code> and
<code>Stensor3D</code>. These <code>class</code> can be
initialized/modified as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tfel.math <span class="im">as</span> tm</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>s1<span class="op">=</span>tm.Stensor3D([<span class="fl">1.</span>,<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">0.</span>])</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>s2<span class="op">=</span>tm.Stensor2D([<span class="fl">1.</span>,<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">0.</span>])</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>sig<span class="op">=</span>tm.Stensor3D()</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>sig[<span class="dv">2</span>]<span class="op">=</span><span class="fl">1.e9</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>epsilon<span class="op">=</span>np.zeros((<span class="dv">6</span>,))</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>epsilon[<span class="dv">0</span>]<span class="op">=</span><span class="fl">0.001</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>eps<span class="op">=</span>tm.Stensor3D(epsilon)</span></code></pre></div>
<p>The standard mathematical operations are defined:</p>
<ul>
<li>addition of two symmetric tensors.</li>
<li>subtraction of two symmetric tensors.</li>
<li>multiplication by scalar.</li>
<li>in-place addition by a symmetric tensor.</li>
<li>in-place subtraction by a symmetric tensor.</li>
<li>in-place multiplication by scalar.</li>
<li>in-place division by scalar.</li>
</ul>
<p>The following functions are available:</p>
<ul>
<li><code>sigmaeq</code>: computes the von Mises norm of a symmetric
tensor.</li>
<li><code>tresca</code>: computes the Tresca norm of a symmetric
tensor.</li>
</ul>
<h2 id="bindings-related-to-the-st2tost2-class">Bindings related to the
<code>st2tost2</code> class</h2>
<p>Three classes standing for fourth-order tensors with minor symmetries
are available: <code>ST2toST21D</code>, <code>ST2toST22D</code>,
<code>ST2toST23D</code>. These <code>class</code> can be
initialized/modified as follows:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tfel.math <span class="im">as</span> tm</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>s1<span class="op">=</span>tm.ST2toST22D([[<span class="fl">1.</span>,<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">0.</span>],[<span class="fl">0.</span>,<span class="fl">1.</span>,<span class="fl">0.</span>,<span class="fl">0.</span>],[<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">1.</span>,<span class="fl">0.</span>],[<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">1.</span>]])</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>C<span class="op">=</span>tm.ST2toST23D()</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>C[<span class="dv">2</span>,<span class="dv">2</span>]<span class="op">=</span><span class="fl">1.e9</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>A<span class="op">=</span>np.zeros((<span class="dv">6</span>,<span class="dv">6</span>))</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>A[<span class="dv">0</span>,<span class="dv">1</span>]<span class="op">=</span><span class="fl">0.001</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>A_<span class="op">=</span>tm.ST2toST23D(A)</span></code></pre></div>
<h1 id="the-tfel.material-module">The <code>tfel.material</code>
module</h1>
<h2 id="bindings-related-to-the-pi-plane">Bindings related to the <span
class="math inline">\(\pi\)</span>-plane</h2>
<p>The following functions are available:</p>
<ul>
<li><code>buildFromPiPlane</code>: returns a tuple containing the three
eigenvalues of the stress corresponding to the given point in the <span
class="math inline">\(\pi\)</span>-plane.</li>
<li><code>projectOnPiPlane</code>: projects a stress state, defined its
three eigenvalues or by a symmetric tensor, on the <span
class="math inline">\(\pi\)</span>-plane.</li>
</ul>
<h2 id="bindings-related-to-the-hosford-equivalent-stress">Bindings
related to the Hosford equivalent stress</h2>
<p>The <code>computeHosfordStress</code> function, which compute the
Hosford equivalent stress, is available.</p>
<h2 id="bindings-related-to-the-barlat-equivalent-stress">Bindings
related to the Barlat equivalent stress</h2>
<p>The following functions are available:</p>
<ul>
<li><code>makeBarlatLinearTransformation1D</code>: builds a <span
class="math inline">\(1D\)</span> linear transformation of the stress
tensor.</li>
<li><code>makeBarlatLinearTransformation2D</code>: builds a <span
class="math inline">\(2D\)</span> linear transformation of the stress
tensor.</li>
<li><code>makeBarlatLinearTransformation3D</code>: builds a <span
class="math inline">\(3D\)</span> linear transformation of the stress
tensor.</li>
<li><code>computeBarlatStress</code>: computes the Barlat equivalent
Barlat stress.</li>
</ul>
<h2 id="bindings-related-to-the-isotropicmoduli">Bindings related to the
<code>IsotropicModuli</code></h2>
<p>The three following <code>class</code> are available:
<code>KGModuli</code>, <code>YoungNuModuli</code> and
<code>LambdaMuModuli</code>. They can be constructed as:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tfel.material <span class="im">as</span> tmat</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>K<span class="op">=</span><span class="fl">1e9</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>G<span class="op">=</span><span class="fl">0.2e9</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>kg<span class="op">=</span>tmat.KGModuli(K,G)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>kg2<span class="op">=</span>tmat.KGModuli(kg)</span></code></pre></div>
<p>their attributes are accessible and their methods permit to convert
them:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>kg<span class="op">=</span>tmat.KGModuli(<span class="fl">3e6</span>,<span class="fl">2e6</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(kg.kappa,kg.mu)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>Enu<span class="op">=</span>tmat.YoungNuModuli(<span class="fl">1e6</span>,<span class="fl">0.2</span>)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Enu.young,Enu.nu)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>lg<span class="op">=</span>tmat.LambdaMuModuli(<span class="fl">0.5e6</span>,<span class="fl">1e6</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(lg.lamb,lg.mu)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>Enu2<span class="op">=</span>kg.ToYoungNu()</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Enu2.young,Enu2.nu)</span></code></pre></div>
<p>Note that Lam√© coefficient is <code>lamb</code> in
<code>Python</code> and <code>lambda</code> in <code>C++</code>.</p>
<h2 id="the-tfel.material.homogenization-module">The
<code>tfel.material.homogenization</code> module</h2>
<p>The <code>tfel.material.homogenization</code> module mirrors the
functionalities defined in the namespace
<code>tfel::material::homogenization::elasticity</code>. Hence, the
reader may be interested by the <a
href="tfel-material.html#homogenization">details</a> of the
documentation of this namespace. The <code>Python</code> modules can be
imported as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tfel.material.homogenization <span class="im">as</span> hm</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tfel.material <span class="im">as</span> tmat</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> tfel.math <span class="im">as</span> tm</span></code></pre></div>
<h3 id="hill-tensors">Hill tensors</h3>
<p>The Hill tensors are available:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>young<span class="op">=</span><span class="fl">1e9</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>nu<span class="op">=</span><span class="fl">0.2</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>P0<span class="op">=</span>hm.computeSphereHillTensor(young,nu)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>e<span class="op">=</span><span class="fl">10.</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span>tm.TVector3D([<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">1.</span>])</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>P1<span class="op">=</span>hm.computeAxisymmetricalHillTensor(young,nu,n,e)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>n_a<span class="op">=</span>tm.TVector3D([<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">1.</span>])</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>n_b<span class="op">=</span>tm.TVector3D([<span class="fl">0.</span>,<span class="fl">1.</span>,<span class="fl">0.</span>])</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span><span class="fl">10.</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>b<span class="op">=</span><span class="fl">1.</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>c<span class="op">=</span><span class="fl">3.</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>P2<span class="op">=</span>hm.computeHillTensor(young,nu,n_a,a,n_b,b,c)</span></code></pre></div>
<p>Note that the above functions have slightly different names from the
<code>C++</code> version: <code>computeHillPolarisationTensor</code>
becomes <code>computeHillTensor</code>. Moreover, as in
<code>C++</code>, it is possible to pass isotropic moduli objects
instead of <code>young</code> and <code>nu</code>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>IM0<span class="op">=</span>tmat.YoungNuModuli(young,nu)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>P0 <span class="op">=</span> hm.computeSphereHillTensor(IM0)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>P0_axi <span class="op">=</span> hm.computeAxisymmetricalHillTensor(IM0,n_a,e)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>P0_ellipsoid <span class="op">=</span> hm.computeHillTensor(IM0,n_a,a,n_b,b,c)</span></code></pre></div>
<p>The computation in the anisotropic reference medium is given by:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode py"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>C0<span class="op">=</span>tm.ST2toST23D(<span class="fl">1e9</span><span class="op">*</span>np.eye(<span class="dv">6</span>))</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>C0[<span class="dv">0</span>,<span class="dv">2</span>]<span class="op">=</span><span class="fl">0.1e9</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>C0[<span class="dv">2</span>,<span class="dv">0</span>]<span class="op">=</span><span class="fl">0.1e9</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>max_it<span class="op">=</span><span class="dv">14</span> <span class="co">#optional</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>P<span class="op">=</span>hm.computeAnisotropicHillTensor(C0,n_a,a,n_b,b,c,max_it)</span></code></pre></div>
<p>Note that the integer <code>max_it</code> is related to the number of
iterations in the integration process (see the <a
href="tfel-material.html#homogenization">documentation</a> of the
namespace).</p>
<h3 id="localisation-tensors">Localisation tensors</h3>
<p>The computation of the strain localisation tensors are given by:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>young<span class="op">=</span><span class="fl">1e9</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>nu<span class="op">=</span><span class="fl">0.2</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>young_i<span class="op">=</span><span class="fl">100e9</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>nu_i<span class="op">=</span><span class="fl">0.3</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Spherical inclusion</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>A_S<span class="op">=</span>hm.computeSphereLocalisationTensor(young,nu,young_i,nu_i)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Axisymmetric ellipsoidal inclusion (or spheroid)</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>e<span class="op">=</span><span class="fl">20.</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>n<span class="op">=</span>tm.TVector3D([<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">1.</span>])</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>A_AE<span class="op">=</span>hm.computeAxisymmetricalLocalisationTensor(young,nu,young_i,nu_i,n,e)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="co"># General ellipsoidal inclusion</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span><span class="fl">10.</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>b<span class="op">=</span><span class="fl">1.</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>c<span class="op">=</span><span class="fl">3.</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>n_a<span class="op">=</span>tm.TVector3D([<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">1.</span>])</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>n_b<span class="op">=</span>tm.TVector3D([<span class="fl">0.</span>,<span class="fl">1.</span>,<span class="fl">0.</span>])</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>A_GE<span class="op">=</span>hm.computeLocalisationTensor(young,nu,young_i,nu_i,n_a,a,n_b,b,c)</span></code></pre></div>
<p>Some isotropic moduli can also be passed for the elasticities, as
follows:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>IM0<span class="op">=</span>tmat.YoungNuModuli(young,nu)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>IMi<span class="op">=</span>tmat.YoungNuModuli(young_i,nu_i)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>A0 <span class="op">=</span> hm.computeSphereLocalisationTensor(IM0,IMi)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>A0_axi <span class="op">=</span> hm.computeAxisymmetricalLocalisationTensor(IM0,IMi,n_a,e)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>A0_ellipsoid <span class="op">=</span> hm.computeLocalisationTensor(IM0,IMi,n_a,a,n_b,b,c)</span></code></pre></div>
<p>Note that if the elasticity of the inclusion is not isotropic, an
anisotropic elasticity <code>C_i</code> can be provided, assuming that
this elasticiy is expressed in the same basis as the one defined by
<code>n_a,n_b</code> (the local basis of the inclusion):</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>A_aniso <span class="op">=</span> hm<span class="op">.</span>computeLocalisationTensor<span class="op">(</span>IM0<span class="op">,</span>C_i<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">)</span></span></code></pre></div>
<p>The case of an anisotropic reference medium is detailed below:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Anisotropic matrix</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>max_it<span class="op">=</span><span class="dv">12</span> <span class="co">#optional</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>C0_glob<span class="op">=</span>tm.ST2toST23D(<span class="fl">1e9</span><span class="op">*</span>np.eye(<span class="dv">6</span>)) <span class="co"># C0_glob is defined in the basis in which the localisation tensor is returned</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>C0_glob[<span class="dv">0</span>,<span class="dv">2</span>]<span class="op">=</span><span class="fl">0.1e9</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>C0_glob[<span class="dv">2</span>,<span class="dv">0</span>]<span class="op">=</span><span class="fl">0.1e9</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>Ci_loc<span class="op">=</span>tm.ST2toST23D(<span class="fl">1e9</span><span class="op">*</span>np.eye(<span class="dv">6</span>)) <span class="co"># Ci_loc is defined in the basis defined by &#39;n_a&#39; and &#39;n_b&#39;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>A_AN<span class="op">=</span>hm.computeAnisotropicLocalisationTensor(C0_glob,Ci_loc,n_a,a,n_b,b,c,max_it)</span></code></pre></div>
<p>Note that in this case, the elasticity of the inclusion is always
passed as a <code>ST2toST2</code> object <code>C_i_loc</code>. Moreover,
if this elasticity is not isotropic, <code>C_i_loc</code> is expressed
in the same basis as the one defined by <code>n_a,n_b</code> (the local
basis of the inclusion, see the <a
href="tfel-material.html#homogenization">documentation</a> of the
namespace).</p>
<h3 id="homogenization-schemes-in-biphasic-media">Homogenization schemes
in biphasic media</h3>
<p>The following schemes are available for biphasic media with 2
isotropic phases:</p>
<ul>
<li>Mori-Tanaka scheme</li>
<li>dilute scheme</li>
<li>Ponte Castaneda and Willis scheme</li>
</ul>
<p>Here are some examples of computation:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>young<span class="op">=</span><span class="fl">1e9</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>nu<span class="op">=</span><span class="fl">0.2</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>young_i<span class="op">=</span><span class="fl">100e9</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>nu_i<span class="op">=</span><span class="fl">0.3</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>f<span class="op">=</span><span class="fl">0.2</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>IM<span class="op">=</span>tmat.YoungNuModuli(young,nu)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>IMi<span class="op">=</span>tmat.YoungNuModuli(young_i,nu_i)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Spherical inclusions</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>EnuDS<span class="op">=</span>hm.computeSphereDiluteScheme(young,nu,f,young_i,nu_i)</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>EnuMT<span class="op">=</span>hm.computeSphereMoriTanakaScheme(young,nu,f,young_i,nu_i)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>KGDS_IM<span class="op">=</span>hm.computeSphereDiluteScheme(IM,f,IMi)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>KGMT_IM<span class="op">=</span>hm.computeSphereMoriTanakaScheme(IM,f,IMi)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(EnuDS.young,EnuDS.nu,KGDS_IM.kappa,KGDS_IM.mu)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(EnuMT.young,EnuMT.nu,KGMT_IM.kappa,KGMT_IM.mu)</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Ellipsoidal inclusions</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span><span class="fl">10.</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a>b<span class="op">=</span><span class="fl">1.</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>c<span class="op">=</span><span class="fl">3.</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>n_a<span class="op">=</span>tm.TVector3D([<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">1.</span>])</span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>n_b<span class="op">=</span>tm.TVector3D([<span class="fl">0.</span>,<span class="fl">1.</span>,<span class="fl">0.</span>])</span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a><span class="co">## Isotropic distribution of orientations</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a>KG_I_DS<span class="op">=</span>hm.computeIsotropicDiluteScheme(IM,f,IMi,a,b,c)</span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>KG_I_MT<span class="op">=</span>hm.computeIsotropicMoriTanakaScheme(IM,f,IMi,a,b,c)</span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a>D<span class="op">=</span>hm.Distribution(n_a,a,n_b,b,c)</span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>C_I_PCW<span class="op">=</span>hm.computeIsotropicPCWScheme(IM,f,IMi,a,b,c,D)</span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(KG_I_DS.kappa,KG_I_DS.mu)</span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(KG_I_MT.kappa,KG_I_MT.mu)</span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C_I_PCW)</span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a><span class="co">## Ellipsoids which turn around their axis &#39;a&#39;</span></span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a>C_TI_DS<span class="op">=</span>hm.computeTransverseIsotropicDiluteScheme(IM,f,IMi,n_a,a,b,c)</span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a>C_TI_MT<span class="op">=</span>hm.computeTransverseIsotropicMoriTanakaScheme(IM,f,IMi,n_a,a,b,c)</span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>C_TI_PCW<span class="op">=</span>hm.computeTransverseIsotropicPCWScheme(IM,f,IMi,n_a,a,b,c,D)</span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C_TI_DS)</span>
<span id="cb14-40"><a href="#cb14-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C_TI_MT)</span>
<span id="cb14-41"><a href="#cb14-41" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C_TI_PCW)</span>
<span id="cb14-42"><a href="#cb14-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-43"><a href="#cb14-43" aria-hidden="true" tabindex="-1"></a><span class="co">## Oriented ellipsoids</span></span>
<span id="cb14-44"><a href="#cb14-44" aria-hidden="true" tabindex="-1"></a>C_O_DS<span class="op">=</span>hm.computeOrientedDiluteScheme(IM,f,IMi,n_a,a,n_b,b,c)</span>
<span id="cb14-45"><a href="#cb14-45" aria-hidden="true" tabindex="-1"></a>C_O_MT<span class="op">=</span>hm.computeOrientedMoriTanakaScheme(IM,f,IMi,n_a,a,n_b,b,c)</span>
<span id="cb14-46"><a href="#cb14-46" aria-hidden="true" tabindex="-1"></a>C_O_PCW<span class="op">=</span>hm.computeOrientedPCWScheme(IM,f,IMi,n_a,a,n_b,b,c,D)</span>
<span id="cb14-47"><a href="#cb14-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C_O_DS)</span>
<span id="cb14-48"><a href="#cb14-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C_O_MT)</span>
<span id="cb14-49"><a href="#cb14-49" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(C_O_PCW)</span></code></pre></div>
<h3 id="homogenization-bounds">Homogenization bounds</h3>
<p>The available bounds are:</p>
<ul>
<li>Voigt bound</li>
<li>Reuss bound</li>
<li>Hashin-Shtrikman bounds</li>
</ul>
<p>Here are some examples of computation:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>f0<span class="op">=</span><span class="fl">0.2</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>f1<span class="op">=</span><span class="fl">0.5</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>f2<span class="op">=</span><span class="fl">0.3</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>C0<span class="op">=</span>tm.ST2toST23D(np.eye(<span class="dv">6</span>))</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>C1<span class="op">=</span>tm.ST2toST23D(<span class="dv">2</span><span class="op">*</span>np.eye(<span class="dv">6</span>))</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>C2<span class="op">=</span>tm.ST2toST23D(<span class="dv">5</span><span class="op">*</span>np.eye(<span class="dv">6</span>))</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>C0_2d<span class="op">=</span>tm.ST2toST22D(np.eye(<span class="dv">4</span>))</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>C1_2d<span class="op">=</span>tm.ST2toST22D(<span class="dv">2</span><span class="op">*</span>np.eye(<span class="dv">4</span>))</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>C2_2d<span class="op">=</span>tm.ST2toST22D(<span class="dv">5</span><span class="op">*</span>np.eye(<span class="dv">4</span>))</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Voigt and Reuss bounds</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>CV_3D<span class="op">=</span>hm.computeVoigtStiffness3D([f0,f1,f2],[C0,C1,C2])</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>CV_2D<span class="op">=</span>hm.computeVoigtStiffness2D([f0,f1,f2],[C0_2d,C1_2d,C2_2d])</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>CR_3D<span class="op">=</span>hm.computeReussStiffness3D([f0,f1,f2],[C0,C1,C2])</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>CR_2D<span class="op">=</span>hm.computeReussStiffness2D([f0,f1,f2],[C0_2d,C1_2d,C2_2d])</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(CR_3D,CV_3D)</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(CR_2D,CV_2D)</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Hashin-Shtrikman bounds</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>K0<span class="op">=</span><span class="dv">1</span><span class="op">/</span><span class="dv">3</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>G0<span class="op">=</span><span class="dv">1</span><span class="op">/</span><span class="dv">2</span></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>K1<span class="op">=</span><span class="dv">2</span><span class="op">/</span><span class="dv">3</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>G1<span class="op">=</span><span class="dv">1</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>K2<span class="op">=</span><span class="dv">5</span><span class="op">/</span><span class="dv">3</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>G2<span class="op">=</span><span class="dv">5</span><span class="op">/</span><span class="dv">2</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>KG_HS_3D<span class="op">=</span>hm.computeIsotropicHashinShtrikmanBounds3D([f0,f1,f2],[K0,K1,K2],[G0,G1,G2])</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>KG_HS_2D<span class="op">=</span>hm.computeIsotropicHashinShtrikmanBounds2D([f0,f1,f2],[K0,K1,K2],[G0,G1,G2])</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>K_LB_3D<span class="op">=</span>KG_HS_3D[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>G_LB_3D<span class="op">=</span>KG_HS_3D[<span class="dv">0</span>][<span class="dv">1</span>]</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>K_UB_3D<span class="op">=</span>KG_HS_3D[<span class="dv">1</span>][<span class="dv">0</span>]</span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>G_UB_3D<span class="op">=</span>KG_HS_3D[<span class="dv">1</span>][<span class="dv">1</span>]</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(K_LB_3D,G_LB_3D)</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(K_UB_3D,G_UB_3D)</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>K_LB_2D<span class="op">=</span>KG_HS_2D[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>G_LB_2D<span class="op">=</span>KG_HS_2D[<span class="dv">0</span>][<span class="dv">1</span>]</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>K_UB_2D<span class="op">=</span>KG_HS_2D[<span class="dv">1</span>][<span class="dv">0</span>]</span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>G_UB_2D<span class="op">=</span>KG_HS_2D[<span class="dv">1</span>][<span class="dv">1</span>]</span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(K_LB_2D,G_LB_2D)</span>
<span id="cb15-45"><a href="#cb15-45" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(K_UB_2D,G_UB_2D)</span></code></pre></div>
<p>Note that Voigt and Reuss bounds work on <code>ST2toST2</code>
objects, whereas Hashin-Shtrikman bounds work on bulk and shear moduli.
The number of phases is arbitrary.</p>
<h3 id="homogenization-of-general-microstructures">Homogenization of
general microstructures</h3>
<h4 id="construction-of-a-particulatemicrostructure">Construction of a
<code>ParticulateMicrostructure</code></h4>
<p>Some objects are defined that mirror the objects defined in the
namespace <code>tfel::material::homogenization::elasticity</code> for
the construction and homogenization of general microstructures. The
reader may want to consult this documentation <a
href="tfel-material.html#homogenization-of-general-microstructures">here</a>.</p>
<p>The <code>ParticulateMicrostructure</code> object is defined and can
be instantiated in various ways:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>IM0<span class="op">=</span>tmat.KGModuli(<span class="fl">1e7</span>,<span class="fl">1e7</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>micro_1<span class="op">=</span>hm.ParticulateMicrostructure(IM0)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>C0<span class="op">=</span>tm.ST2toST23D(<span class="fl">1e7</span><span class="op">*</span>np.eye(<span class="dv">6</span>))</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>micro_2<span class="op">=</span>hm.ParticulateMicrostructure(C0)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>micro_3<span class="op">=</span>hm.ParticulateMicrostructure(micro_2)</span></code></pre></div>
<p>where <code>C0</code> and <code>IM0</code> correspond to the
elasticity of the matrix phase. The
<code>ParticulateMicrostructure</code> has no public attribute. However,
it has some methods that return the value of the private attributes:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(micro_1.get_number_of_phases())</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(micro_1.get_matrix_fraction())</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(micro_1.get_matrix_elasticity())</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(micro_1.is_isotropic_matrix())</span></code></pre></div>
<p>Note that last line returns <code>True</code> if <code>micro_1</code>
was instantiated with objects like <code>KGModuli</code>,
<code>YoungNuModuli</code>, <code>LambdaMuModuli</code>, and
<code>False</code> when instantiated with a <code>ST2toST2</code> (like
<code>micro_2</code> above).</p>
<p>We can add a distribution of inclusions if we first instantiate such
a distribution. We must instantiate an inclusion first:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>a<span class="op">=</span><span class="dv">10</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>b<span class="op">=</span><span class="dv">2</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>c<span class="op">=</span><span class="dv">3</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>sph<span class="op">=</span>hm.Sphere()</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>spheroid<span class="op">=</span>hm.Spheroid(a,b)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>ellipso<span class="op">=</span>hm.Ellipsoid(a,b,c)</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(spheroid.axis_length(),spheroid.transverse_length())</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ellipso.semi_lengths)</span></code></pre></div>
<p>We can now instantiate a distribution of inclusions in various
ways:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>IMi<span class="op">=</span>tmat.KGModuli(<span class="fl">1e9</span>,<span class="fl">1e9</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>f<span class="op">=</span><span class="fl">0.1</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>sph_dist<span class="op">=</span>hm.SphereDistribution(sph,f,IMi)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>ellipsoid_dist_iso<span class="op">=</span>hm.IsotropicDistribution(ellipso,f,IMi)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>n_a<span class="op">=</span>tm.TVector3D([<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">1.</span>])</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>n_b<span class="op">=</span>tm.TVector3D([<span class="fl">0.</span>,<span class="fl">1.</span>,<span class="fl">0.</span>])</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>ellipsoid_dist_O<span class="op">=</span>hm.OrientedDistribution(ellipso,f,IMi,n_a,n_b)</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>Ci<span class="op">=</span>tm.ST2toST23D(<span class="fl">1e9</span><span class="op">*</span>np.eye(<span class="dv">6</span>))</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>Ci[<span class="dv">0</span>,<span class="dv">1</span>]<span class="op">=</span><span class="fl">1e8</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>Ci[<span class="dv">1</span>,<span class="dv">0</span>]<span class="op">=</span><span class="fl">1e8</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>ellipsoid_dist_O_2<span class="op">=</span>hm.OrientedDistribution(ellipso,f,Ci,n_a,n_b)</span></code></pre></div>
<p>The <code>TransverseDistribution</code> is a special case which
requires to precise which axis of the ellipsoid (or spheroid) will
remain fixed when the two other axes rotate:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>index<span class="op">=</span><span class="dv">0</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>ellipsoid_dist_TI<span class="op">=</span>hm.TransverseIsotropicDistribution(ellipso,f,IMi,n_a,index)</span></code></pre></div>
<p>The index can be 0,1 or 2. For a spheroid, giving <code>2</code> for
the <code>index</code> is the same as giving <code>1</code>, because
these 2 axes have the same length.</p>
<p>Note that the <code>OrientedDistribution</code> can be instantiated
with a <code>ST2toST2</code> object, here <code>Ci</code>. It is also
possible for a <code>SphereDistribution</code>. It can be useful for
considering anisotropic inclusions. However, the basis in which
<code>Ci</code> is defined is the local basis for the
<code>OrientedDistribution</code>, that is, the basis defined by
<code>n_a</code> and <code>n_b</code> passed as arguments. For a
<code>SphereDistribution</code>, it is the global basis.</p>
<p>We can now add these distributions to the microstructure:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>micro_1.addInclusionPhase(sph_dist)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(micro_1.get_number_of_phases())</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(micro_1.get_matrix_fraction())</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>micro_1.addInclusionPhase(ellipsoid_dist_iso)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(micro_1.get_number_of_phases())</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(micro_1.get_matrix_fraction())</span></code></pre></div>
<p>or remove them:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>micro_1.removeInclusionPhase(<span class="dv">0</span>)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(micro_1.get_number_of_phases())</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(micro_1.get_matrix_fraction())</span></code></pre></div>
<p>At this stage, we have added the distribution of spheres
<code>sph_dist</code>, and added the isotropic distribution of
ellipsoids <code>ellipsoid_dist_iso</code>. Afterthat, we have removed
the first inclusion distribution (number <code>0</code>), which is the
distribution of spheres. Hence, only one
<code>InclusionDistribution</code> object remains in the microstructure.
We can get this distribution by doing:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>ell_dist<span class="op">=</span>micro_1.get_inclusionPhase(<span class="dv">0</span>)</span></code></pre></div>
<p>This distribution of ellipsoids was instantiated before with a
<code>Ellipsoid</code> object, a fraction, and an isotropic elastic
modulus (see above <code>ellipsoid_dist_iso</code>) In fact, the
distribution has three attributes:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ell_dist.inclusion)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ell_dist.fraction)</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ell_dist.stiffness)</span></code></pre></div>
<p>like the other types of distributions of inclusions
(<code>SphereDistribution</code>,
<code>TransverseIsotropicDistribution</code> and
<code>OrientedDistribution</code>). All these distributions have also
two methods. The first just states if the distribution was instantiated
with isotropic elastic moduli or with a <code>ST2toST2</code> object.
Here, it was instantiated with a <code>KGModuli</code>, so that it is
considered isotropic. Hence,</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(ell_dist.is_isotropic())</span></code></pre></div>
<p>returns <code>True</code>.</p>
<p>The second method of the distribution allows to compute the mean
strain localisation (or concentration) tensor in the inclusions when
they are embedded in a matrix:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>Ai<span class="op">=</span>ell_dist.computeMeanLocalisator(IM0)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(Ai)</span></code></pre></div>
<p>Note that in the latter case, passing <code>C0</code>, a
<code>ST2toST2</code> object as an argument of the method will return an
error, because it will be considered that the matrix is not isotropic,
so that computing a average localisator of a distribution of ellipsoids
in an anisotropic matrix is impossible (too complicated). However, it
can be done for other kinds of distributions, like sphere distributions
or distributions of oriented inclusions:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>A1<span class="op">=</span>sph_dist.computeMeanLocalisator(C0,<span class="dv">10</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>A2<span class="op">=</span>ellipsoid_dist_O.computeMeanLocalisator(C0,<span class="dv">10</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(A1,A2)</span></code></pre></div>
<p>Here, the integer <code>10</code> is the number of subdivisions in
the integration process in the computation of the Hill tensor relative
to the inclusions. It is <code>12</code> by default.</p>
<p>The last method of the <code>ParticulateMicrostructure</code> object
allows to replace the matrix phase:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>micro_1.replaceMatrixPhase(C0)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(micro_1.get_matrix_elasticity())</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(micro_1.is_isotropic_matrix())</span></code></pre></div>
<p>Here we see that the matrix is no more isotropic because it was
replaced via a <code>ST2toST2</code> object.</p>
<p>Now, let us do homogenization !</p>
<h4 id="homogenization-schemes">Homogenization schemes</h4>
<p>Three schemes are currently available:</p>
<ul>
<li>Dilute scheme</li>
<li>Mori-Tanaka scheme</li>
<li>Self-consistent scheme</li>
</ul>
<p>Let us consider the previous <code>ParticulateMicrostructure</code>
object <code>micro_1</code>. We already have seen that computing some
average localisators in an anisotropic matrix was not possible for
non-oriented anisotropic inclusions like ellipsoids. Hence, we here
recover the isotropic matrix by doing</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>micro_1.replaceMatrixPhase(IM0)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(micro_1.is_isotropic_matrix())</span></code></pre></div>
<p>Afterwards,</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>hmDS<span class="op">=</span>hm.computeDiluteScheme(micro_1)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>hmMT<span class="op">=</span>hm.computeMoriTanakaScheme(micro_1)</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>hmSC<span class="op">=</span>hm.computeSelfConsistentScheme(micro_1,<span class="dv">10</span>,<span class="va">True</span>)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;DS: &quot;</span>,hmDS.homogenized_stiffness)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;MT: &quot;</span>,hmMT.homogenized_stiffness)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;SC: &quot;</span>,hmSC.homogenized_stiffness)</span></code></pre></div>
<p>We note that <code>computeSelfConsistentScheme</code> not only takes
the microstructure as an argument, but also takes one integer
(<code>10</code>) as a parameter, which is the maximum number of
iteration in the self-consistent iterative algorithm. Moreover, the
<code>bool</code> parameter (<code>True</code>) precises if the
computation considers an isotropic matrix when computing the Hill
tensors relative to the inclusions, at each iteration of the algorithm.
Indeed, the homogenized stiffness may be non isotropic, so that the user
can make the choice of isotropizing this homogenized stiffness at each
iteration. Otherwise, he can put <code>False</code>, so that a numerical
integration (resulting in a slower computation) will be performed to
compute the Hill tensors. Moreover, an integer parameter can be added
after the boolean, that indicates the number of subdivisions in the
numerical integration. This value is <code>12</code> by default:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>micro_2.addInclusionPhase(ellipsoid_dist_O)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>hmSC_iso<span class="op">=</span>hm.computeSelfConsistentScheme(micro_2,<span class="dv">10</span>,<span class="va">True</span>)</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>hmSC_aniso<span class="op">=</span>hm.computeSelfConsistentScheme(micro_2,<span class="dv">10</span>,<span class="va">False</span>,<span class="dv">10</span>)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;SC iso: &quot;</span>,hmSC_iso.homogenized_stiffness)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;SC aniso: &quot;</span>,hmSC_aniso.homogenized_stiffness)</span></code></pre></div>
<p>For the oter schemes, the isotropic character of the matrix when
computing the strain localisators will depend on what returns
<code>micro_1.is_isotropic_matrix()</code>. Hence, it is important to
initialized the matrix or the microstructure with the appropriate
elastic moduli. If isotropic, it will works in all case, whereas if not
isotropic, it will fail depending on the distributions that are present
in the microstructure. Moreover, if anisotropic, another parameter can
be passed to specify the number of subdivisions in the numerical
integration (this value is <code>12</code> by default):</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>micro_1.replaceMatrixPhase(C0)</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>micro_1.removeInclusionPhase(<span class="dv">0</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>micro_1.addInclusionPhase(ellipsoid_dist_O)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>hmDS_aniso<span class="op">=</span>hm.computeDiluteScheme(micro_1,<span class="dv">10</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>hmMT_aniso<span class="op">=</span>hm.computeMoriTanakaScheme(micro_1,<span class="dv">10</span>)</span></code></pre></div>
<p>We can also recover the strain localisation tensors:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>A_i_DS<span class="op">=</span>hmDS.mean_strain_localisation_tensors</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;A_0_DS: &quot;</span>,A_i_DS[<span class="dv">0</span>],<span class="st">&quot;A_1_DS: &quot;</span>,A_i_DS[<span class="dv">1</span>])</span></code></pre></div>
<p>We can also add a polarization on each phase:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>micro_1.replaceMatrixPhase(IM0)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>pola<span class="op">=</span>[tm.Stensor3D(<span class="dv">6</span><span class="op">*</span>[<span class="fl">0.</span>]),tm.Stensor3D([<span class="fl">1.e8</span>,<span class="fl">1e8</span>,<span class="fl">1e8</span>,<span class="fl">0.</span>,<span class="fl">0.</span>,<span class="fl">0.</span>])]</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>hmDS_pola<span class="op">=</span>hm.computeDiluteScheme(micro_1,polarisations<span class="op">=</span>pola)</span></code></pre></div>
<p>(note that here we must precise the name of the optional argument).
And we can recover the effective polarization:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>P_eff_DS<span class="op">=</span>hmDS_pola.effective_polarisation</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;P_eff_DS: &quot;</span>,P_eff_DS)</span></code></pre></div>
<p>In fact, the functions <code>computeDiluteScheme</code>,
<code>computeMoriTanakaScheme</code>
<code>computeSelfConsistentScheme</code>‚Ä¶ return an object
<code>HomogenizationScheme</code> which possesses the attributes
<code>homogenized_stiffness</code>,<code>mean_strain_localisation_tensors</code>
and <code>effective_polarisation</code>.</p>
<!-- Local IspellDict: english -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-62273823-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
