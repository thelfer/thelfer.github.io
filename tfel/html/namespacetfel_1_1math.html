<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <title>tfel: tfel::math Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">The TFEL project </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetfel.html">tfel</a></li><li class="navelem"><a class="el" href="namespacetfel_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tfel::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace contains various classes and functions défining mathematical objects and numerical algorithms.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetfel_1_1math_1_1ieee754"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math_1_1ieee754.html">ieee754</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetfel_1_1math_1_1internals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math_1_1internals.html">internals</a></td></tr>
<tr class="memdesc:namespacetfel_1_1math_1_1internals"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains classes, functions, metafunctions and data structures that are used internally in the <code><a class="el" href="namespacetfel_1_1math.html" title="This namespace contains various classes and functions défining mathematical objects and numerical alg...">tfel::math</a></code> namespace and that are meant to be used by the end user. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1abs_compare.html">absCompare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_abs_sum.html">AbsSum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_add_unit__.html">AddUnit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_add_unit___3_01_unit_3_01std_1_1integral__constant_3_01int_00_01_n1_01_4_6e9b48f5d91e090539faa59a6ac8ad5d.html">AddUnit_&lt; Unit&lt; std::integral_constant&lt; int, N1 &gt;, std::integral_constant&lt; int, N2 &gt;, std::integral_constant&lt; int, N3 &gt;, std::integral_constant&lt; int, N4 &gt;, std::integral_constant&lt; int, N5 &gt;, std::integral_constant&lt; int, N6 &gt;, std::integral_constant&lt; int, N7 &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt; &gt;, Unit&lt; std::integral_constant&lt; int, O1 &gt;, std::integral_constant&lt; int, O2 &gt;, std::integral_constant&lt; int, O3 &gt;, std::integral_constant&lt; int, O4 &gt;, std::integral_constant&lt; int, O5 &gt;, std::integral_constant&lt; int, O6 &gt;, std::integral_constant&lt; int, O7 &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_add_unit___3_01_unit_3_01std_1_1integral__constant_3_01int_00_01_n1_01_4_da6dcb20b504450056b1fd8385d8c613.html">AddUnit_&lt; Unit&lt; std::integral_constant&lt; int, N1 &gt;, std::integral_constant&lt; int, N2 &gt;, std::integral_constant&lt; int, N3 &gt;, std::integral_constant&lt; int, N4 &gt;, std::integral_constant&lt; int, N5 &gt;, std::integral_constant&lt; int, N6 &gt;, std::integral_constant&lt; int, N7 &gt;, std::integral_constant&lt; unsigned int, D1 &gt;, std::integral_constant&lt; unsigned int, D2 &gt;, std::integral_constant&lt; unsigned int, D3 &gt;, std::integral_constant&lt; unsigned int, D4 &gt;, std::integral_constant&lt; unsigned int, D5 &gt;, std::integral_constant&lt; unsigned int, D6 &gt;, std::integral_constant&lt; unsigned int, D7 &gt; &gt;, Unit&lt; std::integral_constant&lt; int, O1 &gt;, std::integral_constant&lt; int, O2 &gt;, std::integral_constant&lt; int, O3 &gt;, std::integral_constant&lt; int, O4 &gt;, std::integral_constant&lt; int, O5 &gt;, std::integral_constant&lt; int, O6 &gt;, std::integral_constant&lt; int, O7 &gt;, std::integral_constant&lt; unsigned int, AP1 &gt;, std::integral_constant&lt; unsigned int, AP2 &gt;, std::integral_constant&lt; unsigned int, AP3 &gt;, std::integral_constant&lt; unsigned int, AP4 &gt;, std::integral_constant&lt; unsigned int, AP5 &gt;, std::integral_constant&lt; unsigned int, AP6 &gt;, std::integral_constant&lt; unsigned int, AP7 &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_aitken_acceleration_algorithm.html">AitkenAccelerationAlgorithm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an implementation of the Aitken \(\Delta^{2}\) algorithm  <a href="structtfel_1_1math_1_1_aitken_acceleration_algorithm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_anderson_base.html">AndersonBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights for the Anderson accelation algorithm.  <a href="structtfel_1_1math_1_1_anderson_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_binary_operation.html">BinaryOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_bissection_algorithm_base.html">BissectionAlgorithmBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class to algorithms that extends a scalar root finding algorithm, such as a fixed-point iteration, Newton-Raphson, Stephensen, etc.. with the bissection algorithm.  <a href="structtfel_1_1math_1_1_bissection_algorithm_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_bissection_algorithm_data.html">BissectionAlgorithmData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a data structure holoding the current state of the bissection algorithm.  <a href="structtfel_1_1math_1_1_bissection_algorithm_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_result__.html">ComputeBinaryResult_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>. This default version returns InvalidType both for Result and Handle.  <a href="structtfel_1_1math_1_1_compute_binary_result__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_matrix_tag_00_01_matrix_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; MatrixTag, MatrixTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_result___3_01_matrix_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; MatrixTag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_result___3_01_matrix_tag_00_01_vector_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; MatrixTag, VectorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_matrix_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, MatrixTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_s_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, ST2toST2Tag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_s_t2to_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, ST2toT2Tag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, StensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, T2toST2Tag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, T2toT2Tag, A, B, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_result__.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryResult_</a> for scalar-t2tot2 operations  <a href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, TensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_result___3_01_scalar_tag_00_01_vector_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ScalarTag, VectorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ST2toST2Tag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_s_t2_tag_00_01_s_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ST2toST2Tag, ST2toST2Tag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_s_t2_tag_00_01_s_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; ST2toST2Tag, ST2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_s_t2_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; ST2toST2Tag, StensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_s_t2_tag_00_01_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; ST2toST2Tag, T2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ST2toT2Tag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_t2_tag_00_01_s_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; ST2toT2Tag, ST2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_t2_tag_00_01_s_t2to_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; ST2toT2Tag, ST2toT2Tag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_t2_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; ST2toT2Tag, StensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_s_t2to_t2_tag_00_01_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; ST2toT2Tag, T2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; StensorTag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_s_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; StensorTag, ST2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; StensorTag, StensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_diadic_product_01_4.html">ComputeBinaryResult_&lt; StensorTag, StensorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_dot_product_01_4.html">ComputeBinaryResult_&lt; StensorTag, StensorTag, A, B, OpDotProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; StensorTag, StensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; StensorTag, T2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; StensorTag, TensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_diadic_product_01_4.html">ComputeBinaryResult_&lt; StensorTag, TensorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_stensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; StensorTag, TensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; T2toST2Tag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_s_t2_tag_00_01_s_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; T2toST2Tag, ST2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_s_t2_tag_00_01_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; T2toST2Tag, T2toST2Tag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_s_t2_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; T2toST2Tag, T2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_s_t2_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; T2toST2Tag, TensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; T2toT2Tag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_result__.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryResult_</a> for t2tot2-scalar operations  <a href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_s_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; T2toT2Tag, ST2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; T2toT2Tag, T2toT2Tag, A, B, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_result__.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryResult_</a> for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>'s operation  <a href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; T2toT2Tag, T2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_result__.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryResult_</a> for T2toT2-T2toT2 operations  <a href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; T2toT2Tag, TensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_result__.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryResult_</a> for T2toT2-Tensor operations  <a href="classtfel_1_1math_1_1_compute_binary_result___3_01_t2to_t2_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; TensorTag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_s_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; TensorTag, ST2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; TensorTag, StensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_diadic_product_01_4.html">ComputeBinaryResult_&lt; TensorTag, StensorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; TensorTag, StensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; TensorTag, T2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; TensorTag, TensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_diadic_product_01_4.html">ComputeBinaryResult_&lt; TensorTag, TensorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_tensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; TensorTag, TensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_result___3_01_vector_tag_00_01_matrix_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryResult_&lt; VectorTag, MatrixTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_vector_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; VectorTag, ScalarTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_vector_tag_00_01_vector_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryResult_&lt; VectorTag, VectorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_vector_tag_00_01_vector_tag_00_01_a_00_01_b_00_01_op_diadic_product_01_4.html">ComputeBinaryResult_&lt; VectorTag, VectorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result___3_01_vector_tag_00_01_vector_tag_00_01_a_00_01_b_00_01_op_dot_product_01_4.html">ComputeBinaryResult_&lt; VectorTag, VectorTag, A, B, OpDotProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag.html">ComputeObjectTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a metafunction which compute the tag. associated with a given type.  <a href="structtfel_1_1math_1_1_compute_object_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag__.html">ComputeObjectTag_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An helper metafunction for tag computing.  <a href="structtfel_1_1math_1_1_compute_object_tag__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01false_00_01false_00_01true_01_4.html">ComputeObjectTag_&lt; Type, false, false, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for functions.  <a href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01false_00_01false_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01false_00_01true_01_4.html">ComputeObjectTag_&lt; Type, false, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for unary operators.  <a href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01false_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01true_01_4.html">ComputeObjectTag_&lt; Type, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for scalars.  <a href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result__.html">ComputeUnaryResult_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result___3_01_matrix_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; MatrixTag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_scalar_tag_00_01_tag_op_00_01_a_00_01_op_01_4.html">ComputeUnaryResult_&lt; ScalarTag, TagOp, A, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial Specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_unary_result__.html">ComputeUnaryResult_</a> for scalars.  <a href="structtfel_1_1math_1_1_compute_unary_result___3_01_scalar_tag_00_01_tag_op_00_01_a_00_01_op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_s_t2to_s_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; ST2toST2Tag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_s_t2to_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; ST2toT2Tag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_stensor_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; StensorTag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_t2to_s_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; T2toST2Tag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_t2to_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; T2toT2Tag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <code><a class="el" href="structtfel_1_1math_1_1_compute_unary_result__.html">ComputeUnaryResult_</a></code> for <code>T2toT2</code>'s object  <a href="structtfel_1_1math_1_1_compute_unary_result___3_01_t2to_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_tensor_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; TensorTag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result___3_01_vector_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; VectorTag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind.html">ConceptRebind</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_matrix_tag_00_01_type_01_4.html">ConceptRebind&lt; MatrixTag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for matrices  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_matrix_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_s_t2to_s_t2_tag_00_01_t_01_4.html">ConceptRebind&lt; ST2toST2Tag, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_s_t2to_t2_tag_00_01_type_01_4.html">ConceptRebind&lt; ST2toT2Tag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for symmetric tensors  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_s_t2to_t2_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_stensor_tag_00_01_type_01_4.html">ConceptRebind&lt; StensorTag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for symmetric tensors  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_stensor_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_t2to_s_t2_tag_00_01_type_01_4.html">ConceptRebind&lt; T2toST2Tag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for T2toST2  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_t2to_s_t2_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_t2to_t2_tag_00_01_type_01_4.html">ConceptRebind&lt; T2toT2Tag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for symmetric tensors  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_t2to_t2_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_tensor_tag_00_01_type_01_4.html">ConceptRebind&lt; TensorTag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for tensors  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_tensor_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_vector_tag_00_01_type_01_4.html">ConceptRebind&lt; VectorTag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for vectors  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_vector_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_array_common_methods.html">ConstArrayCommonMethods</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure gathering access methods for const arrays.  <a href="structtfel_1_1math_1_1_const_array_common_methods.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_array_s_t_l_compatibility_layer.html">ConstArraySTLCompatibilityLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class providing standard methods and aliases for compatibility with the standard template library (STL) based on the curiously recurring template pattern (CRTP).  <a href="structtfel_1_1math_1_1_const_array_s_t_l_compatibility_layer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_array_with_contiguous_data_s_t_l_compatibility_layer.html">ConstArrayWithContiguousDataSTLCompatibilityLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code>ArraySTLCompatibilityLayer</code> class when the memoy layout is contiguous.  <a href="structtfel_1_1math_1_1_const_array_with_contiguous_data_s_t_l_compatibility_layer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_array_without_contiguous_data_s_t_l_compatibility_layer.html">ConstArrayWithoutContiguousDataSTLCompatibilityLayer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_fixed_size_array_base.html">ConstFixedSizeArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class for fixed sized const arrays.  <a href="structtfel_1_1math_1_1_const_fixed_size_array_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_s_t2to_s_t2_view_expr.html">ConstST2toST2ViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_stensor_view_expr.html">ConstStensorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_t2to_s_t2_view_expr.html">ConstT2toST2ViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_t_matrix_view_expr.html">ConstTMatrixViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_t_vector_view_expr.html">ConstTVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative.html">ConvertKirchhoffStressJaumanRateModuliToKirchhoffStressDerivative</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_011u_00_01_t_01_4.html">ConvertKirchhoffStressJaumanRateModuliToKirchhoffStressDerivative&lt; 1u, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_011u_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_012u_00_01_t_01_4.html">ConvertKirchhoffStressJaumanRateModuliToKirchhoffStressDerivative&lt; 2u, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_012u_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_013u_00_01_t_01_4.html">ConvertKirchhoffStressJaumanRateModuliToKirchhoffStressDerivative&lt; 3u, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_013u_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator.html">ConvertLogarithmicStrainTangentOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used to convert the tangent operator in the logarithmic strain framework into the CSE tangent moduli.  <a href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator_3_011u_00_01stress_01_4.html">ConvertLogarithmicStrainTangentOperator&lt; 1u, stress &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator.html" title="A class used to convert the tangent operator in the logarithmic strain framework into the CSE tangent...">ConvertLogarithmicStrainTangentOperator</a> in 1D.  <a href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator_3_011u_00_01stress_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_t2to_s_t2_to_s_t2to_s_t2_expr.html">ConvertT2toST2ToST2toST2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cste.html">Cste</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cste_base.html">CsteBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_roots.html">CubicRoots</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline.html">CubicSpline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_invalid_abscissa_vector_size.html">CubicSplineInvalidAbscissaVectorSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_invalid_inputs.html">CubicSplineInvalidInputs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_invalid_ordinate_vector_size.html">CubicSplineInvalidOrdinateVectorSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_null_pivot.html">CubicSplineNullPivot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_uninitialised.html">CubicSplineUninitialised</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_unordered_abscissa_vector.html">CubicSplineUnorderedAbscissaVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type.html">DerivativeType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a meta function returning the type of the derivative of a variable of type T1 with respect to a variable of type T2  <a href="structtfel_1_1math_1_1_derivative_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html">DerivativeTypeDispatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper metafunction meant to be specialised  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_stensor_tag_00_01_scalar_type_00_01_stensor_type_01_4.html">DerivativeTypeDispatcher&lt; ScalarTag, StensorTag, ScalarType, StensorType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction meant to be specialised ">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_stensor_tag_00_01_scalar_type_00_01_stensor_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_tensor_tag_00_01_scalar_type_00_01_tensor_type_01_4.html">DerivativeTypeDispatcher&lt; ScalarTag, TensorTag, ScalarType, TensorType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction meant to be specialised ">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_tensor_tag_00_01_scalar_type_00_01_tensor_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_stensor_tag_00_01_scalar_tag_00_01_stensor_type_00_01_scalar_type_01_4.html">DerivativeTypeDispatcher&lt; StensorTag, ScalarTag, StensorType, ScalarType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction meant to be specialised ">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_stensor_tag_00_01_scalar_tag_00_01_stensor_type_00_01_scalar_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_stensor_tag_00_01_stensor_tag_00_01_stense15cf9bcc0b986936608266484ef659e.html">DerivativeTypeDispatcher&lt; StensorTag, StensorTag, StensorType1, StensorType2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction meant to be specialised ">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_stensor_tag_00_01_stensor_tag_00_01_stense15cf9bcc0b986936608266484ef659e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_stensor_tag_00_01_tensor_tag_00_01_stensor_type1_00_01_tensor_type2_01_4.html">DerivativeTypeDispatcher&lt; StensorTag, TensorTag, StensorType1, TensorType2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction meant to be specialised ">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_stensor_tag_00_01_tensor_tag_00_01_stensor_type1_00_01_tensor_type2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_tensor_tag_00_01_scalar_tag_00_01_tensor_type_00_01_scalar_type_01_4.html">DerivativeTypeDispatcher&lt; TensorTag, ScalarTag, TensorType, ScalarType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction meant to be specialised ">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_tensor_tag_00_01_scalar_tag_00_01_tensor_type_00_01_scalar_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_tensor_tag_00_01_stensor_tag_00_01_tensor_type1_00_01_stensor_type2_01_4.html">DerivativeTypeDispatcher&lt; TensorTag, StensorTag, TensorType1, StensorType2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction meant to be specialised ">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_tensor_tag_00_01_stensor_tag_00_01_tensor_type1_00_01_stensor_type2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_tensor_tag_00_01_tensor_tag_00_01_tensor_type1_00_01_tensor_type2_01_4.html">DerivativeTypeDispatcher&lt; TensorTag, TensorTag, TensorType1, TensorType2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction meant to be specialised ">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_tensor_tag_00_01_tensor_tag_00_01_tensor_type1_00_01_tensor_type2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_diadic_product_operation.html">DiadicProductOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_diagonal_term_product.html">DiagonalTermProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper structure used to compute the products of the diagonal terms of a square matrix  <a href="structtfel_1_1math_1_1_diagonal_term_product.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_diagonal_term_product_3_01_n_00_01_num_type_00_01_n_01_4.html">DiagonalTermProduct&lt; N, NumType, N &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an adaptator to random access iterator  <a href="structtfel_1_1math_1_1_difference_random_access_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator_base.html">DifferenceRandomAccessIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class of the <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html" title="an adaptator to random access iterator ">DifferenceRandomAccessIterator</a> containing some static common utility methods.  <a href="structtfel_1_1math_1_1_difference_random_access_iterator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_dot_product.html">DotProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1dot_product.html">dotProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtfel_1_1math_1_1dot_product.html" title="dotProduct calculates a generalized inner product of the ranges [first1,first1+N) and [first2...">dotProduct</a> calculates a generalized inner product of the ranges [first1,first1+N) and [first2,first2+N)  <a href="structtfel_1_1math_1_1dot_product.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1dot_product_3_010u_01_4.html">dotProduct&lt; 0u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation used to end recursion when using the <a class="el" href="structtfel_1_1math_1_1dot_product.html" title="dotProduct calculates a generalized inner product of the ranges [first1,first1+N) and [first2...">dotProduct</a> algorithm.  <a href="structtfel_1_1math_1_1dot_product_3_010u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_dot_product_3_010u_00_01_m_01_4.html">DotProduct&lt; 0u, M &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is aimed to used for mathematical objects whose size are known at compile-tme.  <a href="structtfel_1_1math_1_1_empty_run_time_properties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_evaluator.html">Evaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class in charge of handling a function defined by a string.  <a href="structtfel_1_1math_1_1_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation. ">Expr</a> object allows the lazy evaluation of a mathematical operation.  <a href="structtfel_1_1math_1_1_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_binary_operation_3_01_t1_00_01_t2_00_01_op_01_4_01_4.html">Expr&lt; ResultType, BinaryOperation&lt; T1, T2, Op &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation. ">Expr</a> object allowing the lazy evaluation of a binary operation.  <a href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_binary_operation_3_01_t1_00_01_t2_00_01_op_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_diadic_product_operation_3_01_t1_00_01_t2_01_4_01_4.html">Expr&lt; ResultType, DiadicProductOperation&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_object_scalar_operation_3_01_t1_00_01_t2_00_01_op_01_4_01_4.html">Expr&lt; ResultType, ObjectScalarOperation&lt; T1, T2, Op &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_scalar_object_operation_3_01_t1_00_01_t2_00_01_op_01_4_01_4.html">Expr&lt; ResultType, ScalarObjectOperation&lt; T1, T2, Op &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_unary_operation_3_01_t1_00_01_op_01_4_01_4.html">Expr&lt; ResultType, UnaryOperation&lt; T1, Op &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation. ">Expr</a> object allowing the lazy evaluation of an unary operation.  <a href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_unary_operation_3_01_t1_00_01_op_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01st2tost2_3_01_n_00_01_t_01_4_00_01_const_s_t2to_s_t2_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; st2tost2&lt; N, T &gt;, ConstST2toST2ViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01st2tost2_3_01_n_00_01_t_01_4_00_01_s_t2to_s_t2_from_tiny_matrix_0b65a96da2fd434c4504b3ad91687014.html">Expr&lt; st2tost2&lt; N, T &gt;, ST2toST2FromTinyMatrixView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01st2tost2_3_01_n_00_01_t_01_4_00_01_s_t2to_s_t2_from_tiny_matrix_5d7d9d3c651568fadb2b23032443bc0e.html">Expr&lt; st2tost2&lt; N, T &gt;, ST2toST2FromTinyMatrixViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01st2tost2_3_01_n_00_01_t_01_4_00_01_s_t2to_s_t2_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; st2tost2&lt; N, T &gt;, ST2toST2ViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_convert_t2to_s_t2_to_s_t2to_s_t2_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ConvertT2toST2ToST2toST2Expr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_convert_t2to_s_t2_to_s_t2to_s_t2_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ConvertT2toST2ToST2toST2Expr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_convert_t2to_s_t2_to_s_t2to_s_t2_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ConvertT2toST2ToST2toST2Expr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_s_t2to_s_t2_s_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ST2toST2ST2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_s_t2to_s_t2_s_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ST2toST2ST2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_s_t2to_s_t2_s_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ST2toST2ST2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_stensor_square_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, StensorSquareDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_stensor_square_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, StensorSquareDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_stensor_square_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, StensorSquareDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_t2to_s_t2_s_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, T2toST2ST2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_t2to_s_t2_s_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, T2toST2ST2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_t2to_s_t2_s_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, T2toST2ST2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_s_t2to_t2_s_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, ST2toT2ST2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_s_t2to_t2_s_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, ST2toT2ST2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_s_t2to_t2_s_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, ST2toT2ST2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_left_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductLeftDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_left_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductLeftDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_left_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductLeftDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_right_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductRightDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_right_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductRightDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_right_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductRightDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_t2to_t2_s_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, T2toT2ST2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_t2to_t2_s_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, T2toT2ST2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_t2to_t2_s_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, T2toT2ST2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_const_stensor_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; stensor&lt; N, T &gt;, ConstStensorViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_stensor_from_tiny_matrix_colum651beb94bb796f0fe0a96869c319fe81.html">Expr&lt; stensor&lt; N, T &gt;, StensorFromTinyMatrixColumnView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_stensor_from_tiny_matrix_columd61eb7230bf5bfeb00090d6ffa1ee624.html">Expr&lt; stensor&lt; N, T &gt;, StensorFromTinyMatrixColumnViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_stensor_from_tiny_matrix_row_vcd7e9933f829c50fdd14867fa642a5cf.html">Expr&lt; stensor&lt; N, T &gt;, StensorFromTinyMatrixRowView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_stensor_from_tiny_matrix_row_vbb8e834eeff4203ecedacf1c63b36404.html">Expr&lt; stensor&lt; N, T &gt;, StensorFromTinyMatrixRowViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_stensor_from_tiny_vector_view_82cbbfb10b414b56cd3432d72fc32068.html">Expr&lt; stensor&lt; N, T &gt;, StensorFromTinyVectorViewExpr&lt; N, Mn, In, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01stensor_3_01_n_00_01_t_01_4_00_01_stensor_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; stensor&lt; N, T &gt;, StensorViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_s_t2to_s_t2_stensor_product_expr_3_011u_01_4_01_4.html">Expr&lt; StensorResultType, ST2toST2StensorProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_s_t2to_s_t2_stensor_product_expr_3_012u_01_4_01_4.html">Expr&lt; StensorResultType, ST2toST2StensorProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_s_t2to_s_t2_stensor_product_expr_3_013u_01_4_01_4.html">Expr&lt; StensorResultType, ST2toST2StensorProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_stensor_s_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; StensorResultType, StensorST2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_stensor_s_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; StensorResultType, StensorST2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_stensor_s_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; StensorResultType, StensorST2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_t2to_s_t2_tensor_product_expr_3_011u_01_4_01_4.html">Expr&lt; StensorResultType, T2toST2TensorProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_t2to_s_t2_tensor_product_expr_3_012u_01_4_01_4.html">Expr&lt; StensorResultType, T2toST2TensorProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_t2to_s_t2_tensor_product_expr_3_013u_01_4_01_4.html">Expr&lt; StensorResultType, T2toST2TensorProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_tensor_s_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; StensorResultType, TensorST2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_tensor_s_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; StensorResultType, TensorST2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_tensor_s_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; StensorResultType, TensorST2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01t2tost2_3_01_n_00_01_t_01_4_00_01_const_t2to_s_t2_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; t2tost2&lt; N, T &gt;, ConstT2toST2ViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01t2tost2_3_01_n_00_01_t_01_4_00_01_t2to_s_t2_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; t2tost2&lt; N, T &gt;, T2toST2ViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_s_t2to_s_t2_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; T2toST2ResultType, ST2toST2T2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_s_t2to_s_t2_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; T2toST2ResultType, ST2toST2T2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_s_t2to_s_t2_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; T2toST2ResultType, ST2toST2T2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_t2to_s_t2_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; T2toST2ResultType, T2toST2T2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_t2to_s_t2_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; T2toST2ResultType, T2toST2T2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_t2to_s_t2_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; T2toST2ResultType, T2toST2T2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_left_cauchy_green_tensor_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; T2toST2Type, LeftCauchyGreenTensorDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_left_cauchy_green_tensor_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; T2toST2Type, LeftCauchyGreenTensorDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_left_cauchy_green_tensor_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; T2toST2Type, LeftCauchyGreenTensorDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_right_cauchy_green_tensor_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; T2toST2Type, RightCauchyGreenTensorDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_right_cauchy_green_tensor_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; T2toST2Type, RightCauchyGreenTensorDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_right_cauchy_green_tensor_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; T2toST2Type, RightCauchyGreenTensorDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01t2tot2_3_01_n_00_01_t_01_4_00_01_s_t2to_t2_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; t2tot2&lt; N, T &gt;, ST2toT2ViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expression that allows to interpret a memory buffer as an <code>ST2toT2</code> object.  <a href="structtfel_1_1math_1_1_expr_3_01t2tot2_3_01_n_00_01_t_01_4_00_01_s_t2to_t2_view_expr_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01t2tot2_3_01_n_00_01_t_01_4_00_01_t2to_t2_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; t2tot2&lt; N, T &gt;, T2toT2ViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_s_t2to_t2_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; T2toT2ResultType, ST2toT2T2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_s_t2to_t2_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; T2toT2ResultType, ST2toT2T2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_s_t2to_t2_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; T2toT2ResultType, ST2toT2T2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_t2to_t2_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; T2toT2ResultType, T2toT2T2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_t2to_t2_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; T2toT2ResultType, T2toT2T2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_t2to_t2_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; T2toT2ResultType, T2toT2T2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_left_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductLeftDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_left_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductLeftDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_left_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductLeftDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_right_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductRightDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_right_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductRightDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_right_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductRightDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_t_01_4_00_01_tensor_from_tiny_matrix_column_90e6c5a0b22204e71f019b056042d9da.html">Expr&lt; tensor&lt; N, T &gt;, TensorFromTinyMatrixColumnView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_t_01_4_00_01_tensor_from_tiny_matrix_column_37a4f4b582a70566ea3d5354f25cf96a.html">Expr&lt; tensor&lt; N, T &gt;, TensorFromTinyMatrixColumnViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_t_01_4_00_01_tensor_from_tiny_matrix_row_vie58f9ba98184126761fca3cc9fb82c484.html">Expr&lt; tensor&lt; N, T &gt;, TensorFromTinyMatrixRowView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_t_01_4_00_01_tensor_from_tiny_matrix_row_vie197da9ef818a07949020f8bf74d87451.html">Expr&lt; tensor&lt; N, T &gt;, TensorFromTinyMatrixRowViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_t_01_4_00_01_tensor_from_tiny_vector_view_excd0765c041f2aa70c9fbb4df0aebf446.html">Expr&lt; tensor&lt; N, T &gt;, TensorFromTinyVectorViewExpr&lt; N, Mn, In, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_t_01_4_00_01_tensor_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; tensor&lt; N, T &gt;, TensorViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tensor view  <a href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_t_01_4_00_01_tensor_view_expr_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_value_type_01_4_00_01_tensor_view_from_stensor_expr_3_01_t_01_4_01_4.html">Expr&lt; tensor&lt; N, ValueType &gt;, TensorViewFromStensorExpr&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_s_t2to_t2_stensor_product_expr_3_011u_01_4_01_4.html">Expr&lt; TensorResultType, ST2toT2StensorProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_s_t2to_t2_stensor_product_expr_3_012u_01_4_01_4.html">Expr&lt; TensorResultType, ST2toT2StensorProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_s_t2to_t2_stensor_product_expr_3_013u_01_4_01_4.html">Expr&lt; TensorResultType, ST2toT2StensorProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_stensor_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; TensorResultType, StensorT2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_stensor_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; TensorResultType, StensorT2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_stensor_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; TensorResultType, StensorT2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_t2to_t2_tensor_product_expr_3_011u_01_4_01_4.html">Expr&lt; TensorResultType, T2toT2TensorProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_t2to_t2_tensor_product_expr_3_012u_01_4_01_4.html">Expr&lt; TensorResultType, T2toT2TensorProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_t2to_t2_tensor_product_expr_3_013u_01_4_01_4.html">Expr&lt; TensorResultType, T2toT2TensorProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_tensor_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; TensorResultType, TensorT2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_tensor_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; TensorResultType, TensorT2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_tensor_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; TensorResultType, TensorT2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tmatrix_3_013u_00_013u_00_01numeric__type_3_01_tensor_type_01_4_0dbb3e0acd2a635f8343ce465cee3a2d.html">Expr&lt; tmatrix&lt; 3u, 3u, numeric_type&lt; TensorType &gt; &gt;, MatrixViewFromTensorExpr&lt; TensorType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01_const_t_matrix_view_ex4ac13d0660d557667e9fac67277955dd.html">Expr&lt; tmatrix&lt; N, M, T &gt;, ConstTMatrixViewExpr&lt; N, M, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01_t_matrix_view_expr_3_01_n_00_01_m_00_01_t_01_4_01_4.html">Expr&lt; tmatrix&lt; N, M, T &gt;, TMatrixViewExpr&lt; N, M, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_const_t_vector_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; tvector&lt; N, T &gt;, ConstTVectorViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_tiny_vector_from_tiny_vector_ve4426bd9028d65ef49b0af19a58b2d0c.html">Expr&lt; tvector&lt; N, T &gt;, TinyVectorFromTinyVectorViewExpr&lt; N, Mn, In, T, b &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_t_vector_view_expr_3_01_n_00_01_t_01_4_01_4.html">Expr&lt; tvector&lt; N, T &gt;, TVectorViewExpr&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tvector_3_01_nn_00_01stensor_3_01_n_00_01_t_01_4_01_4_00_01_tiny03ab00e9f46540130ac2586b9b2c8886.html">Expr&lt; tvector&lt; Nn, stensor&lt; N, T &gt; &gt;, TinyVectorOfStensorFromTinyVectorViewExpr&lt; N, Mn, In, Nn, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tvector_3_01_nn_00_01tvector_3_01_n_00_01_t_01_4_01_4_00_01_tinyc4b64e635bd18497f53043592d62e75a.html">Expr&lt; tvector&lt; Nn, tvector&lt; N, T &gt; &gt;, TinyVectorOfTinyVectorFromTinyVectorViewExpr&lt; N, Mn, In, Nn, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_base.html">ExprBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper class  <a href="structtfel_1_1math_1_1_expr_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_with_array_access_operator.html">ExprWithArrayAccessOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An helper class which defines array-like access operator by relying on the operator() of the derived class.  <a href="structtfel_1_1math_1_1_expr_with_array_access_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_factorized_kriging.html">FactorizedKriging</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_factorized_kriging1_d1_d.html">FactorizedKriging1D1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_factorized_kriging1_d2_d.html">FactorizedKriging1D2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_factorized_kriging1_d3_d.html">FactorizedKriging1D3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_f_anderson.html">FAnderson</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_fct_object_random_access_const_iterator.html">FctObjectRandomAccessConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_row_major_matrix_indexing_policy.html">FixedSizeRowMajorMatrixIndexingPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an indexing policy suitable for fixed sized matrices  <a href="structtfel_1_1math_1_1_fixed_size_row_major_matrix_indexing_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_tiny_matrix_policy.html">FixedSizeTinyMatrixPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_tiny_vector_policy.html">FixedSizeTinyVectorPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_vector_indexing_policy.html">FixedSizeVectorIndexingPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an indexing policy suitable for fixed sized vectors  <a href="structtfel_1_1math_1_1_fixed_size_vector_indexing_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_f_s_levenberg_marquardt.html">FSLevenbergMarquardt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_f_s_levenberg_marquardt_variable.html">FSLevenbergMarquardtVariable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_f_s_levenberg_marquardt_variable_3_011u_00_01_t_01_4.html">FSLevenbergMarquardtVariable&lt; 1u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_generic_fixed_size_array.html">GenericFixedSizeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a fixed size array class with storage on the stack  <a href="structtfel_1_1math_1_1_generic_fixed_size_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_generic_fixed_size_array_view.html">GenericFixedSizeArrayView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_generic_fixed_size_const_array_view.html">GenericFixedSizeConstArrayView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_geometric_discretization_invalid_density.html">GeometricDiscretizationInvalidDensity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_geometric_discretization_invalid_length.html">GeometricDiscretizationInvalidLength</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_geometric_discretization_invalid_number_of_elements.html">GeometricDiscretizationInvalidNumberOfElements</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check.html">IndexingPoliciesCompatiblityCheck</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure used to compare two indexing policies  <a href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_3_01_fixed_size_row_major_matrix_indc87d843b3c2b4577b6e93ba1b052d26e.html">IndexingPoliciesCompatiblityCheck&lt; FixedSizeRowMajorMatrixIndexingPolicy&lt; SizeType, N, M, Stride1 &gt;, FixedSizeRowMajorMatrixIndexingPolicy&lt; SizeType, N, M, Stride2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check.html" title="a structure used to compare two indexing policies ">IndexingPoliciesCompatiblityCheck</a></code> class for <code><a class="el" href="structtfel_1_1math_1_1_fixed_size_row_major_matrix_indexing_policy.html" title="an indexing policy suitable for fixed sized matrices ">FixedSizeRowMajorMatrixIndexingPolicy</a></code> of the same sizes.  <a href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_3_01_fixed_size_row_major_matrix_indc87d843b3c2b4577b6e93ba1b052d26e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_3_01_fixed_size_vector_indexing_poli3a4ac835d60942037e87a59b99ba4733.html">IndexingPoliciesCompatiblityCheck&lt; FixedSizeVectorIndexingPolicy&lt; SizeType, N, Stride1 &gt;, FixedSizeVectorIndexingPolicy&lt; SizeType, N, Stride2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check.html" title="a structure used to compare two indexing policies ">IndexingPoliciesCompatiblityCheck</a></code> class for <code><a class="el" href="structtfel_1_1math_1_1_fixed_size_vector_indexing_policy.html" title="an indexing policy suitable for fixed sized vectors ">FixedSizeVectorIndexingPolicy</a></code> of the same size.  <a href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_3_01_fixed_size_vector_indexing_poli3a4ac835d60942037e87a59b99ba4733.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_base.html">IndexingPoliciesCompatiblityCheckBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class to compare indexing policies which provide default implementations.  <a href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_integer_evaluator.html">IntegerEvaluator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_invalid_time_step_exception.html">InvalidTimeStepException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_is_convertible_to_qt_no_unit.html">IsConvertibleToQtNoUnit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_is_euclidian_norm_valid.html">IsEuclidianNormValid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_is_qt_scalar_operation_valid.html">IsQtScalarOperationValid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_is_scalar_vector_operation_valid.html">IsScalarVectorOperationValid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_is_t_vector_scalar_operation_valid.html">IsTVectorScalarOperationValid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_is_vector_vector_operation_valid.html">IsVectorVectorOperationValid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_iterate_over_multiple_indices.html">IterateOverMultipleIndices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging.html">Kriging</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging1_d.html">Kriging1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging2_d.html">Kriging2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging3_d.html">Kriging3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_model.html">KrigingDefaultModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_model_3_011u_00_01_t_00_01_n_m_01_4.html">KrigingDefaultModel&lt; 1u, T, NM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_model_3_012u_00_01_t_00_01_n_m_01_4.html">KrigingDefaultModel&lt; 2u, T, NM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_model_3_013u_00_01_t_00_01_n_m_01_4.html">KrigingDefaultModel&lt; 3u, T, NM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_nugget_model.html">KrigingDefaultNuggetModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_error_insufficient_data.html">KrigingErrorInsufficientData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_error_invalid_length.html">KrigingErrorInvalidLength</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_error_no_data_specified.html">KrigingErrorNoDataSpecified</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_model_adaptator.html">KrigingModelAdaptator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_piece_wise_linear_model1_d.html">KrigingPieceWiseLinearModel1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_utilities.html">KrigingUtilities</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_variable.html">KrigingVariable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_variable_3_011u_00_01_t_01_4.html">KrigingVariable&lt; 1u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_left_cauchy_green_tensor_derivative_expr.html">LeftCauchyGreenTensorDerivativeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declaration  <a href="structtfel_1_1math_1_1_left_cauchy_green_tensor_derivative_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_levenberg_marquardt.html">LevenbergMarquardt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_levenberg_marquardt_evaluator_wrapper.html">LevenbergMarquardtEvaluatorWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_levenberg_marquardt_external_function_wrapper.html">LevenbergMarquardtExternalFunctionWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_levenberg_marquardt_function_wrapper.html">LevenbergMarquardtFunctionWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_loop_un_roller.html">LoopUnRoller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_decomp.html">LUDecomp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_exception.html">LUException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_invalid_matrix_size.html">LUInvalidMatrixSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_matrix_not_square.html">LUMatrixNotSquare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_null_determinant.html">LUNullDeterminant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_null_pivot.html">LUNullPivot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_solve.html">LUSolve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_unmatched_size.html">LUUnmatchedSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_divergence_exception.html">MathDivergenceException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_exception.html">MathException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a traits class describing a mathematical object  <a href="structtfel_1_1math_1_1_math_object_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01_expr_3_01_result_type_00_01_operation_01_4_01_4.html">MathObjectTraits&lt; Expr&lt; ResultType, Operation &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html" title="a traits class describing a mathematical object ">MathObjectTraits</a></code>. We assume that the expression has the same properties that the result of its evaluation.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01_expr_3_01_result_type_00_01_operation_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01matrix_3_01_t_01_4_01_4.html">MathObjectTraits&lt; matrix&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for <code>matrix</code>. This is a <a class="el" href="structtfel_1_1math_1_1_matrix_concept.html" title="A class used to model the concept of matrices. Here we use the curiously recurring template pattern...">MatrixConcept</a> requirement.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01matrix_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01st2tost2_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; st2tost2&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html" title="a traits class describing a mathematical object ">MathObjectTraits</a></code> class for <code><a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a></code>.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01st2tost2_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01st2tot2_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; st2tot2&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01stensor_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; stensor&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html" title="a traits class describing a mathematical object ">MathObjectTraits</a></code> class.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01stensor_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01t2tost2_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; t2tost2&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01t2tot2_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; t2tot2&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html" title="a traits class describing a mathematical object ">MathObjectTraits</a></code> class for <code><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a></code>.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01t2tot2_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01tensor_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; tensor&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html" title="a traits class describing a mathematical object ">MathObjectTraits</a></code> class.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01tensor_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_01_4.html">MathObjectTraits&lt; tmatrix&lt; N, M, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for tmatrix This is a <a class="el" href="structtfel_1_1math_1_1_matrix_concept.html" title="A class used to model the concept of matrices. Here we use the curiously recurring template pattern...">MatrixConcept</a> requirement.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01tvector_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; tvector&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvectors.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01tvector_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01vector_3_01_t_01_4_01_4.html">MathObjectTraits&lt; vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for the vector class.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01vector_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_run_time_exception.html">MathRunTimeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1matrix.html">matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class representing a dynamically allocated matrix  <a href="structtfel_1_1math_1_1matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1matrix__utilities.html">matrix_utilities</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1matrix__utilities_3_010u_00_01_m_00_01_m__init_01_4.html">matrix_utilities&lt; 0u, M, M_init &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1matrix__utilities_3_01_n_00_010u_00_01_m__init_01_4.html">matrix_utilities&lt; N, 0u, M_init &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_concept.html">MatrixConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used to model the concept of matrices. Here we use the curiously recurring template pattern.  <a href="structtfel_1_1math_1_1_matrix_concept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_properties.html">MatrixProperties</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_tag.html">MatrixTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise matrices.  <a href="structtfel_1_1math_1_1_matrix_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_matrix_vector_handle.html">MatrixVectorHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_matrix_vector_handle_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tvector_7459a53bfb61de9ef0633aa0de6b8077.html">MatrixVectorHandle&lt; tmatrix&lt; N, M, T &gt;, tvector&lt; M, T2 &gt;, A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_matrix_vector_handle_3_01tvector_3_01_n_00_01_t_01_4_00_01tmatrix_3_01_n_0a6d426fa0cba568d50d019d6432066a6.html">MatrixVectorHandle&lt; tvector&lt; N, T &gt;, tmatrix&lt; N, M, T2 &gt;, A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_view_from_tensor_expr.html">MatrixViewFromTensorExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declaration  <a href="structtfel_1_1math_1_1_matrix_view_from_tensor_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_maximum_number_of_iterations_reached_exception.html">MaximumNumberOfIterationsReachedException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_multi_indices_binary_operator_functor.html">MultiIndicesBinaryOperatorFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_multi_indices_radom_access_interator_wrapper.html">MultiIndicesRadomAccessInteratorWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_multi_indices_unary_operator_functor.html">MultiIndicesUnaryOperatorFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_mutable_array_common_methods.html">MutableArrayCommonMethods</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure gathering access methods and helper function for arrays.  <a href="structtfel_1_1math_1_1_mutable_array_common_methods.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_mutable_array_s_t_l_compatibility_layer.html">MutableArraySTLCompatibilityLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class providing standard methods and aliases for compatibility with the standard template library (STL) based on the curiously recurring template pattern (CRTP).  <a href="structtfel_1_1math_1_1_mutable_array_s_t_l_compatibility_layer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_mutable_array_with_contiguous_data_s_t_l_compatibility_layer.html">MutableArrayWithContiguousDataSTLCompatibilityLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code>ArraySTLCompatibilityLayer</code> class when the memoy layout is contiguous.  <a href="structtfel_1_1math_1_1_mutable_array_with_contiguous_data_s_t_l_compatibility_layer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_mutable_array_without_contiguous_data_s_t_l_compatibility_layer.html">MutableArrayWithoutContiguousDataSTLCompatibilityLayer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_mutable_fixed_size_array_base.html">MutableFixedSizeArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class for mutable fixed size arrays.  <a href="structtfel_1_1math_1_1_mutable_fixed_size_array_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_neg_object_random_access_const_iterator.html">NegObjectRandomAccessConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator.html">ObjectObjectRandomAccessConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator_3_01_a_00_01_b_00_01_op_div_01_4.html">ObjectObjectRandomAccessConstIterator&lt; A, B, OpDiv &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator_3_01_a_00_01_b_00_01_op_minus_01_4.html">ObjectObjectRandomAccessConstIterator&lt; A, B, OpMinus &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator_3_01_a_00_01_b_00_01_op_mult_01_4.html">ObjectObjectRandomAccessConstIterator&lt; A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator_3_01_a_00_01_b_00_01_op_plus_01_4.html">ObjectObjectRandomAccessConstIterator&lt; A, B, OpPlus &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_object_scalar_operation.html">ObjectScalarOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_scalar_random_access_const_iterator.html">ObjectScalarRandomAccessConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_scalar_random_access_const_iterator_3_01_a_00_01_b_00_01_op_div_01_4.html">ObjectScalarRandomAccessConstIterator&lt; A, B, OpDiv &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_object_scalar_random_access_const_iterator_3_01_a_00_01_b_00_01_op_mult_01_4.html">ObjectScalarRandomAccessConstIterator&lt; A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_and.html">OpAnd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_diadic_product.html">OpDiadicProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_minus.html">OpMinus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_neg.html">OpNeg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_or.html">OpOr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_permutation.html">Permutation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power.html">Power</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_generator.html">PowerGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_power_impl_selector.html">PowerImplSelector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_power_impl_selector_3_01_n_00_011u_01_4.html">PowerImplSelector&lt; N, 1u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_power_impl_selector_3_01_n_00_012u_01_4.html">PowerImplSelector&lt; N, 2u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_neg.html">PowerNeg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper structure to compute the negative power of a number.  <a href="structtfel_1_1math_1_1_power_neg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_power_pos.html">PowerPos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_3_010u_01_4.html">PowerPos&lt; 0u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_3_011u_01_4.html">PowerPos&lt; 1u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_3_012u_01_4.html">PowerPos&lt; 2u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_3_013u_01_4.html">PowerPos&lt; 3u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_impl.html">PowerPosImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_impl_3_010u_00_010u_01_4.html">PowerPosImpl&lt; 0u, 0u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_impl_3_010u_00_01_m_01_4.html">PowerPosImpl&lt; 0u, M &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_pos_impl_3_01_n_00_010u_01_4.html">PowerPosImpl&lt; N, 0u &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power_sqrt_neg.html">PowerSqrtNeg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_power_sqrt_pos.html">PowerSqrtPos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_pow_unit__.html">PowUnit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_pow_unit___3_01_n_00_01_d_00_01_unit_3_01std_1_1integral__constant_3_01in4b8c5f857d933d72fce243da4ec3d4ab.html">PowUnit_&lt; N, D, Unit&lt; std::integral_constant&lt; int, N1 &gt;, std::integral_constant&lt; int, N2 &gt;, std::integral_constant&lt; int, N3 &gt;, std::integral_constant&lt; int, N4 &gt;, std::integral_constant&lt; int, N5 &gt;, std::integral_constant&lt; int, N6 &gt;, std::integral_constant&lt; int, N7 &gt;, std::integral_constant&lt; unsigned int, D1 &gt;, std::integral_constant&lt; unsigned int, D2 &gt;, std::integral_constant&lt; unsigned int, D3 &gt;, std::integral_constant&lt; unsigned int, D4 &gt;, std::integral_constant&lt; unsigned int, D5 &gt;, std::integral_constant&lt; unsigned int, D6 &gt;, std::integral_constant&lt; unsigned int, D7 &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_decomp.html">QRDecomp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_exception.html">QRException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_invalid_matrix_size.html">QRInvalidMatrixSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_null_pivot.html">QRNullPivot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_unmatched_size.html">QRUnmatchedSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1qt.html">qt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes numbers with unit. qt must be has efficient and simple to use that standard numerical types.  <a href="classtfel_1_1math_1_1qt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1qt_3_01_no_unit_00_01_t_01_4.html">qt&lt; NoUnit, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization in case NoUnit. This class shall be implicitly convertible to T and T must be convertible to qt&lt;T,nounit&gt;.  <a href="classtfel_1_1math_1_1qt_3_01_no_unit_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_of_evaluation.html">ResultOfEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a metafunction giving the result of a the evaluation of an object.  <a href="structtfel_1_1math_1_1_result_of_evaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_of_evaluation_3_01_expr_3_01_result_type_00_01_operation_01_4_01_4.html">ResultOfEvaluation&lt; Expr&lt; ResultType, Operation &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_result_of_evaluation.html" title="a metafunction giving the result of a the evaluation of an object. ">ResultOfEvaluation</a></code> class for objects representing a lazy expression.  <a href="structtfel_1_1math_1_1_result_of_evaluation_3_01_expr_3_01_result_type_00_01_operation_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01cadna_1_1numeric__type_3_01_t1_01_4_00_01cadna_1_1numeric4647a7dbf40f75c8d11b614983725a44.html">ResultType&lt; cadna::numeric_type&lt; T1 &gt;, cadna::numeric_type&lt; T2 &gt;, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01cadna_1_1numeric__type_3_01_t1_01_4_00_01_t2_00_01_op_01_4.html">ResultType&lt; cadna::numeric_type&lt; T1 &gt;, T2, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; qt&lt; unit, T1 &gt;, qt&lt; unit, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for substraction of two qt having the same unit.  <a href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; qt&lt; unit, T1 &gt;, qt&lt; unit, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for addition of two qt having the same unit.  <a href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit2_00_01_t2_01_4_00_01_op_div_01_4.html">ResultType&lt; qt&lt; unit, T1 &gt;, qt&lt; unit2, T2 &gt;, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for division of two qt.  <a href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit2_00_01_t2_01_4_00_01_op_div_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit2_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; qt&lt; unit, T1 &gt;, qt&lt; unit2, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for multiplication of two qt.  <a href="structtfel_1_1math_1_1_result_type_3_01qt_3_01unit_00_01_t1_01_4_00_01qt_3_01unit2_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, st2tost2&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, st2tost2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a> and <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, st2tost2&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a> and stensor multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, t2tost2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> and <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, st2tost2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, st2tot2&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, st2tot2&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> and stensor multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, t2tost2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_0b335bb17f35cb9beb6dc8e4321e2e831.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_0b335bb17f35cb9beb6dc8e4321e2e831.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpDotProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01st2tost2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html">ResultType&lt; stensor&lt; N, T2 &gt;, st2tost2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor and <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01st2tost2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01t2tost2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html">ResultType&lt; stensor&lt; N, T2 &gt;, t2tost2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01t2tost2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01tensor_3_01_n_00_01_t_01_4_00_01_op_minus_01_4.html">ResultType&lt; stensor&lt; N, T2 &gt;, tensor&lt; N, T &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01tensor_3_01_n_00_01_t_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01tensor_3_01_n_00_01_t_01_4_00_01_op_plus_01_4.html">ResultType&lt; stensor&lt; N, T2 &gt;, tensor&lt; N, T &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01tensor_3_01_n_00_01_t_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01_t1_00_01cadna_1_1numeric__type_3_01_t2_01_4_00_01_op_01_4.html">ResultType&lt; T1, cadna::numeric_type&lt; T2 &gt;, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, st2tot2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, t2tost2&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, t2tost2&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, t2tot2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> and <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> and tensor multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, st2tot2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, t2tot2&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, t2tot2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, t2tot2&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and tensor multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpDotProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t2_01_4_00_01st2tot2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html">ResultType&lt; tensor&lt; N, T2 &gt;, st2tot2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t2_01_4_00_01st2tot2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t2_01_4_00_01t2tot2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html">ResultType&lt; tensor&lt; N, T2 &gt;, t2tot2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t2_01_4_00_01t2tot2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tmatrix_3_01_n_00d23288766b859f04393212189880780a.html">ResultType&lt; tmatrix&lt; N, M, T &gt;, tmatrix&lt; N, M, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix.  <a href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tmatrix_3_01_n_00d23288766b859f04393212189880780a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tmatrix_3_01_n_00fb04be3c3710f39eeffa976edd33cc6b.html">ResultType&lt; tmatrix&lt; N, M, T &gt;, tmatrix&lt; N, M, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix.  <a href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tmatrix_3_01_n_00fb04be3c3710f39eeffa976edd33cc6b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tvector_3_01_m_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tmatrix&lt; N, M, T &gt;, tvector&lt; M, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tmatrix_3_01_n_00_01_m_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tmatrix&lt; N, M, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_m_00_01_t2_09e8a9814bcfc77e83ac21a8ba95ba5f9.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; M, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_m_00_01_t2_09e8a9814bcfc77e83ac21a8ba95ba5f9.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt;, OpDotProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="structtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_diadic_product_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_diadic_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_dot_product_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpDotProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_dot_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type__.html">ResultType_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_matrix_tag_00_01_scalar_tag_00_01tmatrix_3_01_n_00_01_me9ae6de7965859d27ef03434bc6c7f52.html">ResultType_&lt; MatrixTag, ScalarTag, tmatrix&lt; N, M, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_matrix_tag_00_01_scalar_tag_00_01tmatrix_3_01_n_00_01_me9ae6de7965859d27ef03434bc6c7f52.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_matrix_tag_00_01_scalar_tag_00_01tmatrix_3_01_n_00_01_ma0e653c3d66a6288b06d91a432e1fec6.html">ResultType_&lt; MatrixTag, ScalarTag, tmatrix&lt; N, M, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_matrix_tag_00_01_scalar_tag_00_01tmatrix_3_01_n_00_01_ma0e653c3d66a6288b06d91a432e1fec6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_matrix_tag_00_01_scal_00_01tmatrix_3_08cda50d859ca3ee73ffea7c032d22569.html">ResultType_&lt; ScalarTag, MatrixTag, Scal, tmatrix&lt; N, M, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_matrix_tag_00_01_scal_00_01tmatrix_3_08cda50d859ca3ee73ffea7c032d22569.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_s_t2to_s_t2_tag_00_01_scal_00_01st2tosc1d0c5b514bcf06bbf7c906ae91b01a7.html">ResultType_&lt; ScalarTag, ST2toST2Tag, Scal, st2tost2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_s_t2to_s_t2_tag_00_01_scal_00_01st2tosc1d0c5b514bcf06bbf7c906ae91b01a7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_s_t2to_t2_tag_00_01_scal_00_01st2tot2_a1150ab073afbc19ae903b1717c8dc7f.html">ResultType_&lt; ScalarTag, ST2toT2Tag, Scal, st2tot2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_s_t2to_t2_tag_00_01_scal_00_01st2tot2_a1150ab073afbc19ae903b1717c8dc7f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_stensor_tag_00_01_scal_00_01stensor_3_0acf953d529361483f81aa0448d57284.html">ResultType_&lt; ScalarTag, StensorTag, Scal, stensor&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_stensor_tag_00_01_scal_00_01stensor_3_0acf953d529361483f81aa0448d57284.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_t2to_s_t2_tag_00_01_scal_00_01t2tost2_f15a598792b8786ebabdc98be50cd8a3.html">ResultType_&lt; ScalarTag, T2toST2Tag, Scal, t2tost2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_t2to_s_t2_tag_00_01_scal_00_01t2tost2_f15a598792b8786ebabdc98be50cd8a3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_t2to_t2_tag_00_01_scal_00_01t2tot2_3_0dec645c7ae871308e02efe1b28649eae.html">ResultType_&lt; ScalarTag, T2toT2Tag, Scal, t2tot2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_t2to_t2_tag_00_01_scal_00_01t2tot2_3_0dec645c7ae871308e02efe1b28649eae.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_tensor_tag_00_01_scal_00_01tensor_3_014e8854cb7ff9ea600a3a10ef3d4a31b1.html">ResultType_&lt; ScalarTag, TensorTag, Scal, tensor&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_tensor_tag_00_01_scal_00_01tensor_3_014e8854cb7ff9ea600a3a10ef3d4a31b1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_vector_tag_00_01_scal_00_01tvector_3_06d89c62f22b8c70bd66aa33a9632978d.html">ResultType_&lt; ScalarTag, VectorTag, Scal, tvector&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_vector_tag_00_01_scal_00_01tvector_3_06d89c62f22b8c70bd66aa33a9632978d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_vector_tag_00_01_scal_00_01vector_3_01_t_01_4_00_01_op_mult_01_4.html">ResultType_&lt; ScalarTag, VectorTag, Scal, vector&lt; T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_scalar_tag_00_01_vector_tag_00_01_scal_00_01vector_3_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_01st2tost2_3_01_n_0a614054aff72840d9e550611497117e8.html">ResultType_&lt; ST2toST2Tag, ScalarTag, st2tost2&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_01st2tost2_3_01_n_0a614054aff72840d9e550611497117e8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_01st2tost2_3_01_n_0521cc28819535bc0ad60c9fe3cfcc369.html">ResultType_&lt; ST2toST2Tag, ScalarTag, st2tost2&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_01st2tost2_3_01_n_0521cc28819535bc0ad60c9fe3cfcc369.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01st2tot2_3_01_n_00_0a746b811fc90e8eb495efd24d62f24d5.html">ResultType_&lt; ST2toT2Tag, ScalarTag, st2tot2&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01st2tot2_3_01_n_00_0a746b811fc90e8eb495efd24d62f24d5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01st2tot2_3_01_n_00_0c5c9e23c9f092d87a43a222428f714b5.html">ResultType_&lt; ST2toT2Tag, ScalarTag, st2tot2&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01st2tot2_3_01_n_00_0c5c9e23c9f092d87a43a222428f714b5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_stensor_tag_00_01_scalar_tag_00_01stensor_3_01_n_00_01_02b6ad26cf90e4198148ca4a8058223f.html">ResultType_&lt; StensorTag, ScalarTag, stensor&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_stensor_tag_00_01_scalar_tag_00_01stensor_3_01_n_00_01_02b6ad26cf90e4198148ca4a8058223f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_stensor_tag_00_01_scalar_tag_00_01stensor_3_01_n_00_01_819aced7a8169610cc89d37a357ed134.html">ResultType_&lt; StensorTag, ScalarTag, stensor&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_stensor_tag_00_01_scalar_tag_00_01stensor_3_01_n_00_01_819aced7a8169610cc89d37a357ed134.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01t2tost2_3_01_n_00_00c1fbf515130e142b798bc63e27ad3d2.html">ResultType_&lt; T2toST2Tag, ScalarTag, t2tost2&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01t2tost2_3_01_n_00_00c1fbf515130e142b798bc63e27ad3d2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01t2tost2_3_01_n_00_00984a9c8e14878213cf153a46182359b.html">ResultType_&lt; T2toST2Tag, ScalarTag, t2tost2&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01t2tost2_3_01_n_00_00984a9c8e14878213cf153a46182359b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_t2to_t2_tag_00_01_scalar_tag_00_01t2tot2_3_01_n_00_01_tdccd9191702872cc2e27780865169c3d.html">ResultType_&lt; T2toT2Tag, ScalarTag, t2tot2&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_t2to_t2_tag_00_01_scalar_tag_00_01t2tot2_3_01_n_00_01_tdccd9191702872cc2e27780865169c3d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_t2to_t2_tag_00_01_scalar_tag_00_01t2tot2_3_01_n_00_01_t73b3cb6d26b5678c356802fc2084de3a.html">ResultType_&lt; T2toT2Tag, ScalarTag, t2tot2&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_t2to_t2_tag_00_01_scalar_tag_00_01t2tot2_3_01_n_00_01_t73b3cb6d26b5678c356802fc2084de3a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_tensor_tag_00_01_scalar_tag_00_01tensor_3_01_n_00_01_t_48e165fb69a0785a902518a3dc6a0bd8.html">ResultType_&lt; TensorTag, ScalarTag, tensor&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_tensor_tag_00_01_scalar_tag_00_01tensor_3_01_n_00_01_t_48e165fb69a0785a902518a3dc6a0bd8.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_tensor_tag_00_01_scalar_tag_00_01tensor_3_01_n_00_01_t_a879824024c9915aab6ff978413fd8dd.html">ResultType_&lt; TensorTag, ScalarTag, tensor&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_tensor_tag_00_01_scalar_tag_00_01tensor_3_01_n_00_01_t_a879824024c9915aab6ff978413fd8dd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01tvector_3_01_n_00_01_t8e27333d965750e6f98ae80503d13d97.html">ResultType_&lt; VectorTag, ScalarTag, tvector&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01tvector_3_01_n_00_01_t8e27333d965750e6f98ae80503d13d97.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01tvector_3_01_n_00_01_t81b86aee6785def0b1c16375a794c6f5.html">ResultType_&lt; VectorTag, ScalarTag, tvector&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01tvector_3_01_n_00_01_t81b86aee6785def0b1c16375a794c6f5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01vector_3_01_t_01_4_00_01_scal_00_01_op_div_01_4.html">ResultType_&lt; VectorTag, ScalarTag, vector&lt; T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01vector_3_01_t_01_4_00_01_scal_00_01_op_div_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01vector_3_01_t_01_4_00_01_scal_00_01_op_mult_01_4.html">ResultType_&lt; VectorTag, ScalarTag, vector&lt; T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_result_type___3_01_vector_tag_00_01_scalar_tag_00_01vector_3_01_t_01_4_00_01_scal_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_right_cauchy_green_tensor_derivative_expr.html">RightCauchyGreenTensorDerivativeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declaration  <a href="structtfel_1_1math_1_1_right_cauchy_green_tensor_derivative_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runge_kutta2.html">RungeKutta2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_runge_kutta4.html">RungeKutta4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runge_kutta42.html">RungeKutta42</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runge_kutta54.html">RungeKutta54</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_run_time_check.html">RunTimeCheck</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_run_time_check_3_01_empty_run_time_properties_01_4.html">RunTimeCheck&lt; EmptyRunTimeProperties &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runtime_check_failure.html">RuntimeCheckFailure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_scalar_newton_raphson_parameters.html">ScalarNewtonRaphsonParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure holding parameters of the <code>scalarNewtonRaphson</code> function.  <a href="structtfel_1_1math_1_1_scalar_newton_raphson_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_scalar_object_operation.html">ScalarObjectOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_scalar_object_random_access_const_iterator.html">ScalarObjectRandomAccessConstIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_scalar_object_random_access_const_iterator_3_01_a_00_01_b_00_01_op_div_01_4.html">ScalarObjectRandomAccessConstIterator&lt; A, B, OpDiv &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_scalar_object_random_access_const_iterator_3_01_a_00_01_b_00_01_op_mult_01_4.html">ScalarObjectRandomAccessConstIterator&lt; A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_scalar_tag.html">ScalarTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise scalars.  <a href="structtfel_1_1math_1_1_scalar_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_singular_jacobian_exception.html">SingularJacobianException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear operator on symmetric tensors.  <a href="structtfel_1_1math_1_1st2tost2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1st2tost2__base.html">st2tost2_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for stensor or classes acting like stensor.  <a href="structtfel_1_1math_1_1st2tost2__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_from_tiny_matrix_view.html">ST2toST2FromTinyMatrixView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_from_tiny_matrix_view2.html">ST2toST2FromTinyMatrixView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_from_tiny_matrix_view2_expr.html">ST2toST2FromTinyMatrixView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_from_tiny_matrix_view_expr.html">ST2toST2FromTinyMatrixViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_s_t2to_s_t2_product_expr.html">ST2toST2ST2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_stensor_product_expr.html">ST2toST2StensorProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_t2to_s_t2_product_expr.html">ST2toST2T2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_tag.html">ST2toST2Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>.  <a href="structtfel_1_1math_1_1_s_t2to_s_t2_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html">ST2toST2TransposeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias  <a href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_view_expr.html">ST2toST2ViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1st2tot2__base.html">st2tot2_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for stensor or classes acting like stensor.  <a href="structtfel_1_1math_1_1st2tot2__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_concept.html">ST2toT2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_s_t2to_s_t2_product_expr.html">ST2toT2ST2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_stensor_product_expr.html">ST2toT2StensorProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_t2to_s_t2_product_expr.html">ST2toT2T2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_tag.html">ST2toT2Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>.  <a href="structtfel_1_1math_1_1_s_t2to_t2_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_view_expr.html">ST2toT2ViewExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple place holder  <a href="structtfel_1_1math_1_1_s_t2to_t2_view_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_standard_array_policy_aliases.html">StandardArrayPolicyAliases</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">symmetric tensor.  <a href="structtfel_1_1math_1_1stensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1stensor__base.html">stensor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for stensor or classes acting like stensor.  <a href="structtfel_1_1math_1_1stensor__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1stensor__common.html">stensor_common</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper structure inherited by the <code>stensor</code> class  <a href="structtfel_1_1math_1_1stensor__common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_dime_to_size.html">StensorDimeToSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction which returns the number of components of an stensor given the spatial dimension used. The correspondance between these two numbers is given by the following table:  <a href="structtfel_1_1math_1_1_stensor_dime_to_size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_dime_to_size_3_011u_01_4.html">StensorDimeToSize&lt; 1u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 1D.  <a href="structtfel_1_1math_1_1_stensor_dime_to_size_3_011u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_dime_to_size_3_012u_01_4.html">StensorDimeToSize&lt; 2u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 2D.  <a href="structtfel_1_1math_1_1_stensor_dime_to_size_3_012u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_dime_to_size_3_013u_01_4.html">StensorDimeToSize&lt; 3u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 3D.  <a href="structtfel_1_1math_1_1_stensor_dime_to_size_3_013u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_column_view.html">StensorFromTinyMatrixColumnView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_column_view2.html">StensorFromTinyMatrixColumnView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_column_view2_expr.html">StensorFromTinyMatrixColumnView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_column_view_expr.html">StensorFromTinyMatrixColumnViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_row_view.html">StensorFromTinyMatrixRowView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_row_view2.html">StensorFromTinyMatrixRowView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_row_view2_expr.html">StensorFromTinyMatrixRowView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_matrix_row_view_expr.html">StensorFromTinyMatrixRowViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_vector_view.html">StensorFromTinyVectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_from_tiny_vector_view_expr.html">StensorFromTinyVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_expr1_d.html">StensorProductExpr1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_expr2_d.html">StensorProductExpr2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_expr3_d.html">StensorProductExpr3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_stensor_product_expr_base.html">StensorProductExprBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_left_derivative_expr.html">StensorProductLeftDerivativeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_right_derivative_expr.html">StensorProductRightDerivativeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_size_to_dime.html">StensorSizeToDime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction which returns the spatial dimension given the number of components of a stensor.  <a href="structtfel_1_1math_1_1_stensor_size_to_dime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_size_to_dime_3_013u_01_4.html">StensorSizeToDime&lt; 3u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 1D.  <a href="structtfel_1_1math_1_1_stensor_size_to_dime_3_013u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_size_to_dime_3_014u_01_4.html">StensorSizeToDime&lt; 4u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 2D.  <a href="structtfel_1_1math_1_1_stensor_size_to_dime_3_014u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_size_to_dime_3_016u_01_4.html">StensorSizeToDime&lt; 6u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 3D.  <a href="structtfel_1_1math_1_1_stensor_size_to_dime_3_016u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_square_derivative_expr.html">StensorSquareDerivativeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_s_t2to_s_t2_product_expr.html">StensorST2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_symmetric_product_derivative.html">StensorSymmetricProductDerivative</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_symmetric_product_derivative_3_011u_00_01_t_01_4.html">StensorSymmetricProductDerivative&lt; 1u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_symmetric_product_derivative_3_012u_00_01_t_01_4.html">StensorSymmetricProductDerivative&lt; 2u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_symmetric_product_derivative_3_013u_00_01_t_01_4.html">StensorSymmetricProductDerivative&lt; 3u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_t2to_s_t2_product_expr.html">StensorT2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_tag.html">StensorTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise stensors.  <a href="structtfel_1_1math_1_1_stensor_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_view_expr.html">StensorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an adaptator to random access iterator  <a href="structtfel_1_1math_1_1_strided_random_access_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator_base.html">StridedRandomAccessIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class of the <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html" title="an adaptator to random access iterator ">StridedRandomAccessIterator</a> containing some static common utility methods.  <a href="structtfel_1_1math_1_1_strided_random_access_iterator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_sub_unit__.html">SubUnit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_sub_unit___3_01_unit_3_01std_1_1integral__constant_3_01int_00_01_n1_01_4_43e53766f29d0aabc5d40527d3dc5dc5.html">SubUnit_&lt; Unit&lt; std::integral_constant&lt; int, N1 &gt;, std::integral_constant&lt; int, N2 &gt;, std::integral_constant&lt; int, N3 &gt;, std::integral_constant&lt; int, N4 &gt;, std::integral_constant&lt; int, N5 &gt;, std::integral_constant&lt; int, N6 &gt;, std::integral_constant&lt; int, N7 &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt; &gt;, Unit&lt; std::integral_constant&lt; int, O1 &gt;, std::integral_constant&lt; int, O2 &gt;, std::integral_constant&lt; int, O3 &gt;, std::integral_constant&lt; int, O4 &gt;, std::integral_constant&lt; int, O5 &gt;, std::integral_constant&lt; int, O6 &gt;, std::integral_constant&lt; int, O7 &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_sub_unit___3_01_unit_3_01std_1_1integral__constant_3_01int_00_01_n1_01_4_be4082d880dae6c274e4fa573469b6a9.html">SubUnit_&lt; Unit&lt; std::integral_constant&lt; int, N1 &gt;, std::integral_constant&lt; int, N2 &gt;, std::integral_constant&lt; int, N3 &gt;, std::integral_constant&lt; int, N4 &gt;, std::integral_constant&lt; int, N5 &gt;, std::integral_constant&lt; int, N6 &gt;, std::integral_constant&lt; int, N7 &gt;, std::integral_constant&lt; unsigned int, D1 &gt;, std::integral_constant&lt; unsigned int, D2 &gt;, std::integral_constant&lt; unsigned int, D3 &gt;, std::integral_constant&lt; unsigned int, D4 &gt;, std::integral_constant&lt; unsigned int, D5 &gt;, std::integral_constant&lt; unsigned int, D6 &gt;, std::integral_constant&lt; unsigned int, D7 &gt; &gt;, Unit&lt; std::integral_constant&lt; int, O1 &gt;, std::integral_constant&lt; int, O2 &gt;, std::integral_constant&lt; int, O3 &gt;, std::integral_constant&lt; int, O4 &gt;, std::integral_constant&lt; int, O5 &gt;, std::integral_constant&lt; int, O6 &gt;, std::integral_constant&lt; int, O7 &gt;, std::integral_constant&lt; unsigned int, AP1 &gt;, std::integral_constant&lt; unsigned int, AP2 &gt;, std::integral_constant&lt; unsigned int, AP3 &gt;, std::integral_constant&lt; unsigned int, AP4 &gt;, std::integral_constant&lt; unsigned int, AP5 &gt;, std::integral_constant&lt; unsigned int, AP6 &gt;, std::integral_constant&lt; unsigned int, AP7 &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear operator which turns an unsymmetric tensor to symmetric tensor.  <a href="structtfel_1_1math_1_1t2tost2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1t2tost2__base.html">t2tost2_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for stensor or classes acting like stensor.  <a href="structtfel_1_1math_1_1t2tost2__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_s_t2to_t2_product_expr.html">T2toST2ST2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_t2to_t2_product_expr.html">T2toST2T2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_tag.html">T2toST2Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a>.  <a href="structtfel_1_1math_1_1_t2to_s_t2_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_tensor_product_expr.html">T2toST2TensorProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_view_expr.html">T2toST2ViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1t2tot2__base.html">t2tot2_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for stensor or classes acting like stensor.  <a href="structtfel_1_1math_1_1t2tot2__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_concept.html">T2toT2Concept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_s_t2to_t2_product_expr.html">T2toT2ST2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_t2to_t2_product_expr.html">T2toT2T2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_tag.html">T2toT2Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>.  <a href="structtfel_1_1math_1_1_t2to_t2_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_tensor_product_expr.html">T2toT2TensorProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_view_expr.html">T2toT2ViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tensor__base.html">tensor_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for tensor or classes acting like tensor.  <a href="structtfel_1_1math_1_1tensor__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_dime_to_size.html">TensorDimeToSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction which returns the number of components of an tensor given the spatial dimension used. The correspondance between these two numbers is given by the following table:  <a href="structtfel_1_1math_1_1_tensor_dime_to_size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_dime_to_size_3_011u_01_4.html">TensorDimeToSize&lt; 1u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 1D.  <a href="structtfel_1_1math_1_1_tensor_dime_to_size_3_011u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_dime_to_size_3_012u_01_4.html">TensorDimeToSize&lt; 2u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 2D.  <a href="structtfel_1_1math_1_1_tensor_dime_to_size_3_012u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_dime_to_size_3_013u_01_4.html">TensorDimeToSize&lt; 3u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 3D.  <a href="structtfel_1_1math_1_1_tensor_dime_to_size_3_013u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_column_view.html">TensorFromTinyMatrixColumnView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_column_view2.html">TensorFromTinyMatrixColumnView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_column_view2_expr.html">TensorFromTinyMatrixColumnView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_column_view_expr.html">TensorFromTinyMatrixColumnViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_row_view.html">TensorFromTinyMatrixRowView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_row_view2.html">TensorFromTinyMatrixRowView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_row_view2_expr.html">TensorFromTinyMatrixRowView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_matrix_row_view_expr.html">TensorFromTinyMatrixRowViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_vector_view.html">TensorFromTinyVectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_from_tiny_vector_view_expr.html">TensorFromTinyVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_invalid_indexes_exception.html">TensorInvalidIndexesException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception thrown if invalid indexes were given  <a href="structtfel_1_1math_1_1_tensor_invalid_indexes_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_invalid_index_exception.html">TensorInvalidIndexException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception thrown if invalid index is given  <a href="structtfel_1_1math_1_1_tensor_invalid_index_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_invalid_initializer_list_size_exception.html">TensorInvalidInitializerListSizeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception thrown if an std::initializer_list with no appropriate size is affected to a tensor.  <a href="structtfel_1_1math_1_1_tensor_invalid_initializer_list_size_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_expr1_d.html">TensorProductExpr1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_expr2_d.html">TensorProductExpr2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_expr3_d.html">TensorProductExpr3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_expr_base.html">TensorProductExprBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_left_derivative_expr.html">TensorProductLeftDerivativeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_right_derivative_expr.html">TensorProductRightDerivativeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_size_to_dime.html">TensorSizeToDime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metafunction which returns the spatial dimension given the number of components of a tensor.  <a href="structtfel_1_1math_1_1_tensor_size_to_dime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_size_to_dime_3_013u_01_4.html">TensorSizeToDime&lt; 3u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 1D.  <a href="structtfel_1_1math_1_1_tensor_size_to_dime_3_013u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_size_to_dime_3_015u_01_4.html">TensorSizeToDime&lt; 5u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 2D.  <a href="structtfel_1_1math_1_1_tensor_size_to_dime_3_015u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_size_to_dime_3_019u_01_4.html">TensorSizeToDime&lt; 9u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for 3D.  <a href="structtfel_1_1math_1_1_tensor_size_to_dime_3_019u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_s_t2to_t2_product_expr.html">TensorST2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_t2to_t2_product_expr.html">TensorT2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_tag.html">TensorTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper class to characterize tensors.  <a href="structtfel_1_1math_1_1_tensor_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_transpose_expr1_d.html">TensorTransposeExpr1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_transpose_expr2_d.html">TensorTransposeExpr2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_transpose_expr3_d.html">TensorTransposeExpr3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_transpose_expr_base.html">TensorTransposeExprBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_view_expr.html">TensorViewExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tensor view expression  <a href="structtfel_1_1math_1_1_tensor_view_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_view_from_stensor.html">TensorViewFromStensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_view_from_stensor_expr.html">TensorViewFromStensorExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_invert.html">TinyMatrixInvert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve.html">TinyMatrixSolve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve_3_011u_00_01_t_01_4.html">TinyMatrixSolve&lt; 1u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve_3_012u_00_01_t_01_4.html">TinyMatrixSolve&lt; 2u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve_3_013u_00_01_t_01_4.html">TinyMatrixSolve&lt; 3u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve_base.html">TinyMatrixSolveBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_tiny_newton_raphson.html">TinyNewtonRaphson</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Newton-Raphson algorithm when the size N of the problem is known at compile-time. One wish to solve the problem: </p><p class="formulaDsp">
\[\vec{f}\left(\vec{x}\right)=\vec{0}\]
</p>
<p> where \(\displaystyle\vec{f}:R^{N}\rightarrow R^{N}\). if \(\displaystyle\vec{x}^{n}\) is an estimation of the solution, \(\displaystyle\vec{x}^{n+1}\) will be given by: </p><p class="formulaDsp">
\[\displaystyle\vec{x}^{n+1}=\vec{x}^{n}-J^{-1}\vec{f}\left(\vec{x}^{n}\right)\]
</p>
<p> where \( J \) is the jacobien matrix of \( f \) at \(\left(\displaystyle\vec{x}^{n}\right)\) defined by \( J_{ij} = \displaystyle\frac{\displaystyle\partial f_{i}}{\displaystyle\partial x_{j}}\).  <a href="classtfel_1_1math_1_1_tiny_newton_raphson.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_tiny_newton_raphson_3_011u_00_01_t_00_01_f_01_4.html">TinyNewtonRaphson&lt; 1u, T, F &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_permutation.html">TinyPermutation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view.html">TinyVectorFromTinyVectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_vector_of_stensor_from_tiny_vector_view.html">TinyVectorOfStensorFromTinyVectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_vector_of_stensor_from_tiny_vector_view_expr.html">TinyVectorOfStensorFromTinyVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_vector_of_tiny_vector_from_tiny_vector_view.html">TinyVectorOfTinyVectorFromTinyVectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_vector_of_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorOfTinyVectorFromTinyVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__base.html">tmatrix_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for tmatrix or classes acting like tmatrix.  <a href="structtfel_1_1math_1_1tmatrix__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__column__view.html">tmatrix_column_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__column__view__expr.html">tmatrix_column_view_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__const__column__view.html">tmatrix_const_column_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__const__row__view.html">tmatrix_const_row_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__const__row__view__expr.html">tmatrix_const_row_view_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__const__submatrix__view.html">tmatrix_const_submatrix_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__const__submatrix__view__expr.html">tmatrix_const_submatrix_view_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__row__view.html">tmatrix_row_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__row__view__expr.html">tmatrix_row_view_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__submatrix__view.html">tmatrix_submatrix_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix__submatrix__view__expr.html">tmatrix_submatrix_view_expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_matrix_const_column_view.html">TMatrixConstColumnView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_matrix_t_vector_expr.html">TMatrixTVectorExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for the computation of product of a tiny matrix and a tiny vector.  <a href="structtfel_1_1math_1_1_t_matrix_t_vector_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_matrix_view_expr.html">TMatrixViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tvector__base.html">tvector_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base for tvector or classes acting like tvector.  <a href="structtfel_1_1math_1_1tvector__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tvector_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_t_vector_from_tiny_mat4a0fcf4621ebce4274a9b65ffa345efc.html">TvectorExpr&lt; tvector&lt; N, T &gt;, TVectorFromTinyMatrixColumnView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tvector_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_t_vector_from_tiny_matc3dae03e360ec0e0492bcefc382b8706.html">TvectorExpr&lt; tvector&lt; N, T &gt;, TVectorFromTinyMatrixColumnViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tvector_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_t_vector_from_tiny_mat5c97a6f3fba398c0a730ce040ae98f7a.html">TvectorExpr&lt; tvector&lt; N, T &gt;, TVectorFromTinyMatrixRowView2Expr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tvector_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_t_vector_from_tiny_mata4a7c60f114e3a6cf7250d818379ec7f.html">TvectorExpr&lt; tvector&lt; N, T &gt;, TVectorFromTinyMatrixRowViewExpr&lt; N, Mn, Mm, In, Im, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tvector_expr_3_01tvector_3_01_n_00_01_t_01_4_00_01_t_vector_from_tiny_vecf7cd59d23a0361aaddbc577239d6a49e.html">TvectorExpr&lt; tvector&lt; N, T &gt;, TVectorFromTinyVectorViewExpr&lt; N, Mn, In, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_column_view.html">TVectorFromTinyMatrixColumnView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_column_view2.html">TVectorFromTinyMatrixColumnView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_column_view2_expr.html">TVectorFromTinyMatrixColumnView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_column_view_expr.html">TVectorFromTinyMatrixColumnViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_row_view.html">TVectorFromTinyMatrixRowView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_row_view2.html">TVectorFromTinyMatrixRowView2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_row_view2_expr.html">TVectorFromTinyMatrixRowView2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_matrix_row_view_expr.html">TVectorFromTinyMatrixRowViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_vector_view.html">TVectorFromTinyVectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_from_tiny_vector_view_expr.html">TVectorFromTinyVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_t_matrix_expr.html">TVectorTMatrixExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_view_expr.html">TVectorViewExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_u_anderson.html">UAnderson</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator.html">UmatNormaliseTangentOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalise the tangent operator returned by:  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html">UmatNormaliseTangentOperatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalise the tangent operator returned by:  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_011u_00_01stress_01_4.html">UmatNormaliseTangentOperatorBase&lt; 1u, stress &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html" title="normalise the tangent operator returned by: ">UmatNormaliseTangentOperatorBase</a></code> class in 1D.  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_011u_00_01stress_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_012u_00_01stress_01_4.html">UmatNormaliseTangentOperatorBase&lt; 2u, stress &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html" title="normalise the tangent operator returned by: ">UmatNormaliseTangentOperatorBase</a></code> class in 1D  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_012u_00_01stress_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_013u_00_01stress_01_4.html">UmatNormaliseTangentOperatorBase&lt; 3u, stress &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html" title="normalise the tangent operator returned by: ">UmatNormaliseTangentOperatorBase</a></code> class in 1D  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_013u_00_01stress_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_operation.html">UnaryOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_operator_tag.html">UnaryOperatorTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise operators.  <a href="structtfel_1_1math_1_1_unary_operator_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type.html">UnaryResultType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01cadna_1_1numeric__type_3_01_t_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; cadna::numeric_type&lt; T &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01_complex_3_01double_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; Complex&lt; double &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01_complex_3_01float_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; Complex&lt; float &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01_complex_3_01long_01double_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; Complex&lt; long double &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01double_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; double, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01float_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; float, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01long_01double_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; long double, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01_complex_3_01double_01_4_01_4_00_061d6b5a193fd75b770af8793d45c486d.html">UnaryResultType&lt; qt&lt; Unit, Complex&lt; double &gt; &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01_complex_3_01float_01_4_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; qt&lt; Unit, Complex&lt; float &gt; &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01_complex_3_01long_01double_01_4_015cb1689c54c69868d2635b7dded33ef6.html">UnaryResultType&lt; qt&lt; Unit, Complex&lt; long double &gt; &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01double_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; qt&lt; Unit, double &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01float_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; qt&lt; Unit, float &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01long_01double_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; qt&lt; Unit, long double &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; st2tost2&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; st2tot2&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; stensor&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; t2tost2&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; t2tot2&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; tensor&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; tmatrix&lt; N, M, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; tvector&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01vector_3_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; vector&lt; T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type__.html">UnaryResultType_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for <a class="el" href="classtfel_1_1math_1_1_unary_result_type.html">UnaryResultType</a>. This default version returns InvalidType both for Result and Handle.  <a href="structtfel_1_1math_1_1_unary_result_type__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unit_3_01std_1_1integral__constant_3_01int_00_01_n1_01_4_00_01std_1_1inte22245c37637fc2ae3e1f4d95f396757e.html">Unit&lt; std::integral_constant&lt; int, N1 &gt;, std::integral_constant&lt; int, N2 &gt;, std::integral_constant&lt; int, N3 &gt;, std::integral_constant&lt; int, N4 &gt;, std::integral_constant&lt; int, N5 &gt;, std::integral_constant&lt; int, N6 &gt;, std::integral_constant&lt; int, N7 &gt;, std::integral_constant&lt; unsigned int, D1 &gt;, std::integral_constant&lt; unsigned int, D2 &gt;, std::integral_constant&lt; unsigned int, D3 &gt;, std::integral_constant&lt; unsigned int, D4 &gt;, std::integral_constant&lt; unsigned int, D5 &gt;, std::integral_constant&lt; unsigned int, D6 &gt;, std::integral_constant&lt; unsigned int, D7 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing dynamically allocated vector.  <a href="classtfel_1_1math_1_1vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_concept.html">VectorConcept</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_dot_product_handle.html">VectorDotProductHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_dot_product_handle_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_01_4.html">VectorDotProductHandle&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_vector_matrix_handle.html">VectorMatrixHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_tag.html">VectorTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise vectors.  <a href="structtfel_1_1math_1_1_vector_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab.html">vectorToTab</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure copy a vector to an array.  <a href="structtfel_1_1math_1_1vector_to_tab.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_010u_01_4.html">vectorToTab&lt; 0u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=0 to end the recursion.  <a href="structtfel_1_1math_1_1vector_to_tab_3_010u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_0110u_01_4.html">vectorToTab&lt; 10u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=10.  <a href="structtfel_1_1math_1_1vector_to_tab_3_0110u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_011u_01_4.html">vectorToTab&lt; 1u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=1.  <a href="structtfel_1_1math_1_1vector_to_tab_3_011u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_012u_01_4.html">vectorToTab&lt; 2u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=2.  <a href="structtfel_1_1math_1_1vector_to_tab_3_012u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_013u_01_4.html">vectorToTab&lt; 3u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=3.  <a href="structtfel_1_1math_1_1vector_to_tab_3_013u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_014u_01_4.html">vectorToTab&lt; 4u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=4.  <a href="structtfel_1_1math_1_1vector_to_tab_3_014u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_015u_01_4.html">vectorToTab&lt; 5u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=5.  <a href="structtfel_1_1math_1_1vector_to_tab_3_015u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_016u_01_4.html">vectorToTab&lt; 6u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=6.  <a href="structtfel_1_1math_1_1vector_to_tab_3_016u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_017u_01_4.html">vectorToTab&lt; 7u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=7.  <a href="structtfel_1_1math_1_1vector_to_tab_3_017u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_018u_01_4.html">vectorToTab&lt; 8u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structtfel_1_1math_1_1vector_to_tab.html" title="This structure copy a vector to an array. ">vectorToTab</a> class for N=8.  <a href="structtfel_1_1math_1_1vector_to_tab_3_018u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector_to_tab_3_019u_01_4.html">vectorToTab&lt; 9u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for N=9.  <a href="structtfel_1_1math_1_1vector_to_tab_3_019u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_utilities.html">VectorUtilities</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the class <a class="el" href="structtfel_1_1math_1_1_vector_utilities.html" title="the class VectorUtilities contains a set of functions to be applied to every item of a vector...">VectorUtilities</a> contains a set of functions to be applied to every item of a vector. Those functions are implemented recursively and inlined.  <a href="structtfel_1_1math_1_1_vector_utilities.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_utilities_3_010u_01_4.html">VectorUtilities&lt; 0u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This partial specialisation for N=0 is used to end the recursion.  <a href="structtfel_1_1math_1_1_vector_utilities_3_010u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_vector_dot_product.html">VectorVectorDotProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af77fbcb0679a70e562fe1e0f10f5e61c"><td class="memTemplParams" colspan="2"><a id="af77fbcb0679a70e562fe1e0f10f5e61c"></a>
template&lt;typename ObjectType &gt; </td></tr>
<tr class="memitem:af77fbcb0679a70e562fe1e0f10f5e61c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af77fbcb0679a70e562fe1e0f10f5e61c">EvaluationResult</a> = typename <a class="el" href="structtfel_1_1math_1_1_result_of_evaluation.html">ResultOfEvaluation</a>&lt; std::decay_t&lt; ObjectType &gt; &gt;::type</td></tr>
<tr class="memdesc:af77fbcb0679a70e562fe1e0f10f5e61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:af77fbcb0679a70e562fe1e0f10f5e61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037360e732078b2d8b6bee5f80a0c819"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a037360e732078b2d8b6bee5f80a0c819"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a> = <a class="el" href="structstd_1_1complex.html">std::complex</a>&lt; ValueType &gt;</td></tr>
<tr class="memdesc:a037360e732078b2d8b6bee5f80a0c819"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias <a class="el" href="structstd_1_1complex.html">std::complex</a>.  <a href="#a037360e732078b2d8b6bee5f80a0c819">More...</a><br /></td></tr>
<tr class="separator:a037360e732078b2d8b6bee5f80a0c819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6813e0e126161b9c9aea3ce2b085eacc"><td class="memItemLeft" align="right" valign="top"><a id="a6813e0e126161b9c9aea3ce2b085eacc"></a>
typedef <a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a>&lt; std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NoUnit</b></td></tr>
<tr class="separator:a6813e0e126161b9c9aea3ce2b085eacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6aaddfab53e1c567c1f210d3031d7f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 0, 0, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0f6aaddfab53e1c567c1f210d3031d7f">Mass</a></td></tr>
<tr class="memdesc:a0f6aaddfab53e1c567c1f210d3031d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Mass unit.  <a href="#a0f6aaddfab53e1c567c1f210d3031d7f">More...</a><br /></td></tr>
<tr class="separator:a0f6aaddfab53e1c567c1f210d3031d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab4cd4dbbabfa81beade7e23a81aa9f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 1, 0, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f">Length</a></td></tr>
<tr class="memdesc:aeab4cd4dbbabfa81beade7e23a81aa9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Length unit.  <a href="#aeab4cd4dbbabfa81beade7e23a81aa9f">More...</a><br /></td></tr>
<tr class="separator:aeab4cd4dbbabfa81beade7e23a81aa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f1c4734361bfe475e361a040a1ece5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 1, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad1f1c4734361bfe475e361a040a1ece5">Time</a></td></tr>
<tr class="memdesc:ad1f1c4734361bfe475e361a040a1ece5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Time unit.  <a href="#ad1f1c4734361bfe475e361a040a1ece5">More...</a><br /></td></tr>
<tr class="separator:ad1f1c4734361bfe475e361a040a1ece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c502ed4a6dd50e17f17022f7327d74e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 1, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4c502ed4a6dd50e17f17022f7327d74e">Ampere</a></td></tr>
<tr class="memdesc:a4c502ed4a6dd50e17f17022f7327d74e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Ampere unit.  <a href="#a4c502ed4a6dd50e17f17022f7327d74e">More...</a><br /></td></tr>
<tr class="separator:a4c502ed4a6dd50e17f17022f7327d74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2a11fc25b0491377347962a2219cf7"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0, 1, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aaf2a11fc25b0491377347962a2219cf7">Temperature</a></td></tr>
<tr class="memdesc:aaf2a11fc25b0491377347962a2219cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Temperature unit.  <a href="#aaf2a11fc25b0491377347962a2219cf7">More...</a><br /></td></tr>
<tr class="separator:aaf2a11fc25b0491377347962a2219cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7684b7496f5c9bd09f2947b5b8d537"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0, 1, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8b7684b7496f5c9bd09f2947b5b8d537">Kelvin</a></td></tr>
<tr class="memdesc:a8b7684b7496f5c9bd09f2947b5b8d537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Kelvin unit.  <a href="#a8b7684b7496f5c9bd09f2947b5b8d537">More...</a><br /></td></tr>
<tr class="separator:a8b7684b7496f5c9bd09f2947b5b8d537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9f10c92636c52b23d750dc1d146992"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0, 0, 1, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6c9f10c92636c52b23d750dc1d146992">Candela</a></td></tr>
<tr class="memdesc:a6c9f10c92636c52b23d750dc1d146992"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Candela unit.  <a href="#a6c9f10c92636c52b23d750dc1d146992">More...</a><br /></td></tr>
<tr class="separator:a6c9f10c92636c52b23d750dc1d146992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22c96cecfa5347958619e2672a9e0e4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0, 0, 0, 1 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af22c96cecfa5347958619e2672a9e0e4">Mole</a></td></tr>
<tr class="memdesc:af22c96cecfa5347958619e2672a9e0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Mole unit.  <a href="#af22c96cecfa5347958619e2672a9e0e4">More...</a><br /></td></tr>
<tr class="separator:af22c96cecfa5347958619e2672a9e0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cafc93655e0e08a3438947be78f1130"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0,-1, 0, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4cafc93655e0e08a3438947be78f1130">InvLength</a></td></tr>
<tr class="memdesc:a4cafc93655e0e08a3438947be78f1130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the InvLength unit.  <a href="#a4cafc93655e0e08a3438947be78f1130">More...</a><br /></td></tr>
<tr class="separator:a4cafc93655e0e08a3438947be78f1130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1838b2eecf37fb347a5efb709afed4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0,-1, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9a1838b2eecf37fb347a5efb709afed4">InvTemperature</a></td></tr>
<tr class="memdesc:a9a1838b2eecf37fb347a5efb709afed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the InvTemperature unit.  <a href="#a9a1838b2eecf37fb347a5efb709afed4">More...</a><br /></td></tr>
<tr class="separator:a9a1838b2eecf37fb347a5efb709afed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec6d506c79e1d01840880bc03a54df4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0,-1, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4ec6d506c79e1d01840880bc03a54df4">Frequency</a></td></tr>
<tr class="memdesc:a4ec6d506c79e1d01840880bc03a54df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Frequency unit.  <a href="#a4ec6d506c79e1d01840880bc03a54df4">More...</a><br /></td></tr>
<tr class="separator:a4ec6d506c79e1d01840880bc03a54df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4c6c3374a01fa6e86eadcf85cb55ed"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 1,-1, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6b4c6c3374a01fa6e86eadcf85cb55ed">Velocity</a></td></tr>
<tr class="memdesc:a6b4c6c3374a01fa6e86eadcf85cb55ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Velocity unit.  <a href="#a6b4c6c3374a01fa6e86eadcf85cb55ed">More...</a><br /></td></tr>
<tr class="separator:a6b4c6c3374a01fa6e86eadcf85cb55ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7809b7b7e3800ebc6fea939690938e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 1,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8e7809b7b7e3800ebc6fea939690938e">Acceleration</a></td></tr>
<tr class="memdesc:a8e7809b7b7e3800ebc6fea939690938e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Acceleration unit.  <a href="#a8e7809b7b7e3800ebc6fea939690938e">More...</a><br /></td></tr>
<tr class="separator:a8e7809b7b7e3800ebc6fea939690938e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dd04d79c3a9114074eda5a6080fbc6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 1,-1, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a95dd04d79c3a9114074eda5a6080fbc6">Momentum</a></td></tr>
<tr class="memdesc:a95dd04d79c3a9114074eda5a6080fbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Momentum unit.  <a href="#a95dd04d79c3a9114074eda5a6080fbc6">More...</a><br /></td></tr>
<tr class="separator:a95dd04d79c3a9114074eda5a6080fbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898eea1d4e2c1327c6234c96102c970e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 1,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a898eea1d4e2c1327c6234c96102c970e">Force</a></td></tr>
<tr class="memdesc:a898eea1d4e2c1327c6234c96102c970e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Momentum unit.  <a href="#a898eea1d4e2c1327c6234c96102c970e">More...</a><br /></td></tr>
<tr class="separator:a898eea1d4e2c1327c6234c96102c970e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5a1bcf7b721fde538e7a19f99bbd36"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 1,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#adc5a1bcf7b721fde538e7a19f99bbd36">Newton</a></td></tr>
<tr class="memdesc:adc5a1bcf7b721fde538e7a19f99bbd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Newton unit.  <a href="#adc5a1bcf7b721fde538e7a19f99bbd36">More...</a><br /></td></tr>
<tr class="separator:adc5a1bcf7b721fde538e7a19f99bbd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5240f42645c61228638106cf2724850a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1,-1,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5240f42645c61228638106cf2724850a">Stress</a></td></tr>
<tr class="memdesc:a5240f42645c61228638106cf2724850a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Stress unit.  <a href="#a5240f42645c61228638106cf2724850a">More...</a><br /></td></tr>
<tr class="separator:a5240f42645c61228638106cf2724850a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5861e18a76bb1552c699bdebe327c2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1,-1,-3, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9e5861e18a76bb1552c699bdebe327c2">StressRate</a></td></tr>
<tr class="memdesc:a9e5861e18a76bb1552c699bdebe327c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the StressRate unit.  <a href="#a9e5861e18a76bb1552c699bdebe327c2">More...</a><br /></td></tr>
<tr class="separator:a9e5861e18a76bb1552c699bdebe327c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0066b6a6803bbb311c229240d6b6263b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1,-1,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0066b6a6803bbb311c229240d6b6263b">Pressure</a></td></tr>
<tr class="memdesc:a0066b6a6803bbb311c229240d6b6263b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Pressure unit.  <a href="#a0066b6a6803bbb311c229240d6b6263b">More...</a><br /></td></tr>
<tr class="separator:a0066b6a6803bbb311c229240d6b6263b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade22387cb208d66abb4cf8cf1bcbd76f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 2,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ade22387cb208d66abb4cf8cf1bcbd76f">Energy</a></td></tr>
<tr class="memdesc:ade22387cb208d66abb4cf8cf1bcbd76f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Energy unit.  <a href="#ade22387cb208d66abb4cf8cf1bcbd76f">More...</a><br /></td></tr>
<tr class="separator:ade22387cb208d66abb4cf8cf1bcbd76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a34e2674b7e7563d24f1550c17f649"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1,-1,-2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a31a34e2674b7e7563d24f1550c17f649">EnergyDensity</a></td></tr>
<tr class="memdesc:a31a34e2674b7e7563d24f1550c17f649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the EnergyDensity unit.  <a href="#a31a34e2674b7e7563d24f1550c17f649">More...</a><br /></td></tr>
<tr class="separator:a31a34e2674b7e7563d24f1550c17f649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aac068b26a121174ac002a67805e86c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1,-3, 0, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7aac068b26a121174ac002a67805e86c">Density</a></td></tr>
<tr class="memdesc:a7aac068b26a121174ac002a67805e86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Density unit.  <a href="#a7aac068b26a121174ac002a67805e86c">More...</a><br /></td></tr>
<tr class="separator:a7aac068b26a121174ac002a67805e86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872d710b54eaa4ccc2deb1f8ea6d8f8a"><td class="memItemLeft" align="right" valign="top"><a id="a872d710b54eaa4ccc2deb1f8ea6d8f8a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a872d710b54eaa4ccc2deb1f8ea6d8f8a">TemperatureGradient</a> = <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0,-1, 0, 0, 1, 0, 0 &gt;::type</td></tr>
<tr class="memdesc:a872d710b54eaa4ccc2deb1f8ea6d8f8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the TemperatureGradient unit. <br /></td></tr>
<tr class="separator:a872d710b54eaa4ccc2deb1f8ea6d8f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2cabf627d474a2bb5b42486ffdadb0"><td class="memItemLeft" align="right" valign="top"><a id="aed2cabf627d474a2bb5b42486ffdadb0"></a>
typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 1,-3, 0,-1, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aed2cabf627d474a2bb5b42486ffdadb0">ThermalConductivity</a></td></tr>
<tr class="memdesc:aed2cabf627d474a2bb5b42486ffdadb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the ThermalConductivity unit. <br /></td></tr>
<tr class="separator:aed2cabf627d474a2bb5b42486ffdadb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d042a7a3b1ad95b9c9495cdb97a773"><td class="memItemLeft" align="right" valign="top"><a id="a31d042a7a3b1ad95b9c9495cdb97a773"></a>
typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 0,-3, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a31d042a7a3b1ad95b9c9495cdb97a773">HeatFluxDensity</a></td></tr>
<tr class="memdesc:a31d042a7a3b1ad95b9c9495cdb97a773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the HeatFluxDensity unit. <br /></td></tr>
<tr class="separator:a31d042a7a3b1ad95b9c9495cdb97a773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373af1865a931dd29d7ff54ed4ea7b86"><td class="memTemplParams" colspan="2"><a id="a373af1865a931dd29d7ff54ed4ea7b86"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a373af1865a931dd29d7ff54ed4ea7b86"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a> = <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3, 3, <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a373af1865a931dd29d7ff54ed4ea7b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a373af1865a931dd29d7ff54ed4ea7b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfec1e3eff04335dcf839b58c1b587fc"><td class="memTemplParams" colspan="2"><a id="acfec1e3eff04335dcf839b58c1b587fc"></a>
template&lt;unsigned short N, typename ValueType  = double&gt; </td></tr>
<tr class="memitem:acfec1e3eff04335dcf839b58c1b587fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fsarray</b> = <a class="el" href="structtfel_1_1math_1_1_generic_fixed_size_array.html">GenericFixedSizeArray</a>&lt; N, <a class="el" href="structtfel_1_1math_1_1_fixed_size_tiny_vector_policy.html">FixedSizeTinyVectorPolicy</a>&lt; N, ValueType &gt; &gt;</td></tr>
<tr class="separator:acfec1e3eff04335dcf839b58c1b587fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a8048fbed09bfa347e783e2e0490d7"><td class="memTemplParams" colspan="2"><a id="a61a8048fbed09bfa347e783e2e0490d7"></a>
template&lt;typename T1 , typename T2 , typename Op &gt; </td></tr>
<tr class="memitem:a61a8048fbed09bfa347e783e2e0490d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a61a8048fbed09bfa347e783e2e0490d7">BinaryOperationResult</a> = typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, Op &gt;::Result</td></tr>
<tr class="memdesc:a61a8048fbed09bfa347e783e2e0490d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias for the result of an binary operation <br /></td></tr>
<tr class="separator:a61a8048fbed09bfa347e783e2e0490d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f47b467a56d1e49b49a3a711178364e"><td class="memTemplParams" colspan="2"><a id="a7f47b467a56d1e49b49a3a711178364e"></a>
template&lt;typename T1 , typename T2 , typename Op &gt; </td></tr>
<tr class="memitem:a7f47b467a56d1e49b49a3a711178364e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a> = std::integral_constant&lt; bool,!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a61a8048fbed09bfa347e783e2e0490d7">BinaryOperationResult</a>&lt; T1, T2, Op &gt; &gt;::cond &gt;</td></tr>
<tr class="memdesc:a7f47b467a56d1e49b49a3a711178364e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a metafunction returning true if the result of the binary operation is valid <br /></td></tr>
<tr class="separator:a7f47b467a56d1e49b49a3a711178364e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6928d0a344b02c1df04bcf982f9b04"><td class="memTemplParams" colspan="2"><a id="a1e6928d0a344b02c1df04bcf982f9b04"></a>
template&lt;typename T1 , typename T2 , typename Op &gt; </td></tr>
<tr class="memitem:a1e6928d0a344b02c1df04bcf982f9b04"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a> = typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, Op &gt;::Handle</td></tr>
<tr class="memdesc:a1e6928d0a344b02c1df04bcf982f9b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias of the handler of an binary operation <br /></td></tr>
<tr class="separator:a1e6928d0a344b02c1df04bcf982f9b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4328a34f29771e471ebff5eb98cb2e"><td class="memTemplParams" colspan="2"><a id="aea4328a34f29771e471ebff5eb98cb2e"></a>
template&lt;typename T1 , typename Op &gt; </td></tr>
<tr class="memitem:aea4328a34f29771e471ebff5eb98cb2e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aea4328a34f29771e471ebff5eb98cb2e">UnaryOperationResult</a> = typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T1, Op &gt;::Result</td></tr>
<tr class="memdesc:aea4328a34f29771e471ebff5eb98cb2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias for the result of an unary operation <br /></td></tr>
<tr class="separator:aea4328a34f29771e471ebff5eb98cb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300520fa6148e3df294b597830d63e9b"><td class="memTemplParams" colspan="2"><a id="a300520fa6148e3df294b597830d63e9b"></a>
template&lt;typename T1 , typename Op &gt; </td></tr>
<tr class="memitem:a300520fa6148e3df294b597830d63e9b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a300520fa6148e3df294b597830d63e9b">UnaryOperationHandler</a> = typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T1, Op &gt;::Handle</td></tr>
<tr class="memdesc:a300520fa6148e3df294b597830d63e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias of the handler of an unary operation <br /></td></tr>
<tr class="separator:a300520fa6148e3df294b597830d63e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2abca9d653c8ef4f1f2cfaf31eccaa"><td class="memTemplParams" colspan="2"><a id="a8c2abca9d653c8ef4f1f2cfaf31eccaa"></a>
template&lt;typename T1 , typename Op &gt; </td></tr>
<tr class="memitem:a8c2abca9d653c8ef4f1f2cfaf31eccaa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8c2abca9d653c8ef4f1f2cfaf31eccaa">isUnaryOperationResultTypeValid</a> = std::integral_constant&lt; bool,!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aea4328a34f29771e471ebff5eb98cb2e">UnaryOperationResult</a>&lt; T1, Op &gt; &gt;::cond &gt;</td></tr>
<tr class="memdesc:a8c2abca9d653c8ef4f1f2cfaf31eccaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias <br /></td></tr>
<tr class="separator:a8c2abca9d653c8ef4f1f2cfaf31eccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3d4a3b4ac585643b3857d88ce02755"><td class="memTemplParams" colspan="2"><a id="a3f3d4a3b4ac585643b3857d88ce02755"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3f3d4a3b4ac585643b3857d88ce02755"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3f3d4a3b4ac585643b3857d88ce02755">derivative_type</a> = typename <a class="el" href="structtfel_1_1math_1_1_derivative_type.html">DerivativeType</a>&lt; T1, T2 &gt;::type</td></tr>
<tr class="memdesc:a3f3d4a3b4ac585643b3857d88ce02755"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a3f3d4a3b4ac585643b3857d88ce02755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89ae24543be8292214ca296a43fbc19"><td class="memTemplParams" colspan="2"><a id="aa89ae24543be8292214ca296a43fbc19"></a>
template&lt;typename MathObjectType &gt; </td></tr>
<tr class="memitem:aa89ae24543be8292214ca296a43fbc19"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a> = typename <a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a>&lt; std::decay_t&lt; MathObjectType &gt; &gt;::NumType</td></tr>
<tr class="memdesc:aa89ae24543be8292214ca296a43fbc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:aa89ae24543be8292214ca296a43fbc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af164777e769ebd2c2df45123479f2f15"><td class="memTemplParams" colspan="2"><a id="af164777e769ebd2c2df45123479f2f15"></a>
template&lt;typename MathObjectType &gt; </td></tr>
<tr class="memitem:af164777e769ebd2c2df45123479f2f15"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af164777e769ebd2c2df45123479f2f15">index_type</a> = typename <a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a>&lt; std::decay_t&lt; MathObjectType &gt; &gt;::IndexType</td></tr>
<tr class="memdesc:af164777e769ebd2c2df45123479f2f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:af164777e769ebd2c2df45123479f2f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee110500aba43bd0fc73c7a5ecd510e9"><td class="memTemplParams" colspan="2"><a id="aee110500aba43bd0fc73c7a5ecd510e9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee110500aba43bd0fc73c7a5ecd510e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a> = std::conditional_t&lt; tfel::typetraits::isScalar&lt; T &gt;(), <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; T &gt;, <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:aee110500aba43bd0fc73c7a5ecd510e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:aee110500aba43bd0fc73c7a5ecd510e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148d63c9fac3faf5a99af96ffdb36664"><td class="memTemplParams" colspan="2"><a id="a148d63c9fac3faf5a99af96ffdb36664"></a>
template&lt;typename A , typename B , typename Op &gt; </td></tr>
<tr class="memitem:a148d63c9fac3faf5a99af96ffdb36664"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a148d63c9fac3faf5a99af96ffdb36664">result_type</a> = typename <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>&lt; A, B, Op &gt;::type</td></tr>
<tr class="memdesc:a148d63c9fac3faf5a99af96ffdb36664"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a148d63c9fac3faf5a99af96ffdb36664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b3f6aab9c8a6a2c2517e264a24a2c3"><td class="memTemplParams" colspan="2"><a id="a54b3f6aab9c8a6a2c2517e264a24a2c3"></a>
template&lt;unsigned short N, unsigned short M, typename T  = double&gt; </td></tr>
<tr class="memitem:a54b3f6aab9c8a6a2c2517e264a24a2c3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstTMatrixView</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt;, <a class="el" href="structtfel_1_1math_1_1_const_t_matrix_view_expr.html">ConstTMatrixViewExpr</a>&lt; N, M, T &gt; &gt;</td></tr>
<tr class="separator:a54b3f6aab9c8a6a2c2517e264a24a2c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae984f507183e4f9731286546ea3ce022"><td class="memTemplParams" colspan="2"><a id="ae984f507183e4f9731286546ea3ce022"></a>
template&lt;unsigned short N, unsigned short M, typename T  = double&gt; </td></tr>
<tr class="memitem:ae984f507183e4f9731286546ea3ce022"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TMatrixView</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt;, <a class="el" href="structtfel_1_1math_1_1_t_matrix_view_expr.html">TMatrixViewExpr</a>&lt; N, M, T &gt; &gt;</td></tr>
<tr class="separator:ae984f507183e4f9731286546ea3ce022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9fe942a2790b56c3082717ed99ef2b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a0f6aaddfab53e1c567c1f210d3031d7f">Mass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1b9fe942a2790b56c3082717ed99ef2b">mass</a></td></tr>
<tr class="memdesc:a1b9fe942a2790b56c3082717ed99ef2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a mass.  <a href="#a1b9fe942a2790b56c3082717ed99ef2b">More...</a><br /></td></tr>
<tr class="separator:a1b9fe942a2790b56c3082717ed99ef2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06d97ccd2592515a92ba2a4eb662bb4b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f">Length</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a06d97ccd2592515a92ba2a4eb662bb4b">length</a></td></tr>
<tr class="memdesc:a06d97ccd2592515a92ba2a4eb662bb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a length.  <a href="#a06d97ccd2592515a92ba2a4eb662bb4b">More...</a><br /></td></tr>
<tr class="separator:a06d97ccd2592515a92ba2a4eb662bb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780717c8aea48d1f920aabd64af09270"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f">Length</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a780717c8aea48d1f920aabd64af09270">invlength</a></td></tr>
<tr class="memdesc:a780717c8aea48d1f920aabd64af09270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a invlength.  <a href="#a780717c8aea48d1f920aabd64af09270">More...</a><br /></td></tr>
<tr class="separator:a780717c8aea48d1f920aabd64af09270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3215b75eb5815603d8919a02502241da"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#ad1f1c4734361bfe475e361a040a1ece5">Time</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3215b75eb5815603d8919a02502241da">time</a></td></tr>
<tr class="memdesc:a3215b75eb5815603d8919a02502241da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a time.  <a href="#a3215b75eb5815603d8919a02502241da">More...</a><br /></td></tr>
<tr class="separator:a3215b75eb5815603d8919a02502241da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca7dcdc304bb2813a61e03b923ad68a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a4c502ed4a6dd50e17f17022f7327d74e">Ampere</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#afca7dcdc304bb2813a61e03b923ad68a">ampere</a></td></tr>
<tr class="memdesc:afca7dcdc304bb2813a61e03b923ad68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an ampere.  <a href="#afca7dcdc304bb2813a61e03b923ad68a">More...</a><br /></td></tr>
<tr class="separator:afca7dcdc304bb2813a61e03b923ad68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad522fc0823cac19370b9ade552cc679f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aaf2a11fc25b0491377347962a2219cf7">Temperature</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad522fc0823cac19370b9ade552cc679f">temperature</a></td></tr>
<tr class="memdesc:ad522fc0823cac19370b9ade552cc679f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a temperature.  <a href="#ad522fc0823cac19370b9ade552cc679f">More...</a><br /></td></tr>
<tr class="separator:ad522fc0823cac19370b9ade552cc679f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed3cb42e97e262d9a0aedcd40bf0aca"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a6c9f10c92636c52b23d750dc1d146992">Candela</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3ed3cb42e97e262d9a0aedcd40bf0aca">candela</a></td></tr>
<tr class="memdesc:a3ed3cb42e97e262d9a0aedcd40bf0aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a candela.  <a href="#a3ed3cb42e97e262d9a0aedcd40bf0aca">More...</a><br /></td></tr>
<tr class="separator:a3ed3cb42e97e262d9a0aedcd40bf0aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60efadb57e60e9757e189196f3667e68"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#af22c96cecfa5347958619e2672a9e0e4">Mole</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a60efadb57e60e9757e189196f3667e68">mole</a></td></tr>
<tr class="memdesc:a60efadb57e60e9757e189196f3667e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a mole.  <a href="#a60efadb57e60e9757e189196f3667e68">More...</a><br /></td></tr>
<tr class="separator:a60efadb57e60e9757e189196f3667e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a10ed49c61273a39121565bb011e11"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a6b4c6c3374a01fa6e86eadcf85cb55ed">Velocity</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a30a10ed49c61273a39121565bb011e11">velocity</a></td></tr>
<tr class="memdesc:a30a10ed49c61273a39121565bb011e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a velocity.  <a href="#a30a10ed49c61273a39121565bb011e11">More...</a><br /></td></tr>
<tr class="separator:a30a10ed49c61273a39121565bb011e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ea413b09d061d87404c592457b8214"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a8e7809b7b7e3800ebc6fea939690938e">Acceleration</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab0ea413b09d061d87404c592457b8214">acceleration</a></td></tr>
<tr class="memdesc:ab0ea413b09d061d87404c592457b8214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines an acceleration.  <a href="#ab0ea413b09d061d87404c592457b8214">More...</a><br /></td></tr>
<tr class="separator:ab0ea413b09d061d87404c592457b8214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff986de4d5db9845fdb1ed04f5ba6f2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a95dd04d79c3a9114074eda5a6080fbc6">Momentum</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8ff986de4d5db9845fdb1ed04f5ba6f2">momentum</a></td></tr>
<tr class="memdesc:a8ff986de4d5db9845fdb1ed04f5ba6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a momentum.  <a href="#a8ff986de4d5db9845fdb1ed04f5ba6f2">More...</a><br /></td></tr>
<tr class="separator:a8ff986de4d5db9845fdb1ed04f5ba6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4753cbd852f9c874ade45013232ba78"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a898eea1d4e2c1327c6234c96102c970e">Force</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae4753cbd852f9c874ade45013232ba78">force</a></td></tr>
<tr class="memdesc:ae4753cbd852f9c874ade45013232ba78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a force.  <a href="#ae4753cbd852f9c874ade45013232ba78">More...</a><br /></td></tr>
<tr class="separator:ae4753cbd852f9c874ade45013232ba78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa3ef0a795c7d9e8f53f364dc4359f3"><td class="memTemplParams" colspan="2"><a id="affa3ef0a795c7d9e8f53f364dc4359f3"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:affa3ef0a795c7d9e8f53f364dc4359f3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstST2toST2View</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_const_s_t2to_s_t2_view_expr.html">ConstST2toST2ViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:affa3ef0a795c7d9e8f53f364dc4359f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8481031447a9bda2d0ff588d942ef9"><td class="memTemplParams" colspan="2"><a id="a1c8481031447a9bda2d0ff588d942ef9"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:a1c8481031447a9bda2d0ff588d942ef9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ST2toST2View</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_view_expr.html">ST2toST2ViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:a1c8481031447a9bda2d0ff588d942ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba57a5ba0de20411aac13fba18f5e7a3"><td class="memTemplParams" colspan="2"><a id="aba57a5ba0de20411aac13fba18f5e7a3"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:aba57a5ba0de20411aac13fba18f5e7a3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ST2toT2View</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_view_expr.html">ST2toT2ViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:aba57a5ba0de20411aac13fba18f5e7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335238c9f61a882f67a4b69661b8c025"><td class="memTemplParams" colspan="2"><a id="a335238c9f61a882f67a4b69661b8c025"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:a335238c9f61a882f67a4b69661b8c025"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstStensorView</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_const_stensor_view_expr.html">ConstStensorViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:a335238c9f61a882f67a4b69661b8c025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af840e4c53c9de25f811e9ee3c084402c"><td class="memTemplParams" colspan="2"><a id="af840e4c53c9de25f811e9ee3c084402c"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:af840e4c53c9de25f811e9ee3c084402c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StensorView</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_stensor_view_expr.html">StensorViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:af840e4c53c9de25f811e9ee3c084402c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab559c6133a4bef111790e3751251b320"><td class="memTemplParams" colspan="2"><a id="ab559c6133a4bef111790e3751251b320"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:ab559c6133a4bef111790e3751251b320"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstT2toST2View</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_const_t2to_s_t2_view_expr.html">ConstT2toST2ViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:ab559c6133a4bef111790e3751251b320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeff51397c5b64638a61cf9b5b39a751"><td class="memTemplParams" colspan="2"><a id="aaeff51397c5b64638a61cf9b5b39a751"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:aaeff51397c5b64638a61cf9b5b39a751"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>T2toST2View</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_view_expr.html">T2toST2ViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:aaeff51397c5b64638a61cf9b5b39a751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d9bc7fcabd954d957dee72bff2dd7d"><td class="memTemplParams" colspan="2"><a id="aa2d9bc7fcabd954d957dee72bff2dd7d"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:aa2d9bc7fcabd954d957dee72bff2dd7d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>T2toT2View</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_t2to_t2_view_expr.html">T2toT2ViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:aa2d9bc7fcabd954d957dee72bff2dd7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab335d987e451eb5229d860c3dafa7b28"><td class="memTemplParams" colspan="2"><a id="ab335d987e451eb5229d860c3dafa7b28"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:ab335d987e451eb5229d860c3dafa7b28"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TensorView</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tensor_view_expr.html">TensorViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:ab335d987e451eb5229d860c3dafa7b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c1e6c7509cd93c35116d7e40b2091c"><td class="memTemplParams" colspan="2"><a id="aa9c1e6c7509cd93c35116d7e40b2091c"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:aa9c1e6c7509cd93c35116d7e40b2091c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstTVectorView</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_const_t_vector_view_expr.html">ConstTVectorViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:aa9c1e6c7509cd93c35116d7e40b2091c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b62c748ec9395d50814bbcd837ffcf"><td class="memTemplParams" colspan="2"><a id="a83b62c748ec9395d50814bbcd837ffcf"></a>
template&lt;unsigned short N, typename T  = double&gt; </td></tr>
<tr class="memitem:a83b62c748ec9395d50814bbcd837ffcf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TVectorView</b> = <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_t_vector_view_expr.html">TVectorViewExpr</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="separator:a83b62c748ec9395d50814bbcd837ffcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2b759ee7f33caa991286726bb496361a"><td class="memTemplParams" colspan="2">template&lt;typename NumericType , typename IndexType &gt; </td></tr>
<tr class="memitem:a2b759ee7f33caa991286726bb496361a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2b759ee7f33caa991286726bb496361a">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_aitken_acceleration_algorithm.html">AitkenAccelerationAlgorithm</a>&lt; NumericType, IndexType &gt; &amp;)</td></tr>
<tr class="memdesc:a2b759ee7f33caa991286726bb496361a"><td class="mdescLeft">&#160;</td><td class="mdescRight">output stream operator  <a href="#a2b759ee7f33caa991286726bb496361a">More...</a><br /></td></tr>
<tr class="separator:a2b759ee7f33caa991286726bb496361a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f3980e1f02e7bf0310aa5055381e21"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy , typename... Indices&gt; </td></tr>
<tr class="memitem:a36f3980e1f02e7bf0310aa5055381e21"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a36f3980e1f02e7bf0310aa5055381e21">checkIndicesValiditity</a> () noexcept</td></tr>
<tr class="memdesc:a36f3980e1f02e7bf0310aa5055381e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple function to check that the type of the indices are compatible with the given indexing policy  <a href="#a36f3980e1f02e7bf0310aa5055381e21">More...</a><br /></td></tr>
<tr class="separator:a36f3980e1f02e7bf0310aa5055381e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331c0a1318f53ec008ca94d6576d179a"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </td></tr>
<tr class="memitem:a331c0a1318f53ec008ca94d6576d179a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a331c0a1318f53ec008ca94d6576d179a">checkIndexingPoliciesCompatiblity</a> ()</td></tr>
<tr class="memdesc:a331c0a1318f53ec008ca94d6576d179a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two indexing policies can be compatible.  <a href="#a331c0a1318f53ec008ca94d6576d179a">More...</a><br /></td></tr>
<tr class="separator:a331c0a1318f53ec008ca94d6576d179a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6978e9e809a086d009ee40a12b87d169"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </td></tr>
<tr class="memitem:a6978e9e809a086d009ee40a12b87d169"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6978e9e809a086d009ee40a12b87d169">haveIndexingPoliciesTheSameMemoryLayout</a> ()</td></tr>
<tr class="separator:a6978e9e809a086d009ee40a12b87d169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8df1977dfb39b746fe9f020b3e6df49"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </td></tr>
<tr class="memitem:ad8df1977dfb39b746fe9f020b3e6df49"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad8df1977dfb39b746fe9f020b3e6df49">areIndexingPoliciesCompatibleAtRunTime</a> (const IndexingPolicy1 &amp;, const IndexingPolicy2 &amp;)</td></tr>
<tr class="separator:ad8df1977dfb39b746fe9f020b3e6df49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80897c96d06d4e3ddf5ff306dd6ea018"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </td></tr>
<tr class="memitem:a80897c96d06d4e3ddf5ff306dd6ea018"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a80897c96d06d4e3ddf5ff306dd6ea018">checkIndexingPoliciesRuntimeCompatiblity</a> (const IndexingPolicy1 &amp;, const IndexingPolicy2 &amp;)</td></tr>
<tr class="memdesc:a80897c96d06d4e3ddf5ff306dd6ea018"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two indexing policies are compatible at runtime.  <a href="#a80897c96d06d4e3ddf5ff306dd6ea018">More...</a><br /></td></tr>
<tr class="separator:a80897c96d06d4e3ddf5ff306dd6ea018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7fb3567fafbad7fe47b36287448455e"><td class="memTemplParams" colspan="2"><a id="ac7fb3567fafbad7fe47b36287448455e"></a>
template&lt;typename UnaryOperator , typename FirstArgument &gt; </td></tr>
<tr class="memitem:ac7fb3567fafbad7fe47b36287448455e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtfel_1_1math_1_1_multi_indices_unary_operator_functor.html">MultiIndicesUnaryOperatorFunctor</a>&lt; UnaryOperator, FirstArgument &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeMultiIndicesUnaryOperatorFunctor</b> (FirstArgument &amp;a)</td></tr>
<tr class="separator:ac7fb3567fafbad7fe47b36287448455e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdb4d97dec73be49b1ae6970fba567a"><td class="memTemplParams" colspan="2"><a id="abbdb4d97dec73be49b1ae6970fba567a"></a>
template&lt;typename UnaryOperator , typename FirstArgument &gt; </td></tr>
<tr class="memitem:abbdb4d97dec73be49b1ae6970fba567a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtfel_1_1math_1_1_multi_indices_unary_operator_functor.html">MultiIndicesUnaryOperatorFunctor</a>&lt; UnaryOperator, FirstArgument &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeMultiIndicesUnaryOperatorFunctor</b> (const UnaryOperator &amp;o, FirstArgument &amp;a)</td></tr>
<tr class="separator:abbdb4d97dec73be49b1ae6970fba567a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35478774ffc7e32af0c09a8971fc88ad"><td class="memTemplParams" colspan="2"><a id="a35478774ffc7e32af0c09a8971fc88ad"></a>
template&lt;typename BinaryOperator , typename FirstArgument , typename SecondArgument &gt; </td></tr>
<tr class="memitem:a35478774ffc7e32af0c09a8971fc88ad"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtfel_1_1math_1_1_multi_indices_binary_operator_functor.html">MultiIndicesBinaryOperatorFunctor</a>&lt; BinaryOperator, FirstArgument, SecondArgument &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeMultiIndicesBinaryOperatorFunctor</b> (FirstArgument &amp;a, SecondArgument &amp;b)</td></tr>
<tr class="separator:a35478774ffc7e32af0c09a8971fc88ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd4d31398ff30cdb34a0d2c4a802606"><td class="memTemplParams" colspan="2"><a id="a4dd4d31398ff30cdb34a0d2c4a802606"></a>
template&lt;typename BinaryOperator , typename FirstArgument , typename SecondArgument &gt; </td></tr>
<tr class="memitem:a4dd4d31398ff30cdb34a0d2c4a802606"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structtfel_1_1math_1_1_multi_indices_binary_operator_functor.html">MultiIndicesBinaryOperatorFunctor</a>&lt; BinaryOperator, FirstArgument, SecondArgument &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeMultiIndicesBinaryOperatorFunctor</b> (const BinaryOperator &amp;o, FirstArgument &amp;a, SecondArgument &amp;b)</td></tr>
<tr class="separator:a4dd4d31398ff30cdb34a0d2c4a802606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25be866f4fe5021c58672780177c7825"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </td></tr>
<tr class="memitem:a25be866f4fe5021c58672780177c7825"><td class="memTemplItemLeft" align="right" valign="top">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a25be866f4fe5021c58672780177c7825">broyden</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, T &gt; &amp;, const T, const unsigned short)</td></tr>
<tr class="separator:a25be866f4fe5021c58672780177c7825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8437c41fb14f7fbda25b1f07c9dcbf94"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </td></tr>
<tr class="memitem:a8437c41fb14f7fbda25b1f07c9dcbf94"><td class="memTemplItemLeft" align="right" valign="top">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8437c41fb14f7fbda25b1f07c9dcbf94">broyden</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, const T, const unsigned short)</td></tr>
<tr class="separator:a8437c41fb14f7fbda25b1f07c9dcbf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d43a352f91a795ab4c35cc9cdb69d44"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </td></tr>
<tr class="memitem:a7d43a352f91a795ab4c35cc9cdb69d44"><td class="memTemplItemLeft" align="right" valign="top">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7d43a352f91a795ab4c35cc9cdb69d44">broyden2</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, T &gt; &amp;, const T, const unsigned short)</td></tr>
<tr class="separator:a7d43a352f91a795ab4c35cc9cdb69d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12b80ec6e7aad8e4d37e970ecdc0a9d"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </td></tr>
<tr class="memitem:ab12b80ec6e7aad8e4d37e970ecdc0a9d"><td class="memTemplItemLeft" align="right" valign="top">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab12b80ec6e7aad8e4d37e970ecdc0a9d">broyden2</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, const T, const unsigned short)</td></tr>
<tr class="separator:ab12b80ec6e7aad8e4d37e970ecdc0a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add78759d62a38f9554085c8ecf781d4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add78759d62a38f9554085c8ecf781d4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#add78759d62a38f9554085c8ecf781d4d">geometricDiscretization</a> (T &amp;v, const typename T::value_type, const typename T::value_type, const typename T::value_type, const typename T::value_type, const typename T::size_type)</td></tr>
<tr class="memdesc:add78759d62a38f9554085c8ecf781d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">discretize a segment into a fixed number of elements trying to satisfy as much as possible given discretization densities at the beginning and the end of the segment. Elements size grows according to a geometric progression.  <a href="#add78759d62a38f9554085c8ecf781d4d">More...</a><br /></td></tr>
<tr class="separator:add78759d62a38f9554085c8ecf781d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce654ea4324ea12243df2df8283582e"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename Operation &gt; </td></tr>
<tr class="memitem:a5ce654ea4324ea12243df2df8283582e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5ce654ea4324ea12243df2df8283582e">eval</a> (const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>, Operation &gt; &amp;e)</td></tr>
<tr class="memdesc:a5ce654ea4324ea12243df2df8283582e"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate an expression  <a href="#a5ce654ea4324ea12243df2df8283582e">More...</a><br /></td></tr>
<tr class="separator:a5ce654ea4324ea12243df2df8283582e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300173c899a17288ed49569f89a2f35a"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:a300173c899a17288ed49569f89a2f35a"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a300173c899a17288ed49569f89a2f35a">operator-</a> (T1 &amp;&amp;a) -&gt; std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a8c2abca9d653c8ef4f1f2cfaf31eccaa">isUnaryOperationResultTypeValid</a>&lt; decltype(a), <a class="el" href="structtfel_1_1math_1_1_op_neg.html">OpNeg</a> &gt;::value, <a class="el" href="namespacetfel_1_1math.html#a300520fa6148e3df294b597830d63e9b">UnaryOperationHandler</a>&lt; decltype(a), <a class="el" href="structtfel_1_1math_1_1_op_neg.html">OpNeg</a> &gt;&gt;</td></tr>
<tr class="memdesc:a300173c899a17288ed49569f89a2f35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">negate a mathematical object  <a href="#a300173c899a17288ed49569f89a2f35a">More...</a><br /></td></tr>
<tr class="separator:a300173c899a17288ed49569f89a2f35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9768b53386714e990d318ef601ed007a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a9768b53386714e990d318ef601ed007a"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9768b53386714e990d318ef601ed007a">operator+</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) -&gt; std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::value &amp;&amp;(!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; std::decay_t&lt; T1 &gt;&gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; std::decay_t&lt; T2 &gt;&gt;::cond))), <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;&gt;</td></tr>
<tr class="memdesc:a9768b53386714e990d318ef601ed007a"><td class="mdescLeft">&#160;</td><td class="mdescRight">add to mathematical object  <a href="#a9768b53386714e990d318ef601ed007a">More...</a><br /></td></tr>
<tr class="separator:a9768b53386714e990d318ef601ed007a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeaf610ff7113226347634268bcd0bed"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:abeaf610ff7113226347634268bcd0bed"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#abeaf610ff7113226347634268bcd0bed">operator-</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) -&gt; std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_minus.html">OpMinus</a> &gt;::value &amp;&amp;(!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; std::decay_t&lt; T1 &gt;&gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; std::decay_t&lt; T2 &gt;&gt;::cond))), <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_minus.html">OpMinus</a> &gt;&gt;</td></tr>
<tr class="memdesc:abeaf610ff7113226347634268bcd0bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">substract to mathematical object  <a href="#abeaf610ff7113226347634268bcd0bed">More...</a><br /></td></tr>
<tr class="separator:abeaf610ff7113226347634268bcd0bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18e7a16497abdb0408f6a78ec1eb5fe"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ae18e7a16497abdb0408f6a78ec1eb5fe"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae18e7a16497abdb0408f6a78ec1eb5fe">operator*</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) -&gt; std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::value &amp;&amp;(!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; std::decay_t&lt; T1 &gt;&gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; std::decay_t&lt; T2 &gt;&gt;::cond))), <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;&gt;</td></tr>
<tr class="memdesc:ae18e7a16497abdb0408f6a78ec1eb5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply to mathematical object  <a href="#ae18e7a16497abdb0408f6a78ec1eb5fe">More...</a><br /></td></tr>
<tr class="separator:ae18e7a16497abdb0408f6a78ec1eb5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d751ad016e9a92453975678b7edf2ce"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a2d751ad016e9a92453975678b7edf2ce"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2d751ad016e9a92453975678b7edf2ce">operator/</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) -&gt; std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;::value &amp;&amp;(!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; std::decay_t&lt; T1 &gt;&gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; std::decay_t&lt; T2 &gt;&gt;::cond))), <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;&gt;</td></tr>
<tr class="memdesc:a2d751ad016e9a92453975678b7edf2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">divide a mathematical object by another  <a href="#a2d751ad016e9a92453975678b7edf2ce">More...</a><br /></td></tr>
<tr class="separator:a2d751ad016e9a92453975678b7edf2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eea710246d89ef2318640956a6bd089"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3eea710246d89ef2318640956a6bd089"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3eea710246d89ef2318640956a6bd089">operator^</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) -&gt; std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_diadic_product.html">OpDiadicProduct</a> &gt;::value &amp;&amp;(!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; std::decay_t&lt; T1 &gt;&gt;::cond) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; std::decay_t&lt; T2 &gt;&gt;::cond))), <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_diadic_product.html">OpDiadicProduct</a> &gt;&gt;</td></tr>
<tr class="memdesc:a3eea710246d89ef2318640956a6bd089"><td class="mdescLeft">&#160;</td><td class="mdescRight">diadic product between two mathematical objects  <a href="#a3eea710246d89ef2318640956a6bd089">More...</a><br /></td></tr>
<tr class="separator:a3eea710246d89ef2318640956a6bd089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39472ec66a29e42a7851d566a5304f2"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:ae39472ec66a29e42a7851d566a5304f2"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae39472ec66a29e42a7851d566a5304f2">regularisedFischerBurmeisterFunction</a> (const real &amp;, const real &amp;, const real &amp;=real{})</td></tr>
<tr class="memdesc:ae39472ec66a29e42a7851d566a5304f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a regularised version of the Fischer-Burmeister function defined by: [ f(x,y)=x+y-{x^{2}+y^{2}+^{2}} ] This function is such that: [ f(x,y)=0  x 0, y 0 and {2\,x\,y}=^{2} ]  <a href="#ae39472ec66a29e42a7851d566a5304f2">More...</a><br /></td></tr>
<tr class="separator:ae39472ec66a29e42a7851d566a5304f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b44a8d886f9e1a6748429141a4bb99"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:ae6b44a8d886f9e1a6748429141a4bb99"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::tuple&lt; real, real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae6b44a8d886f9e1a6748429141a4bb99">regularisedFischerBurmeisterFunctionFirstDerivatives</a> (const real &amp;, const real &amp;, const real &amp;)</td></tr>
<tr class="separator:ae6b44a8d886f9e1a6748429141a4bb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6373c72a52fe938120ffcfb6a6952789"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:a6373c72a52fe938120ffcfb6a6952789"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6373c72a52fe938120ffcfb6a6952789">squaredFischerBurmeisterFunction</a> (const real &amp;, const real &amp;)</td></tr>
<tr class="separator:a6373c72a52fe938120ffcfb6a6952789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae946a12af0950352569b2d4961fac39f"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:ae946a12af0950352569b2d4961fac39f"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::tuple&lt; real, real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae946a12af0950352569b2d4961fac39f">squaredFischerBurmeisterFunctionFirstDerivatives</a> (const real &amp;, const real &amp;)</td></tr>
<tr class="separator:ae946a12af0950352569b2d4961fac39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af944b60fb53c166c7f8f18f25fc2f702"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:af944b60fb53c166c7f8f18f25fc2f702"><td class="memTemplItemLeft" align="right" valign="top">real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af944b60fb53c166c7f8f18f25fc2f702">regularisedFischerBurmeisterFunction</a> (const real &amp;x, const real &amp;y, const real &amp;e)</td></tr>
<tr class="memdesc:af944b60fb53c166c7f8f18f25fc2f702"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a regularised version of the Fischer-Burmeister function defined by: [ f(x,y)=x+y-{x^{2}+y^{2}+^{2}} ] This function is such that: [ f(x,y)=0  x 0, y 0 and {2\,x\,y}=^{2} ]  <a href="#af944b60fb53c166c7f8f18f25fc2f702">More...</a><br /></td></tr>
<tr class="separator:af944b60fb53c166c7f8f18f25fc2f702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeb7dd9cc4a53a955127f9b48dfe6ea"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:a1eeb7dd9cc4a53a955127f9b48dfe6ea"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; real, real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1eeb7dd9cc4a53a955127f9b48dfe6ea">regularisedFischerBurmeisterFunctionFirstDerivatives</a> (const real &amp;x, const real &amp;y, const real &amp;e)</td></tr>
<tr class="separator:a1eeb7dd9cc4a53a955127f9b48dfe6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28368afe179eb2a167faa54d1b75af3"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:af28368afe179eb2a167faa54d1b75af3"><td class="memTemplItemLeft" align="right" valign="top">real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af28368afe179eb2a167faa54d1b75af3">squaredFischerBurmeisterFunction</a> (const real &amp;x, const real &amp;y)</td></tr>
<tr class="separator:af28368afe179eb2a167faa54d1b75af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7650a0a577ea13922c56515f287436"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:abd7650a0a577ea13922c56515f287436"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; real, real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#abd7650a0a577ea13922c56515f287436">squaredFischerBurmeisterFunctionFirstDerivatives</a> (const real &amp;x, const real &amp;y)</td></tr>
<tr class="separator:abd7650a0a577ea13922c56515f287436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fa041a1b59944e1fc1aa376f622f20"><td class="memTemplParams" colspan="2"><a id="aa7fa041a1b59944e1fc1aa376f622f20"></a>
template&lt;typename Scal &gt; </td></tr>
<tr class="memitem:aa7fa041a1b59944e1fc1aa376f622f20"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; Scal &gt;::cond, Scal &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const Scal &amp;s)</td></tr>
<tr class="separator:aa7fa041a1b59944e1fc1aa376f622f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b49caed2961b29ad24053371d10955d"><td class="memTemplParams" colspan="2"><a id="a2b49caed2961b29ad24053371d10955d"></a>
template&lt;typename Scal &gt; </td></tr>
<tr class="memitem:a2b49caed2961b29ad24053371d10955d"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; Scal &gt;::cond, Scal &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; Scal &gt; &amp;s)</td></tr>
<tr class="separator:a2b49caed2961b29ad24053371d10955d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1175eb70389bf783a3746fc1eb6c60cd"><td class="memTemplParams" colspan="2"><a id="a1175eb70389bf783a3746fc1eb6c60cd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1175eb70389bf783a3746fc1eb6c60cd"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>base_cast</b> (const T x)</td></tr>
<tr class="separator:a1175eb70389bf783a3746fc1eb6c60cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d8d00f3c2df89819ffe42973ee864c"><td class="memTemplParams" colspan="2"><a id="ac5d8d00f3c2df89819ffe42973ee864c"></a>
template&lt;typename T , typename Unit &gt; </td></tr>
<tr class="memitem:ac5d8d00f3c2df89819ffe42973ee864c"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>base_cast</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a> &gt; x)</td></tr>
<tr class="separator:ac5d8d00f3c2df89819ffe42973ee864c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7611707abbdd715c78815912484c38"><td class="memItemLeft" align="right" valign="top"><a id="abe7611707abbdd715c78815912484c38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (unsigned short)</td></tr>
<tr class="separator:abe7611707abbdd715c78815912484c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394811bedb7775124ba51ce3ebc20fd6"><td class="memItemLeft" align="right" valign="top"><a id="a394811bedb7775124ba51ce3ebc20fd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (long unsigned int)</td></tr>
<tr class="separator:a394811bedb7775124ba51ce3ebc20fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cd6a2d2e58760ec69122cba1bd94b6"><td class="memItemLeft" align="right" valign="top"><a id="a21cd6a2d2e58760ec69122cba1bd94b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (short)</td></tr>
<tr class="separator:a21cd6a2d2e58760ec69122cba1bd94b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89bcd53a3d2bdd03772cc418ab4085d"><td class="memItemLeft" align="right" valign="top"><a id="af89bcd53a3d2bdd03772cc418ab4085d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (int)</td></tr>
<tr class="separator:af89bcd53a3d2bdd03772cc418ab4085d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f143dd8083c2602578e835a85679924"><td class="memItemLeft" align="right" valign="top"><a id="a6f143dd8083c2602578e835a85679924"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (long int)</td></tr>
<tr class="separator:a6f143dd8083c2602578e835a85679924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7057a83a6f3ffa962b32cd4dfa4d6f93"><td class="memItemLeft" align="right" valign="top"><a id="a7057a83a6f3ffa962b32cd4dfa4d6f93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (float)</td></tr>
<tr class="separator:a7057a83a6f3ffa962b32cd4dfa4d6f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdad99801c6e370eff256ca98f69d0d"><td class="memItemLeft" align="right" valign="top"><a id="abfdad99801c6e370eff256ca98f69d0d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (double)</td></tr>
<tr class="separator:abfdad99801c6e370eff256ca98f69d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c0c344016c53feb03d5ca852e14893"><td class="memTemplParams" colspan="2"><a id="a62c0c344016c53feb03d5ca852e14893"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62c0c344016c53feb03d5ca852e14893"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond &amp;&amp;(!<a class="el" href="structtfel_1_1typetraits_1_1_is_complex.html">tfel::typetraits::IsComplex</a>&lt; T &gt;::cond), T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (const T src)</td></tr>
<tr class="separator:a62c0c344016c53feb03d5ca852e14893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab346b974f6bf28df0a7abd128057e1d3"><td class="memTemplParams" colspan="2"><a id="ab346b974f6bf28df0a7abd128057e1d3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab346b974f6bf28df0a7abd128057e1d3"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond &amp;&amp;(!<a class="el" href="structtfel_1_1typetraits_1_1_is_complex.html">tfel::typetraits::IsComplex</a>&lt; T &gt;::cond), T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const T src)</td></tr>
<tr class="separator:ab346b974f6bf28df0a7abd128057e1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45a9684e431c09324e6d2490d04fe1f"><td class="memItemLeft" align="right" valign="top"><a id="ad45a9684e431c09324e6d2490d04fe1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (unsigned short)</td></tr>
<tr class="separator:ad45a9684e431c09324e6d2490d04fe1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55125acfcbd8b87c19910bd8d2206521"><td class="memItemLeft" align="right" valign="top"><a id="a55125acfcbd8b87c19910bd8d2206521"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (long unsigned int)</td></tr>
<tr class="separator:a55125acfcbd8b87c19910bd8d2206521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83096473d77d4510e274001696cf7e93"><td class="memItemLeft" align="right" valign="top"><a id="a83096473d77d4510e274001696cf7e93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (short)</td></tr>
<tr class="separator:a83096473d77d4510e274001696cf7e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d0298a35d5c9042563024d87c13d10"><td class="memItemLeft" align="right" valign="top"><a id="a68d0298a35d5c9042563024d87c13d10"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (int)</td></tr>
<tr class="separator:a68d0298a35d5c9042563024d87c13d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65df6c4d94069e4d1b8e8dd5abffe167"><td class="memItemLeft" align="right" valign="top"><a id="a65df6c4d94069e4d1b8e8dd5abffe167"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (long int)</td></tr>
<tr class="separator:a65df6c4d94069e4d1b8e8dd5abffe167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fbe6efcfe832a44bb6daa9f10d4cad"><td class="memItemLeft" align="right" valign="top"><a id="a15fbe6efcfe832a44bb6daa9f10d4cad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (float)</td></tr>
<tr class="separator:a15fbe6efcfe832a44bb6daa9f10d4cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7c37a7d76aad42c64a8cb3d213861f"><td class="memItemLeft" align="right" valign="top"><a id="a0f7c37a7d76aad42c64a8cb3d213861f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (double)</td></tr>
<tr class="separator:a0f7c37a7d76aad42c64a8cb3d213861f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a16b6504017630437c88d18d5f083d1"><td class="memTemplParams" colspan="2"><a id="a3a16b6504017630437c88d18d5f083d1"></a>
template&lt;typename iterator_base &gt; </td></tr>
<tr class="memitem:a3a16b6504017630437c88d18d5f083d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt;::difference_type n, const <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt; p)</td></tr>
<tr class="separator:a3a16b6504017630437c88d18d5f083d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346d17d68f05b4977f74ee91415aae89"><td class="memTemplParams" colspan="2"><a id="a346d17d68f05b4977f74ee91415aae89"></a>
template&lt;typename iterator_base &gt; </td></tr>
<tr class="memitem:a346d17d68f05b4977f74ee91415aae89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const typename <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt;::difference_type n, const <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt; p)</td></tr>
<tr class="separator:a346d17d68f05b4977f74ee91415aae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade46bc6a5995edba2bfb2b918064608e"><td class="memItemLeft" align="right" valign="top"><a id="ade46bc6a5995edba2bfb2b918064608e"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a> &amp;)</td></tr>
<tr class="separator:ade46bc6a5995edba2bfb2b918064608e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a12302918d196d6f451b96c4334097"><td class="memItemLeft" align="right" valign="top"><a id="ad0a12302918d196d6f451b96c4334097"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a> &amp;)</td></tr>
<tr class="separator:ad0a12302918d196d6f451b96c4334097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d8364a7cc6de24932f2d1f677a78fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a44d8364a7cc6de24932f2d1f677a78fb">init_floating_point_exceptions</a> ()</td></tr>
<tr class="separator:a44d8364a7cc6de24932f2d1f677a78fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6b0b722659adc868abcfcc5c7c0533"><td class="memTemplParams" colspan="2">template&lt;typename MathObjectType &gt; </td></tr>
<tr class="memitem:abf6b0b722659adc868abcfcc5c7c0533"><td class="memTemplItemLeft" align="right" valign="top">constexpr unsigned short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a> ()</td></tr>
<tr class="memdesc:abf6b0b722659adc868abcfcc5c7c0533"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function to retrieve the space dimension associated with a math object.  <a href="#abf6b0b722659adc868abcfcc5c7c0533">More...</a><br /></td></tr>
<tr class="separator:abf6b0b722659adc868abcfcc5c7c0533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74895994b09cd51df13c7d3533f3c03"><td class="memTemplParams" colspan="2"><a id="ac74895994b09cd51df13c7d3533f3c03"></a>
template&lt;typename A &gt; </td></tr>
<tr class="memitem:ac74895994b09cd51df13c7d3533f3c03"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_neg_object_random_access_const_iterator.html">NegObjectRandomAccessConstIterator</a>&lt; A &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="classtfel_1_1math_1_1_neg_object_random_access_const_iterator.html">NegObjectRandomAccessConstIterator</a>&lt; A &gt;::Distance n, const <a class="el" href="classtfel_1_1math_1_1_neg_object_random_access_const_iterator.html">NegObjectRandomAccessConstIterator</a>&lt; A &gt; &amp;p)</td></tr>
<tr class="separator:ac74895994b09cd51df13c7d3533f3c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a368b686442cd0ce544de737c66b4ac96"><td class="memTemplParams" colspan="2"><a id="a368b686442cd0ce544de737c66b4ac96"></a>
template&lt;typename A , typename B , typename Op &gt; </td></tr>
<tr class="memitem:a368b686442cd0ce544de737c66b4ac96"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator.html">ObjectObjectRandomAccessConstIterator</a>&lt; A, B, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator.html">ObjectObjectRandomAccessConstIterator</a>&lt; A, B, Op &gt;::Distance n, const <a class="el" href="classtfel_1_1math_1_1_object_object_random_access_const_iterator.html">ObjectObjectRandomAccessConstIterator</a>&lt; A, B, Op &gt; &amp;p)</td></tr>
<tr class="separator:a368b686442cd0ce544de737c66b4ac96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402e6e88fe9409016b77e3b95f155067"><td class="memTemplParams" colspan="2"><a id="a402e6e88fe9409016b77e3b95f155067"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a402e6e88fe9409016b77e3b95f155067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getRandomRotationMatrix</b> ()</td></tr>
<tr class="separator:a402e6e88fe9409016b77e3b95f155067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d392de25d4c06a3d1d4ffcca726a7b"><td class="memTemplParams" colspan="2"><a id="a12d392de25d4c06a3d1d4ffcca726a7b"></a>
template&lt;typename A , typename B , typename Op &gt; </td></tr>
<tr class="memitem:a12d392de25d4c06a3d1d4ffcca726a7b"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_scalar_object_random_access_const_iterator.html">ScalarObjectRandomAccessConstIterator</a>&lt; A, B, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="classtfel_1_1math_1_1_scalar_object_random_access_const_iterator.html">ScalarObjectRandomAccessConstIterator</a>&lt; A, B, Op &gt;::Distance n, const <a class="el" href="classtfel_1_1math_1_1_scalar_object_random_access_const_iterator.html">ScalarObjectRandomAccessConstIterator</a>&lt; A, B, Op &gt; &amp;p)</td></tr>
<tr class="separator:a12d392de25d4c06a3d1d4ffcca726a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125f96fc65e3308b6e76dffded764fd6"><td class="memTemplParams" colspan="2"><a id="a125f96fc65e3308b6e76dffded764fd6"></a>
template&lt;typename A , typename B , typename Op &gt; </td></tr>
<tr class="memitem:a125f96fc65e3308b6e76dffded764fd6"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_object_scalar_random_access_const_iterator.html">ObjectScalarRandomAccessConstIterator</a>&lt; A, B, Op &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="classtfel_1_1math_1_1_object_scalar_random_access_const_iterator.html">ObjectScalarRandomAccessConstIterator</a>&lt; A, B, Op &gt;::Distance n, const <a class="el" href="classtfel_1_1math_1_1_object_scalar_random_access_const_iterator.html">ObjectScalarRandomAccessConstIterator</a>&lt; A, B, Op &gt; &amp;p)</td></tr>
<tr class="separator:a125f96fc65e3308b6e76dffded764fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f20b955fc36abd1608525116ff7f696"><td class="memTemplParams" colspan="2"><a id="a6f20b955fc36abd1608525116ff7f696"></a>
template&lt;typename iterator_base &gt; </td></tr>
<tr class="memitem:a6f20b955fc36abd1608525116ff7f696"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt;::difference_type n, const <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt; p)</td></tr>
<tr class="separator:a6f20b955fc36abd1608525116ff7f696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bc888c51e94431b3ea585559fd01b0"><td class="memTemplParams" colspan="2"><a id="ad8bc888c51e94431b3ea585559fd01b0"></a>
template&lt;typename iterator_base &gt; </td></tr>
<tr class="memitem:ad8bc888c51e94431b3ea585559fd01b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const typename <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt;::difference_type n, const <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt; p)</td></tr>
<tr class="separator:ad8bc888c51e94431b3ea585559fd01b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dd9171e96269d30fa964346b1dba57"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a16dd9171e96269d30fa964346b1dba57"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a16dd9171e96269d30fa964346b1dba57">implementsMatrixConcept</a> ()</td></tr>
<tr class="memdesc:a16dd9171e96269d30fa964346b1dba57"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_matrix_concept.html" title="A class used to model the concept of matrices. Here we use the curiously recurring template pattern...">MatrixConcept</a></code>.  <a href="#a16dd9171e96269d30fa964346b1dba57">More...</a><br /></td></tr>
<tr class="separator:a16dd9171e96269d30fa964346b1dba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367de12487bb7adcf71d6a7489ecd94d"><td class="memTemplParams" colspan="2"><a id="a367de12487bb7adcf71d6a7489ecd94d"></a>
template&lt;unsigned short N, unsigned short M, typename T &gt; </td></tr>
<tr class="memitem:a367de12487bb7adcf71d6a7489ecd94d"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; M, N, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;m)</td></tr>
<tr class="separator:a367de12487bb7adcf71d6a7489ecd94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644df7be3e82822b2e69cc10936692fd"><td class="memTemplParams" colspan="2"><a id="a644df7be3e82822b2e69cc10936692fd"></a>
template&lt;typename T , typename Operation &gt; </td></tr>
<tr class="memitem:a644df7be3e82822b2e69cc10936692fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 2, 2, T &gt;, Operation &gt; &amp;m)</td></tr>
<tr class="separator:a644df7be3e82822b2e69cc10936692fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af81fbe17baa855f6fb347547fe5389"><td class="memTemplParams" colspan="2"><a id="a3af81fbe17baa855f6fb347547fe5389"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3af81fbe17baa855f6fb347547fe5389"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 2, 2, T &gt; &amp;m)</td></tr>
<tr class="separator:a3af81fbe17baa855f6fb347547fe5389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8139f8cc57793eb2ecd1b4fed69913"><td class="memTemplParams" colspan="2"><a id="adb8139f8cc57793eb2ecd1b4fed69913"></a>
template&lt;typename T , typename Operation &gt; </td></tr>
<tr class="memitem:adb8139f8cc57793eb2ecd1b4fed69913"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3, 3, T &gt;, Operation &gt; &amp;m)</td></tr>
<tr class="separator:adb8139f8cc57793eb2ecd1b4fed69913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28edcc3db38accf5f3ed50f8584b33e8"><td class="memTemplParams" colspan="2"><a id="a28edcc3db38accf5f3ed50f8584b33e8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28edcc3db38accf5f3ed50f8584b33e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3, 3, T &gt; &amp;m)</td></tr>
<tr class="separator:a28edcc3db38accf5f3ed50f8584b33e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57959b3e12df3752b3cac6fe620c08e8"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, unsigned short M, typename T &gt; </td></tr>
<tr class="memitem:a57959b3e12df3752b3cac6fe620c08e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; M, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a57959b3e12df3752b3cac6fe620c08e8">getRow</a> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;m, const unsigned short i)</td></tr>
<tr class="separator:a57959b3e12df3752b3cac6fe620c08e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0112c63107c34060f92af4389b61346"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, unsigned short M, typename T &gt; </td></tr>
<tr class="memitem:ae0112c63107c34060f92af4389b61346"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae0112c63107c34060f92af4389b61346">getColumn</a> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;m, const unsigned short)</td></tr>
<tr class="separator:ae0112c63107c34060f92af4389b61346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be8a39585878e40e7c7d67af203ec31"><td class="memTemplParams" colspan="2"><a id="a7be8a39585878e40e7c7d67af203ec31"></a>
template&lt;unsigned short N, unsigned short M, typename T &gt; </td></tr>
<tr class="memitem:a7be8a39585878e40e7c7d67af203ec31"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;)</td></tr>
<tr class="separator:a7be8a39585878e40e7c7d67af203ec31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34bde6a62da31a11e114a9d1a2f8cfa"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Criterion , typename NumericType , typename IndexType &gt; </td></tr>
<tr class="memitem:aa34bde6a62da31a11e114a9d1a2f8cfa"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; bool, NumericType, IndexType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa34bde6a62da31a11e114a9d1a2f8cfa">scalarNewtonRaphson</a> (const Function &amp;, const Criterion &amp;, const NumericType, const IndexType)</td></tr>
<tr class="memdesc:aa34bde6a62da31a11e114a9d1a2f8cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the root of the given function.  <a href="#aa34bde6a62da31a11e114a9d1a2f8cfa">More...</a><br /></td></tr>
<tr class="separator:aa34bde6a62da31a11e114a9d1a2f8cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721b69ae40bf0e14b7e34b6b703e53eb"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Criterion , typename NumericType , typename IndexType &gt; </td></tr>
<tr class="memitem:a721b69ae40bf0e14b7e34b6b703e53eb"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; bool, NumericType, IndexType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a721b69ae40bf0e14b7e34b6b703e53eb">scalarNewtonRaphson</a> (const Function &amp;, const Criterion &amp;, const <a class="el" href="structtfel_1_1math_1_1_scalar_newton_raphson_parameters.html">ScalarNewtonRaphsonParameters</a>&lt; NumericType, IndexType &gt; &amp;)</td></tr>
<tr class="memdesc:a721b69ae40bf0e14b7e34b6b703e53eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the root of the given function.  <a href="#a721b69ae40bf0e14b7e34b6b703e53eb">More...</a><br /></td></tr>
<tr class="separator:a721b69ae40bf0e14b7e34b6b703e53eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d86c59ae621351bb56182c7f66124b"><td class="memTemplParams" colspan="2"><a id="a72d86c59ae621351bb56182c7f66124b"></a>
template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:a72d86c59ae621351bb56182c7f66124b"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>power</b> (const T)</td></tr>
<tr class="separator:a72d86c59ae621351bb56182c7f66124b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc1544551a61a9232dbac10aafaf821"><td class="memTemplParams" colspan="2"><a id="a9fc1544551a61a9232dbac10aafaf821"></a>
template&lt;int N, unsigned int D, typename T &gt; </td></tr>
<tr class="memitem:a9fc1544551a61a9232dbac10aafaf821"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>power</b> (const T)</td></tr>
<tr class="separator:a9fc1544551a61a9232dbac10aafaf821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac819ab4b4d4d6e80ce4632932a3e777e"><td class="memTemplParams" colspan="2"><a id="ac819ab4b4d4d6e80ce4632932a3e777e"></a>
template&lt;int N, typename T &gt; </td></tr>
<tr class="memitem:ac819ab4b4d4d6e80ce4632932a3e777e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>power</b> (const T x)</td></tr>
<tr class="separator:ac819ab4b4d4d6e80ce4632932a3e777e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae09880739e6972d25e8f833ca13b1e"><td class="memTemplParams" colspan="2"><a id="a1ae09880739e6972d25e8f833ca13b1e"></a>
template&lt;int N, unsigned int D, typename T &gt; </td></tr>
<tr class="memitem:a1ae09880739e6972d25e8f833ca13b1e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>power</b> (const T x)</td></tr>
<tr class="separator:a1ae09880739e6972d25e8f833ca13b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5432b7ca1b84325ff3f8284111fd96"><td class="memTemplParams" colspan="2"><a id="a5b5432b7ca1b84325ff3f8284111fd96"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:a5b5432b7ca1b84325ff3f8284111fd96"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;)</td></tr>
<tr class="separator:a5b5432b7ca1b84325ff3f8284111fd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c57d4bfbf56ffa05d5222373433ea3"><td class="memTemplParams" colspan="2"><a id="a25c57d4bfbf56ffa05d5222373433ea3"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:a25c57d4bfbf56ffa05d5222373433ea3"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;)</td></tr>
<tr class="separator:a25c57d4bfbf56ffa05d5222373433ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb44f389cb1a3958b3ec44057372406"><td class="memTemplParams" colspan="2"><a id="aabb44f389cb1a3958b3ec44057372406"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:aabb44f389cb1a3958b3ec44057372406"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;)</td></tr>
<tr class="separator:aabb44f389cb1a3958b3ec44057372406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec8114eb0ef59bc9c74be078903e049"><td class="memTemplParams" colspan="2"><a id="a3ec8114eb0ef59bc9c74be078903e049"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:a3ec8114eb0ef59bc9c74be078903e049"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;)</td></tr>
<tr class="separator:a3ec8114eb0ef59bc9c74be078903e049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef2d3c737c1321c3ce9815ad83087ce"><td class="memTemplParams" colspan="2"><a id="afef2d3c737c1321c3ce9815ad83087ce"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:afef2d3c737c1321c3ce9815ad83087ce"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;)</td></tr>
<tr class="separator:afef2d3c737c1321c3ce9815ad83087ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbdc1b51868ca44151ba0cdc9e06afc"><td class="memTemplParams" colspan="2"><a id="a1cbdc1b51868ca44151ba0cdc9e06afc"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:a1cbdc1b51868ca44151ba0cdc9e06afc"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt;)</td></tr>
<tr class="separator:a1cbdc1b51868ca44151ba0cdc9e06afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbb95981bf45b6b2924d2f77c173eb37"><td class="memTemplParams" colspan="2"><a id="afbb95981bf45b6b2924d2f77c173eb37"></a>
template&lt;typename Unit , typename Scal &gt; </td></tr>
<tr class="memitem:afbb95981bf45b6b2924d2f77c173eb37"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr Scal&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; <a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a>, Scal &gt; &amp;)</td></tr>
<tr class="separator:afbb95981bf45b6b2924d2f77c173eb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695c24d2cd8e004fcf4d89fa2cd453a4"><td class="memTemplParams" colspan="2"><a id="a695c24d2cd8e004fcf4d89fa2cd453a4"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:a695c24d2cd8e004fcf4d89fa2cd453a4"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt; &amp;)</td></tr>
<tr class="separator:a695c24d2cd8e004fcf4d89fa2cd453a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bc23d25438481db1298f2e53121ab3"><td class="memTemplParams" colspan="2"><a id="af0bc23d25438481db1298f2e53121ab3"></a>
template&lt;typename unit , typename T &gt; </td></tr>
<tr class="memitem:af0bc23d25438481db1298f2e53121ab3"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T &gt; &amp;q)</td></tr>
<tr class="separator:af0bc23d25438481db1298f2e53121ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee96e4dbaf07d3f9539e7868e3e45d6"><td class="memTemplParams" colspan="2"><a id="a2ee96e4dbaf07d3f9539e7868e3e45d6"></a>
template&lt;typename unit , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a2ee96e4dbaf07d3f9539e7868e3e45d6"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, typename <a class="el" href="structtfel_1_1typetraits_1_1_promote.html">tfel::typetraits::Promote</a>&lt; T1, T2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T1 &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T2 &gt;)</td></tr>
<tr class="separator:a2ee96e4dbaf07d3f9539e7868e3e45d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6553175d8955e51c8eaeb3b023b321f2"><td class="memTemplParams" colspan="2"><a id="a6553175d8955e51c8eaeb3b023b321f2"></a>
template&lt;typename unit , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a6553175d8955e51c8eaeb3b023b321f2"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, typename <a class="el" href="structtfel_1_1typetraits_1_1_promote.html">tfel::typetraits::Promote</a>&lt; T1, T2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T1 &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T2 &gt;)</td></tr>
<tr class="separator:a6553175d8955e51c8eaeb3b023b321f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7685502b766644a6e988d651bd90ff8e"><td class="memTemplParams" colspan="2"><a id="a7685502b766644a6e988d651bd90ff8e"></a>
template&lt;typename unit , typename T1 , typename unit2 , typename T2 &gt; </td></tr>
<tr class="memitem:a7685502b766644a6e988d651bd90ff8e"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_add_unit__.html">AddUnit_</a>&lt; unit, unit2 &gt;::type, typename <a class="el" href="structtfel_1_1typetraits_1_1_promote.html">tfel::typetraits::Promote</a>&lt; T1, T2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T1 &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit2, T2 &gt;)</td></tr>
<tr class="separator:a7685502b766644a6e988d651bd90ff8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322d48cb11ffcb916c67ec3f29cc6371"><td class="memTemplParams" colspan="2"><a id="a322d48cb11ffcb916c67ec3f29cc6371"></a>
template&lt;typename unit , typename T1 , typename unit2 , typename T2 &gt; </td></tr>
<tr class="memitem:a322d48cb11ffcb916c67ec3f29cc6371"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE constexpr <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_sub_unit__.html">SubUnit_</a>&lt; unit, unit2 &gt;::type, typename <a class="el" href="structtfel_1_1typetraits_1_1_promote.html">tfel::typetraits::Promote</a>&lt; T1, T2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit, T1 &gt;, const <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt; unit2, T2 &gt;)</td></tr>
<tr class="separator:a322d48cb11ffcb916c67ec3f29cc6371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66351bbed161a09dc75fa160c96143ac"><td class="memItemLeft" align="right" valign="top"><a id="a66351bbed161a09dc75fa160c96143ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (unsigned short)</td></tr>
<tr class="separator:a66351bbed161a09dc75fa160c96143ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e73c4f1db8504ee53e79c79a106b796"><td class="memItemLeft" align="right" valign="top"><a id="a8e73c4f1db8504ee53e79c79a106b796"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (long unsigned int)</td></tr>
<tr class="separator:a8e73c4f1db8504ee53e79c79a106b796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab0654e1776c718519143adfc08a9be"><td class="memItemLeft" align="right" valign="top"><a id="aaab0654e1776c718519143adfc08a9be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (short)</td></tr>
<tr class="separator:aaab0654e1776c718519143adfc08a9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5673079fd79f7cd9f328c6409155c713"><td class="memItemLeft" align="right" valign="top"><a id="a5673079fd79f7cd9f328c6409155c713"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (int)</td></tr>
<tr class="separator:a5673079fd79f7cd9f328c6409155c713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad916a7a479dc3a128a387d4a4556b387"><td class="memItemLeft" align="right" valign="top"><a id="ad916a7a479dc3a128a387d4a4556b387"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (long int)</td></tr>
<tr class="separator:ad916a7a479dc3a128a387d4a4556b387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1c54a966b27a9d7f1e90ac3b615f05"><td class="memItemLeft" align="right" valign="top"><a id="acd1c54a966b27a9d7f1e90ac3b615f05"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (float)</td></tr>
<tr class="separator:acd1c54a966b27a9d7f1e90ac3b615f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8bff81de76da439d0ebc29b0201010"><td class="memItemLeft" align="right" valign="top"><a id="a2c8bff81de76da439d0ebc29b0201010"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (double)</td></tr>
<tr class="separator:a2c8bff81de76da439d0ebc29b0201010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e71f31cfedb01955d11f2891991651c"><td class="memItemLeft" align="right" valign="top"><a id="a6e71f31cfedb01955d11f2891991651c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; unsigned short &gt;)</td></tr>
<tr class="separator:a6e71f31cfedb01955d11f2891991651c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1d04d032ce1b7bdc61b917b3271fda"><td class="memItemLeft" align="right" valign="top"><a id="a8d1d04d032ce1b7bdc61b917b3271fda"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; unsigned int &gt;)</td></tr>
<tr class="separator:a8d1d04d032ce1b7bdc61b917b3271fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae861c64af756816827040e1dca134821"><td class="memItemLeft" align="right" valign="top"><a id="ae861c64af756816827040e1dca134821"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; long unsigned int &gt;)</td></tr>
<tr class="separator:ae861c64af756816827040e1dca134821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeed2a640a7a8d59356442936827c7c8"><td class="memItemLeft" align="right" valign="top"><a id="abeed2a640a7a8d59356442936827c7c8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; short &gt;)</td></tr>
<tr class="separator:abeed2a640a7a8d59356442936827c7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491fb279da58b5514c2f93e6b51bb5a2"><td class="memItemLeft" align="right" valign="top"><a id="a491fb279da58b5514c2f93e6b51bb5a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; int &gt;)</td></tr>
<tr class="separator:a491fb279da58b5514c2f93e6b51bb5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a1d6ffd360baca75e66dbdc6c5ef4c"><td class="memItemLeft" align="right" valign="top"><a id="aa2a1d6ffd360baca75e66dbdc6c5ef4c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; long int &gt;)</td></tr>
<tr class="separator:aa2a1d6ffd360baca75e66dbdc6c5ef4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5f6df114cd0e418f5a8c1dd28d3537"><td class="memItemLeft" align="right" valign="top"><a id="a8a5f6df114cd0e418f5a8c1dd28d3537"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; float &gt;)</td></tr>
<tr class="separator:a8a5f6df114cd0e418f5a8c1dd28d3537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7873a2dcdb8e3d5b10f2198de948ad"><td class="memItemLeft" align="right" valign="top"><a id="a7f7873a2dcdb8e3d5b10f2198de948ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; double &gt;)</td></tr>
<tr class="separator:a7f7873a2dcdb8e3d5b10f2198de948ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a084db953adf9b2955ecec2c850ef6"><td class="memItemLeft" align="right" valign="top"><a id="a96a084db953adf9b2955ecec2c850ef6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QT_RESULT_TYPE</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; long double &gt;)</td></tr>
<tr class="separator:a96a084db953adf9b2955ecec2c850ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a2fc98dcdf453463e8a57d050ad943"><td class="memTemplParams" colspan="2">template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:ae2a2fc98dcdf453463e8a57d050ad943"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae2a2fc98dcdf453463e8a57d050ad943">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_bissection_algorithm_data.html">BissectionAlgorithmData</a>&lt; NumericType &gt; &amp;)</td></tr>
<tr class="memdesc:ae2a2fc98dcdf453463e8a57d050ad943"><td class="mdescLeft">&#160;</td><td class="mdescRight">output stream  <a href="#ae2a2fc98dcdf453463e8a57d050ad943">More...</a><br /></td></tr>
<tr class="separator:ae2a2fc98dcdf453463e8a57d050ad943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150aa17b4b9b5abbb5f87489adaf663f"><td class="memTemplParams" colspan="2">template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:a150aa17b4b9b5abbb5f87489adaf663f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a150aa17b4b9b5abbb5f87489adaf663f">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_bissection_algorithm_base.html">BissectionAlgorithmBase</a>&lt; NumericType &gt; &amp;)</td></tr>
<tr class="memdesc:a150aa17b4b9b5abbb5f87489adaf663f"><td class="mdescLeft">&#160;</td><td class="mdescRight">output stream  <a href="#a150aa17b4b9b5abbb5f87489adaf663f">More...</a><br /></td></tr>
<tr class="separator:a150aa17b4b9b5abbb5f87489adaf663f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec89b9fce29718c2807dfee5fbeb93fc"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename StensorType &gt; </td></tr>
<tr class="memitem:aec89b9fce29718c2807dfee5fbeb93fc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==1u) &amp;&amp;(getSpaceDimension&lt; StensorType &gt;)==1u) &amp;&amp;implementsST2toST2Concept&lt; ST2toST2Type &gt;) &amp;&amp;implementsStensorConcept&lt; StensorType &gt;) &amp;&amp;std::is_same_v&lt; numeric_type&lt; ST2toST2Type &gt;, numeric_type&lt; StensorType &gt; &gt;), st2tost2&lt; 1u, numeric_type&lt; ST2toST2Type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aec89b9fce29718c2807dfee5fbeb93fc">convertSpatialModuliToKirchhoffJaumanRateModuli</a> (const ST2toST2Type &amp;C_s, const StensorType &amp;tau)</td></tr>
<tr class="memdesc:aec89b9fce29718c2807dfee5fbeb93fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the spatial moduli in the moduli associated with Jauman rate of the Kirchhoff stress  <a href="#aec89b9fce29718c2807dfee5fbeb93fc">More...</a><br /></td></tr>
<tr class="separator:aec89b9fce29718c2807dfee5fbeb93fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6e322a1f3214196833b24e8a298960"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename StensorType &gt; </td></tr>
<tr class="memitem:a6b6e322a1f3214196833b24e8a298960"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==2u) &amp;&amp;(getSpaceDimension&lt; StensorType &gt;)==2u) &amp;&amp;implementsST2toST2Concept&lt; ST2toST2Type &gt;) &amp;&amp;implementsStensorConcept&lt; StensorType &gt;) &amp;&amp;std::is_same_v&lt; numeric_type&lt; ST2toST2Type &gt;, numeric_type&lt; StensorType &gt; &gt;), st2tost2&lt; 2u, numeric_type&lt; ST2toST2Type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6b6e322a1f3214196833b24e8a298960">convertSpatialModuliToKirchhoffJaumanRateModuli</a> (const ST2toST2Type &amp;C_s, const StensorType &amp;tau)</td></tr>
<tr class="memdesc:a6b6e322a1f3214196833b24e8a298960"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the spatial moduli in the moduli associated with Jauman rate of the Kirchhoff stress  <a href="#a6b6e322a1f3214196833b24e8a298960">More...</a><br /></td></tr>
<tr class="separator:a6b6e322a1f3214196833b24e8a298960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824e8fcc7047d972cf62034191af00a6"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename StensorType &gt; </td></tr>
<tr class="memitem:a824e8fcc7047d972cf62034191af00a6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==3u) &amp;&amp;(getSpaceDimension&lt; StensorType &gt;)==3u) &amp;&amp;implementsST2toST2Concept&lt; ST2toST2Type &gt;) &amp;&amp;implementsStensorConcept&lt; StensorType &gt;) &amp;&amp;std::is_same_v&lt; numeric_type&lt; ST2toST2Type &gt;, numeric_type&lt; StensorType &gt; &gt;), st2tost2&lt; 3u, numeric_type&lt; ST2toST2Type &gt; &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a824e8fcc7047d972cf62034191af00a6">convertSpatialModuliToKirchhoffJaumanRateModuli</a> (const ST2toST2Type &amp;C_s, const StensorType &amp;tau)</td></tr>
<tr class="memdesc:a824e8fcc7047d972cf62034191af00a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the spatial moduli in the moduli associated with Jauman rate of the Kirchhoff stress  <a href="#a824e8fcc7047d972cf62034191af00a6">More...</a><br /></td></tr>
<tr class="separator:a824e8fcc7047d972cf62034191af00a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060780df969a6b5eed8de96195471ccd"><td class="memTemplParams" colspan="2"><a id="a060780df969a6b5eed8de96195471ccd"></a>
template&lt;typename T2toST2Type , typename TensorType &gt; </td></tr>
<tr class="memitem:a060780df969a6b5eed8de96195471ccd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;)==1u) &amp;&amp;(getSpaceDimension&lt; TensorType &gt;)==1u) &amp;&amp;implementsT2toST2Concept&lt; T2toST2Type &gt;) &amp;&amp;implementsTensorConcept&lt; TensorType &gt;)), st2tost2&lt; 1u, typename ResultType&lt; numeric_type&lt; T2toST2Type &gt;, numeric_type&lt; TensorType &gt;, OpMult &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertToTangentModuli</b> (const T2toST2Type &amp;K, const TensorType &amp;F)</td></tr>
<tr class="separator:a060780df969a6b5eed8de96195471ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e08525d097940cf2b911e9cb10e8c1e"><td class="memTemplParams" colspan="2"><a id="a2e08525d097940cf2b911e9cb10e8c1e"></a>
template&lt;typename T2toST2Type , typename TensorType &gt; </td></tr>
<tr class="memitem:a2e08525d097940cf2b911e9cb10e8c1e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;)==2u) &amp;&amp;(getSpaceDimension&lt; TensorType &gt;)==2u) &amp;&amp;implementsT2toST2Concept&lt; T2toST2Type &gt;) &amp;&amp;implementsTensorConcept&lt; TensorType &gt;)), st2tost2&lt; 2u, typename ResultType&lt; numeric_type&lt; T2toST2Type &gt;, numeric_type&lt; TensorType &gt;, OpMult &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertToTangentModuli</b> (const T2toST2Type &amp;K, const TensorType &amp;F)</td></tr>
<tr class="separator:a2e08525d097940cf2b911e9cb10e8c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27da0c361e57aba29790a8fe0119acc"><td class="memTemplParams" colspan="2"><a id="ab27da0c361e57aba29790a8fe0119acc"></a>
template&lt;typename T2toST2Type , typename TensorType &gt; </td></tr>
<tr class="memitem:ab27da0c361e57aba29790a8fe0119acc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;)==3u) &amp;&amp;(getSpaceDimension&lt; TensorType &gt;)==3u) &amp;&amp;implementsT2toST2Concept&lt; T2toST2Type &gt;) &amp;&amp;implementsTensorConcept&lt; TensorType &gt;)), st2tost2&lt; 3u, typename ResultType&lt; numeric_type&lt; T2toST2Type &gt;, numeric_type&lt; TensorType &gt;, OpMult &gt;::type &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertToTangentModuli</b> (const T2toST2Type &amp;K, const TensorType &amp;F)</td></tr>
<tr class="separator:ab27da0c361e57aba29790a8fe0119acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d29940d33a9b67b48d9c7d91fed631a"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:a4d29940d33a9b67b48d9c7d91fed631a"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;), <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt;, <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4d29940d33a9b67b48d9c7d91fed631a">invert</a> (const ST2toST2Type &amp;s)</td></tr>
<tr class="separator:a4d29940d33a9b67b48d9c7d91fed631a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785578fb243ba7379d14469310bffb53"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:a785578fb243ba7379d14469310bffb53"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;), <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a785578fb243ba7379d14469310bffb53">change_basis</a> (const ST2toST2Type &amp;s, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt;&gt; &amp;r)</td></tr>
<tr class="separator:a785578fb243ba7379d14469310bffb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7f716b1f1e9f23fff20e841c44e84f"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename TensorType &gt; </td></tr>
<tr class="memitem:a1b7f716b1f1e9f23fff20e841c44e84f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1b7f716b1f1e9f23fff20e841c44e84f">push_forward</a> (const ST2toST2Type &amp;C, const TensorType &amp;F)</td></tr>
<tr class="separator:a1b7f716b1f1e9f23fff20e841c44e84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9e0f57e8bd02abaafbe6c3e5a9b076"><td class="memTemplParams" colspan="2"><a id="acd9e0f57e8bd02abaafbe6c3e5a9b076"></a>
template&lt;typename ST2toST2Type , typename TensorType &gt; </td></tr>
<tr class="memitem:acd9e0f57e8bd02abaafbe6c3e5a9b076"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pull_back</b> (const ST2toST2Type &amp;C, const TensorType &amp;F)</td></tr>
<tr class="separator:acd9e0f57e8bd02abaafbe6c3e5a9b076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d6c194266fa00d5a21cdd8b6570b54"><td class="memTemplParams" colspan="2"><a id="ae3d6c194266fa00d5a21cdd8b6570b54"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:ae3d6c194266fa00d5a21cdd8b6570b54"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;::cond, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeDeterminantSecondDerivative</b> (const StensorType &amp;s)</td></tr>
<tr class="separator:ae3d6c194266fa00d5a21cdd8b6570b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f7cc831deb38e98a6990381de38c58"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a97f7cc831deb38e98a6990381de38c58"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;::cond, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a97f7cc831deb38e98a6990381de38c58">computeDeviatorDeterminantSecondDerivative</a> (const StensorType &amp;)</td></tr>
<tr class="memdesc:a97f7cc831deb38e98a6990381de38c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the second derivative of determinant of the deviator of a symmetric tensor with respect to this tensor.  <a href="#a97f7cc831deb38e98a6990381de38c58">More...</a><br /></td></tr>
<tr class="separator:a97f7cc831deb38e98a6990381de38c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bffc5a9c8d6b8cb020e9f6edcf5768"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:a16bffc5a9c8d6b8cb020e9f6edcf5768"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a> ()</td></tr>
<tr class="memdesc:a16bffc5a9c8d6b8cb020e9f6edcf5768"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a></code>.  <a href="#a16bffc5a9c8d6b8cb020e9f6edcf5768">More...</a><br /></td></tr>
<tr class="separator:a16bffc5a9c8d6b8cb020e9f6edcf5768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad249660501ee6fc01ec988d59281322b"><td class="memTemplParams" colspan="2"><a id="ad249660501ee6fc01ec988d59281322b"></a>
template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:ad249660501ee6fc01ec988d59281322b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;), typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt; &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const ST2toST2Type &amp;)</td></tr>
<tr class="separator:ad249660501ee6fc01ec988d59281322b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390bb97667687287c841ef849eb72359"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </td></tr>
<tr class="memitem:a390bb97667687287c841ef849eb72359"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==1u &amp;&amp;getSpaceDimension&lt; ST2toST2Type2 &gt;)==1u &amp;getSpaceDimension&lt; TensorType &gt;)==1u, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a390bb97667687287c841ef849eb72359">push_forward</a> (ST2toST2Type &amp;, const ST2toST2Type2 &amp;, const TensorType &amp;)</td></tr>
<tr class="memdesc:a390bb97667687287c841ef849eb72359"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ]  <a href="#a390bb97667687287c841ef849eb72359">More...</a><br /></td></tr>
<tr class="separator:a390bb97667687287c841ef849eb72359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af780ee7660b6d43a34d4337f321351eb"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </td></tr>
<tr class="memitem:af780ee7660b6d43a34d4337f321351eb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==2u &amp;&amp;getSpaceDimension&lt; ST2toST2Type2 &gt;)==2u &amp;getSpaceDimension&lt; TensorType &gt;)==2u, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af780ee7660b6d43a34d4337f321351eb">push_forward</a> (ST2toST2Type &amp;, const ST2toST2Type2 &amp;, const TensorType &amp;)</td></tr>
<tr class="memdesc:af780ee7660b6d43a34d4337f321351eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ]  <a href="#af780ee7660b6d43a34d4337f321351eb">More...</a><br /></td></tr>
<tr class="separator:af780ee7660b6d43a34d4337f321351eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6401de57bbca960e9de5c231dacd3d5"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </td></tr>
<tr class="memitem:ad6401de57bbca960e9de5c231dacd3d5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==3u &amp;&amp;getSpaceDimension&lt; ST2toST2Type2 &gt;)==3u &amp;getSpaceDimension&lt; TensorType &gt;)==3u, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad6401de57bbca960e9de5c231dacd3d5">push_forward</a> (ST2toST2Type &amp;, const ST2toST2Type2 &amp;, const TensorType &amp;)</td></tr>
<tr class="memdesc:ad6401de57bbca960e9de5c231dacd3d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ]  <a href="#ad6401de57bbca960e9de5c231dacd3d5">More...</a><br /></td></tr>
<tr class="separator:ad6401de57bbca960e9de5c231dacd3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cbf9140ff4e646564528f4ee402080"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:a76cbf9140ff4e646564528f4ee402080"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a76cbf9140ff4e646564528f4ee402080">transpose</a> (ST2toST2Type &amp;&amp;t) -&gt; std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;(), <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="namespacetfel_1_1math.html#af77fbcb0679a70e562fe1e0f10f5e61c">EvaluationResult</a>&lt; ST2toST2Type &gt;, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html">ST2toST2TransposeExpr</a>&lt; decltype(t)&gt;&gt;&gt;</td></tr>
<tr class="separator:a76cbf9140ff4e646564528f4ee402080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4cd77b32eb18ba423f76fcbcac0cfe2"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:af4cd77b32eb18ba423f76fcbcac0cfe2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==1u) &amp;&amp;tfel::typetraits::IsScalar&lt; numeric_type&lt; ST2toST2Type &gt; &gt;::cond, typename ComputeUnaryResult&lt; numeric_type&lt; ST2toST2Type &gt;, Power&lt; 3 &gt; &gt;::Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af4cd77b32eb18ba423f76fcbcac0cfe2">det</a> (const ST2toST2Type &amp;)</td></tr>
<tr class="separator:af4cd77b32eb18ba423f76fcbcac0cfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff681701362e5b7d6c4ef926cebde780"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:aff681701362e5b7d6c4ef926cebde780"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==2u)||(getSpaceDimension&lt; ST2toST2Type &gt;)==3u)) &amp;&amp;tfel::typetraits::IsScalar&lt; numeric_type&lt; ST2toST2Type &gt; &gt;::cond, typename ComputeUnaryResult&lt; numeric_type&lt; ST2toST2Type &gt;, Power&lt; getSpaceDimension&lt; ST2toST2Type &gt;)&gt; &gt;::Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aff681701362e5b7d6c4ef926cebde780">det</a> (const ST2toST2Type &amp;)</td></tr>
<tr class="separator:aff681701362e5b7d6c4ef926cebde780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e39a1ce5b47f1cfdf174a3a306d4dff"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:a0e39a1ce5b47f1cfdf174a3a306d4dff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0e39a1ce5b47f1cfdf174a3a306d4dff">transpose</a> (ST2toST2Type &amp;&amp;t) -&gt; std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;(), <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="namespacetfel_1_1math.html#af77fbcb0679a70e562fe1e0f10f5e61c">EvaluationResult</a>&lt; ST2toST2Type &gt;, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html">ST2toST2TransposeExpr</a>&lt; decltype(t)&gt;&gt;&gt;</td></tr>
<tr class="separator:a0e39a1ce5b47f1cfdf174a3a306d4dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a4df26ed2339327310966205d4c1c9"><td class="memTemplParams" colspan="2"><a id="a61a4df26ed2339327310966205d4c1c9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a61a4df26ed2339327310966205d4c1c9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:a61a4df26ed2339327310966205d4c1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15c8c5daef1fee3fb42c6f293be9a7d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa15c8c5daef1fee3fb42c6f293be9a7d"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T1 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; T2 &gt;) &amp;&amp;!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Handle &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa15c8c5daef1fee3fb42c6f293be9a7d">operator|</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:aa15c8c5daef1fee3fb42c6f293be9a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfda655d34d39ce7e596d82d133cd26a"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </td></tr>
<tr class="memitem:acfda655d34d39ce7e596d82d133cd26a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==1u &amp;&amp;getSpaceDimension&lt; ST2toST2Type2 &gt;)==1u &amp;getSpaceDimension&lt; TensorType &gt;)==1u, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#acfda655d34d39ce7e596d82d133cd26a">push_forward</a> (ST2toST2Type &amp;Ct, const ST2toST2Type2 &amp;C, const TensorType &amp;F)</td></tr>
<tr class="memdesc:acfda655d34d39ce7e596d82d133cd26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ]  <a href="#acfda655d34d39ce7e596d82d133cd26a">More...</a><br /></td></tr>
<tr class="separator:acfda655d34d39ce7e596d82d133cd26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f79c9a625ee8791fd35ac85a5392f0"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </td></tr>
<tr class="memitem:a07f79c9a625ee8791fd35ac85a5392f0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==2u &amp;&amp;getSpaceDimension&lt; ST2toST2Type2 &gt;)==2u &amp;getSpaceDimension&lt; TensorType &gt;)==2u, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a07f79c9a625ee8791fd35ac85a5392f0">push_forward</a> (ST2toST2Type &amp;Ct, const ST2toST2Type2 &amp;C, const TensorType &amp;F)</td></tr>
<tr class="memdesc:a07f79c9a625ee8791fd35ac85a5392f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ]  <a href="#a07f79c9a625ee8791fd35ac85a5392f0">More...</a><br /></td></tr>
<tr class="separator:a07f79c9a625ee8791fd35ac85a5392f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc6fe3fb4d367b46678f77ba7df9477"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </td></tr>
<tr class="memitem:accc6fe3fb4d367b46678f77ba7df9477"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==3u &amp;&amp;getSpaceDimension&lt; ST2toST2Type2 &gt;)==3u &amp;getSpaceDimension&lt; TensorType &gt;)==3u, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#accc6fe3fb4d367b46678f77ba7df9477">push_forward</a> (ST2toST2Type &amp;Ct, const ST2toST2Type2 &amp;C, const TensorType &amp;F)</td></tr>
<tr class="memdesc:accc6fe3fb4d367b46678f77ba7df9477"><td class="mdescLeft">&#160;</td><td class="mdescRight">performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ]  <a href="#accc6fe3fb4d367b46678f77ba7df9477">More...</a><br /></td></tr>
<tr class="separator:accc6fe3fb4d367b46678f77ba7df9477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49fbcbc005ce151c03fa76320dfeeab"><td class="memTemplParams" colspan="2"><a id="ab49fbcbc005ce151c03fa76320dfeeab"></a>
template&lt;typename StensorType1 , typename StensorType2 &gt; </td></tr>
<tr class="memitem:ab49fbcbc005ce151c03fa76320dfeeab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>symmetric_product_derivative_daba_da</b> (const StensorType1 &amp;a, const StensorType2 &amp;b) -&gt; typename std::enable_if&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType1 &gt;()) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType2 &gt;()) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType1 &gt;()==1u) &amp;&amp;(getSpaceDimension&lt; StensorType2 &gt;()==1u)), st2tost2&lt; 1u, decltype(a[0] *b[0])&gt;&gt;::type</td></tr>
<tr class="separator:ab49fbcbc005ce151c03fa76320dfeeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc20bb19ab6a5245cfe5e547e6a2bf8a"><td class="memTemplParams" colspan="2"><a id="acc20bb19ab6a5245cfe5e547e6a2bf8a"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:acc20bb19ab6a5245cfe5e547e6a2bf8a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>symmetric_product_derivative_daba_db</b> (const StensorType &amp;a) -&gt; typename std::enable_if&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;()) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;()==1u)), st2tost2&lt; 1u, decltype(a[0] *a[0])&gt;&gt;::type</td></tr>
<tr class="separator:acc20bb19ab6a5245cfe5e547e6a2bf8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92faf512abe19e1716bd5aeeb215727a"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:a92faf512abe19e1716bd5aeeb215727a"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;), <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a92faf512abe19e1716bd5aeeb215727a">change_basis</a> (const ST2toST2Type &amp;, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt;&gt; &amp;)</td></tr>
<tr class="separator:a92faf512abe19e1716bd5aeeb215727a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0178c5e31d405f93fc7dbfade5ada5d5"><td class="memTemplParams" colspan="2">template&lt;typename ST2toT2Type &gt; </td></tr>
<tr class="memitem:a0178c5e31d405f93fc7dbfade5ada5d5"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0178c5e31d405f93fc7dbfade5ada5d5">implementsST2toT2Concept</a> ()</td></tr>
<tr class="memdesc:a0178c5e31d405f93fc7dbfade5ada5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_concept.html">ST2toT2Concept</a></code>.  <a href="#a0178c5e31d405f93fc7dbfade5ada5d5">More...</a><br /></td></tr>
<tr class="separator:a0178c5e31d405f93fc7dbfade5ada5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa47a955c47550ec67418f2be478a27"><td class="memTemplParams" colspan="2"><a id="a5fa47a955c47550ec67418f2be478a27"></a>
template&lt;typename ST2toT2Type &gt; </td></tr>
<tr class="memitem:a5fa47a955c47550ec67418f2be478a27"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a0178c5e31d405f93fc7dbfade5ada5d5">implementsST2toT2Concept</a>&lt; ST2toT2Type &gt;), typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toT2Type &gt; &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const ST2toT2Type &amp;)</td></tr>
<tr class="separator:a5fa47a955c47550ec67418f2be478a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a1c9732dd8712749e151d6a5df1b60"><td class="memTemplParams" colspan="2"><a id="a51a1c9732dd8712749e151d6a5df1b60"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51a1c9732dd8712749e151d6a5df1b60"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_concept.html">ST2toT2Concept</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:a51a1c9732dd8712749e151d6a5df1b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5107fdde4aaff7f19cbd82da08dca59"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad5107fdde4aaff7f19cbd82da08dca59"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; T1 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a0178c5e31d405f93fc7dbfade5ada5d5">implementsST2toT2Concept</a>&lt; T2 &gt;) &amp;&amp;!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Handle &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad5107fdde4aaff7f19cbd82da08dca59">operator|</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:ad5107fdde4aaff7f19cbd82da08dca59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4265adf56378e36079f0d2f1358f4550"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename PPType , typename StensorType &gt; </td></tr>
<tr class="memitem:a4265adf56378e36079f0d2f1358f4550"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DPPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; PPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DPPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; PPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DPPType &gt; &gt;::cond, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4265adf56378e36079f0d2f1358f4550">computeStensorPositivePartAndDerivative</a> (DPPType &amp;, PPType &amp;, const StensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;)</td></tr>
<tr class="memdesc:a4265adf56378e36079f0d2f1358f4550"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part.  <a href="#a4265adf56378e36079f0d2f1358f4550">More...</a><br /></td></tr>
<tr class="separator:a4265adf56378e36079f0d2f1358f4550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc45c3738a1ef88b44173ebafb2c85a"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename PPType , typename StensorType &gt; </td></tr>
<tr class="memitem:a1dc45c3738a1ef88b44173ebafb2c85a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DPPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; PPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DPPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; PPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DPPType &gt; &gt;::cond, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1dc45c3738a1ef88b44173ebafb2c85a">computeStensorPositivePartAndDerivative</a> (DPPType &amp;, PPType &amp;, const StensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;)</td></tr>
<tr class="memdesc:a1dc45c3738a1ef88b44173ebafb2c85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part.  <a href="#a1dc45c3738a1ef88b44173ebafb2c85a">More...</a><br /></td></tr>
<tr class="separator:a1dc45c3738a1ef88b44173ebafb2c85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97623187184e8ceaa09e7c1abba413a7"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename PPType , typename StensorType &gt; </td></tr>
<tr class="memitem:a97623187184e8ceaa09e7c1abba413a7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DPPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; PPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DPPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; PPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DPPType &gt; &gt;::cond, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a97623187184e8ceaa09e7c1abba413a7">computeStensorPositivePartAndDerivative</a> (DPPType &amp;, PPType &amp;, const StensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;)</td></tr>
<tr class="memdesc:a97623187184e8ceaa09e7c1abba413a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part.  <a href="#a97623187184e8ceaa09e7c1abba413a7">More...</a><br /></td></tr>
<tr class="separator:a97623187184e8ceaa09e7c1abba413a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef81fed87dcc9d816335a077ad35752"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </td></tr>
<tr class="memitem:a5ef81fed87dcc9d816335a077ad35752"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DPPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DNPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; PPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; NPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DPPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DNPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; PPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; NPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; NPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DPPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DNPType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5ef81fed87dcc9d816335a077ad35752">computeStensorDecompositionInPositiveAndNegativeParts</a> (DPPType &amp;, DNPType &amp;, PPType &amp;, NPType &amp;, const StensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;)</td></tr>
<tr class="memdesc:a5ef81fed87dcc9d816335a077ad35752"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives.  <a href="#a5ef81fed87dcc9d816335a077ad35752">More...</a><br /></td></tr>
<tr class="separator:a5ef81fed87dcc9d816335a077ad35752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987e568afd7dde8e7272c2e8e887236e"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </td></tr>
<tr class="memitem:a987e568afd7dde8e7272c2e8e887236e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DPPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DNPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; PPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; NPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DPPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DNPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; PPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; NPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; NPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DPPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DNPType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a987e568afd7dde8e7272c2e8e887236e">computeStensorDecompositionInPositiveAndNegativeParts</a> (DPPType &amp;, DNPType &amp;, PPType &amp;, NPType &amp;, const StensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;)</td></tr>
<tr class="memdesc:a987e568afd7dde8e7272c2e8e887236e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives.  <a href="#a987e568afd7dde8e7272c2e8e887236e">More...</a><br /></td></tr>
<tr class="separator:a987e568afd7dde8e7272c2e8e887236e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaafe116cda097bc610f2c0f986de95f"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </td></tr>
<tr class="memitem:abaafe116cda097bc610f2c0f986de95f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DPPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DNPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; PPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; NPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DPPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DNPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; PPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; NPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; NPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DPPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DNPType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#abaafe116cda097bc610f2c0f986de95f">computeStensorDecompositionInPositiveAndNegativeParts</a> (DPPType &amp;, DNPType &amp;, PPType &amp;, NPType &amp;, const StensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;)</td></tr>
<tr class="memdesc:abaafe116cda097bc610f2c0f986de95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives.  <a href="#abaafe116cda097bc610f2c0f986de95f">More...</a><br /></td></tr>
<tr class="separator:abaafe116cda097bc610f2c0f986de95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50811a7e2eec21596cfcbe4e85709d6e"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename PPType , typename StensorType &gt; </td></tr>
<tr class="memitem:a50811a7e2eec21596cfcbe4e85709d6e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DPPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; PPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DPPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; PPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DPPType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a50811a7e2eec21596cfcbe4e85709d6e">computeStensorPositivePartAndDerivative</a> (DPPType &amp;dpp, PPType &amp;pp, const StensorType &amp;s, const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; eps)</td></tr>
<tr class="memdesc:a50811a7e2eec21596cfcbe4e85709d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part.  <a href="#a50811a7e2eec21596cfcbe4e85709d6e">More...</a><br /></td></tr>
<tr class="separator:a50811a7e2eec21596cfcbe4e85709d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6560667a2bd69f2ab0cdb3c06aded550"><td class="memTemplParams" colspan="2">template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </td></tr>
<tr class="memitem:a6560667a2bd69f2ab0cdb3c06aded550"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DPPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DNPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; PPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; NPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DPPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DNPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; PPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; NPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==3u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; NPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DPPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DNPType &gt; &gt;::cond, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6560667a2bd69f2ab0cdb3c06aded550">computeStensorDecompositionInPositiveAndNegativeParts</a> (DPPType &amp;dpp, DNPType &amp;dnp, PPType &amp;pp, NPType &amp;np, const StensorType &amp;s, const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; eps)</td></tr>
<tr class="memdesc:a6560667a2bd69f2ab0cdb3c06aded550"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives.  <a href="#a6560667a2bd69f2ab0cdb3c06aded550">More...</a><br /></td></tr>
<tr class="separator:a6560667a2bd69f2ab0cdb3c06aded550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b770e53981e0bf3df3e34269c357df"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ac1b770e53981e0bf3df3e34269c357df"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac1b770e53981e0bf3df3e34269c357df">exportToBaseTypeArray</a> (const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &amp;s, OutputIterator p)</td></tr>
<tr class="separator:ac1b770e53981e0bf3df3e34269c357df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956390f6acfa8185d8420636dc422898"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a956390f6acfa8185d8420636dc422898"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a956390f6acfa8185d8420636dc422898">tresca</a> (const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; 1u, T &gt; &amp;s, const bool)</td></tr>
<tr class="separator:a956390f6acfa8185d8420636dc422898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b78db087c9dbda87742fa94d15e769"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:ad2b78db087c9dbda87742fa94d15e769"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad2b78db087c9dbda87742fa94d15e769">tresca</a> (const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &amp;s, const bool b)</td></tr>
<tr class="separator:ad2b78db087c9dbda87742fa94d15e769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d1530eb55e2d45732a6318f3bda36e"><td class="memTemplParams" colspan="2"><a id="a46d1530eb55e2d45732a6318f3bda36e"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a46d1530eb55e2d45732a6318f3bda36e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>square_root</b> (const StensorType &amp;s)</td></tr>
<tr class="separator:a46d1530eb55e2d45732a6318f3bda36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bbe86ee1935cad1c1daccce7f7b530"><td class="memTemplParams" colspan="2"><a id="ad5bbe86ee1935cad1c1daccce7f7b530"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:ad5bbe86ee1935cad1c1daccce7f7b530"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const StensorType &amp;s)</td></tr>
<tr class="separator:ad5bbe86ee1935cad1c1daccce7f7b530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c411f072aca056925a88853476212aa"><td class="memTemplParams" colspan="2"><a id="a1c411f072aca056925a88853476212aa"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a1c411f072aca056925a88853476212aa"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invert</b> (const StensorType &amp;s)</td></tr>
<tr class="separator:a1c411f072aca056925a88853476212aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac089330f221f90549b5e67e468d20d8a"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:ac089330f221f90549b5e67e468d20d8a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, numeric_type&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac089330f221f90549b5e67e468d20d8a">logarithm</a> (const StensorType &amp;s, const bool)</td></tr>
<tr class="memdesc:ac089330f221f90549b5e67e468d20d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the logarithm of a symmetric tensor  <a href="#ac089330f221f90549b5e67e468d20d8a">More...</a><br /></td></tr>
<tr class="separator:ac089330f221f90549b5e67e468d20d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594e911d65cb8770eb19e7627464ebdd"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a594e911d65cb8770eb19e7627464ebdd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u)||(getSpaceDimension&lt; StensorType &gt;)==3u)) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; getSpaceDimension&lt; StensorType &gt;), numeric_type&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a594e911d65cb8770eb19e7627464ebdd">logarithm</a> (const StensorType &amp;s_, const bool b)</td></tr>
<tr class="memdesc:a594e911d65cb8770eb19e7627464ebdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the logarithm of a symmetric tensor  <a href="#a594e911d65cb8770eb19e7627464ebdd">More...</a><br /></td></tr>
<tr class="separator:a594e911d65cb8770eb19e7627464ebdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d1b3d4dfb55a05fa4373f8279055b9"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a95d1b3d4dfb55a05fa4373f8279055b9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, numeric_type&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a95d1b3d4dfb55a05fa4373f8279055b9">absolute_value</a> (const StensorType &amp;, const bool=false)</td></tr>
<tr class="memdesc:a95d1b3d4dfb55a05fa4373f8279055b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the absolute value of a symmetric tensor  <a href="#a95d1b3d4dfb55a05fa4373f8279055b9">More...</a><br /></td></tr>
<tr class="separator:a95d1b3d4dfb55a05fa4373f8279055b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8081fec1cda633aab4f62e383ceb7ada"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a8081fec1cda633aab4f62e383ceb7ada"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u)||(getSpaceDimension&lt; StensorType &gt;)==3u)) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; getSpaceDimension&lt; StensorType &gt;), numeric_type&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8081fec1cda633aab4f62e383ceb7ada">absolute_value</a> (const StensorType &amp;, const bool=false)</td></tr>
<tr class="memdesc:a8081fec1cda633aab4f62e383ceb7ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the absolute value of a symmetric tensor  <a href="#a8081fec1cda633aab4f62e383ceb7ada">More...</a><br /></td></tr>
<tr class="separator:a8081fec1cda633aab4f62e383ceb7ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2749fbd3f6ae56cbb776156d5115af9"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:ac2749fbd3f6ae56cbb776156d5115af9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, numeric_type&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac2749fbd3f6ae56cbb776156d5115af9">positive_part</a> (const StensorType &amp;, const bool=false)</td></tr>
<tr class="memdesc:ac2749fbd3f6ae56cbb776156d5115af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the positive part of a symmetric tensor  <a href="#ac2749fbd3f6ae56cbb776156d5115af9">More...</a><br /></td></tr>
<tr class="separator:ac2749fbd3f6ae56cbb776156d5115af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6e4027c87851f6b6c07ad6180fd2ee"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a2c6e4027c87851f6b6c07ad6180fd2ee"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u)||(getSpaceDimension&lt; StensorType &gt;)==3u)) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; getSpaceDimension&lt; StensorType &gt;), numeric_type&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2c6e4027c87851f6b6c07ad6180fd2ee">positive_part</a> (const StensorType &amp;, const bool=false)</td></tr>
<tr class="memdesc:a2c6e4027c87851f6b6c07ad6180fd2ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the positive part of a symmetric tensor  <a href="#a2c6e4027c87851f6b6c07ad6180fd2ee">More...</a><br /></td></tr>
<tr class="separator:a2c6e4027c87851f6b6c07ad6180fd2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcaaecc493cdabdcfe86fe46983b33e"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a4dcaaecc493cdabdcfe86fe46983b33e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, numeric_type&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4dcaaecc493cdabdcfe86fe46983b33e">negative_part</a> (const StensorType &amp;, const bool=false)</td></tr>
<tr class="memdesc:a4dcaaecc493cdabdcfe86fe46983b33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the negative part of a symmetric tensor  <a href="#a4dcaaecc493cdabdcfe86fe46983b33e">More...</a><br /></td></tr>
<tr class="separator:a4dcaaecc493cdabdcfe86fe46983b33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4485a13170a338345bca7b8641e694e8"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a4485a13170a338345bca7b8641e694e8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u)||(getSpaceDimension&lt; StensorType &gt;)==3u)) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; getSpaceDimension&lt; StensorType &gt;), numeric_type&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4485a13170a338345bca7b8641e694e8">negative_part</a> (const StensorType &amp;, const bool=false)</td></tr>
<tr class="memdesc:a4485a13170a338345bca7b8641e694e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the negative part of a symmetric tensor  <a href="#a4485a13170a338345bca7b8641e694e8">More...</a><br /></td></tr>
<tr class="separator:a4485a13170a338345bca7b8641e694e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99f8a0e285e6a533b479bb940b5873d"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:ae99f8a0e285e6a533b479bb940b5873d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u, stensor&lt; 1u, typename ComputeBinaryResult&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; StensorType &gt;, OpMult &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae99f8a0e285e6a533b479bb940b5873d">square</a> (const StensorType &amp;s)</td></tr>
<tr class="separator:ae99f8a0e285e6a533b479bb940b5873d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588d51c77222cf153592863162f3a23a"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a588d51c77222cf153592863162f3a23a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u, stensor&lt; 2u, typename ComputeBinaryResult&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; StensorType &gt;, OpMult &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a588d51c77222cf153592863162f3a23a">square</a> (const StensorType &amp;s)</td></tr>
<tr class="separator:a588d51c77222cf153592863162f3a23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d40223c816e1a7bb39cd2f1041a6f4"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a90d40223c816e1a7bb39cd2f1041a6f4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==3u, stensor&lt; 3u, typename ComputeBinaryResult&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; StensorType &gt;, OpMult &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a90d40223c816e1a7bb39cd2f1041a6f4">square</a> (const StensorType &amp;s)</td></tr>
<tr class="separator:a90d40223c816e1a7bb39cd2f1041a6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afa916e14d5a0de64678108a5f05163"><td class="memTemplParams" colspan="2"><a id="a5afa916e14d5a0de64678108a5f05163"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a5afa916e14d5a0de64678108a5f05163"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>change_basis</b> (const StensorType &amp;s, const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3u, 3u, base_type&lt; numeric_type&lt; StensorType &gt;&gt;&gt; &amp;r)</td></tr>
<tr class="separator:a5afa916e14d5a0de64678108a5f05163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b82be6fc5983001efb1ded3aa3fd71"><td class="memTemplParams" colspan="2">template&lt;typename stensor_common::EigenSolver es, typename Function , typename StensorType &gt; </td></tr>
<tr class="memitem:a95b82be6fc5983001efb1ded3aa3fd71"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a95b82be6fc5983001efb1ded3aa3fd71">computeIsotropicFunction</a> (const Function &amp;f, const StensorType &amp;s, const bool b)</td></tr>
<tr class="separator:a95b82be6fc5983001efb1ded3aa3fd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41154073d187923d273ce8f09789b1a7"><td class="memTemplParams" colspan="2">template&lt;typename stensor_common::EigenSolver es, typename Function , typename FunctionDerivative , typename StensorType &gt; </td></tr>
<tr class="memitem:a41154073d187923d273ce8f09789b1a7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a41154073d187923d273ce8f09789b1a7">computeIsotropicFunctionDerivative</a> (const Function &amp;f, const FunctionDerivative &amp;df, const StensorType &amp;s, const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; eps, const bool b)</td></tr>
<tr class="separator:a41154073d187923d273ce8f09789b1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63608e2087a9dc5870e39d96df810d6"><td class="memTemplParams" colspan="2">template&lt;typename stensor_common::EigenSolver es, typename Function , typename FunctionDerivative , typename StensorType &gt; </td></tr>
<tr class="memitem:ad63608e2087a9dc5870e39d96df810d6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), std::pair&lt; <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad63608e2087a9dc5870e39d96df810d6">computeIsotropicFunctionDerivative</a> (const Function &amp;f, const FunctionDerivative &amp;df, const StensorType &amp;s, const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; eps, const bool b)</td></tr>
<tr class="separator:ad63608e2087a9dc5870e39d96df810d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f691d19432165784cf9244cde14fd0e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a0f691d19432165784cf9244cde14fd0e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T &gt;)==1u) &amp;&amp;(implementsStensorConcept&lt; T2 &gt;)) &amp;&amp;(getSpaceDimension&lt; T2 &gt;)==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, numeric_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0f691d19432165784cf9244cde14fd0e">convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress</a> (const T &amp;s, const T2 &amp;U)</td></tr>
<tr class="memdesc:a0f691d19432165784cf9244cde14fd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a0f691d19432165784cf9244cde14fd0e">More...</a><br /></td></tr>
<tr class="separator:a0f691d19432165784cf9244cde14fd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53200c8ef0a8447da9392a83d72b3b06"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a53200c8ef0a8447da9392a83d72b3b06"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T &gt;)==2u) &amp;&amp;(implementsStensorConcept&lt; T2 &gt;)) &amp;&amp;(getSpaceDimension&lt; T2 &gt;)==2u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, numeric_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a53200c8ef0a8447da9392a83d72b3b06">convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress</a> (const T &amp;s, const T2 &amp;U)</td></tr>
<tr class="memdesc:a53200c8ef0a8447da9392a83d72b3b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a53200c8ef0a8447da9392a83d72b3b06">More...</a><br /></td></tr>
<tr class="separator:a53200c8ef0a8447da9392a83d72b3b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0359ce444207d45ed70c6850be838d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a6f0359ce444207d45ed70c6850be838d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T &gt;)==3u) &amp;&amp;(implementsStensorConcept&lt; T2 &gt;)) &amp;&amp;(getSpaceDimension&lt; T2 &gt;)==3u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, numeric_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6f0359ce444207d45ed70c6850be838d">convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress</a> (const T &amp;s, const T2 &amp;U)</td></tr>
<tr class="memdesc:a6f0359ce444207d45ed70c6850be838d"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a6f0359ce444207d45ed70c6850be838d">More...</a><br /></td></tr>
<tr class="separator:a6f0359ce444207d45ed70c6850be838d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa319105825cf1e9bde644773a2f73b18"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:aa319105825cf1e9bde644773a2f73b18"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T &gt;)==1u) &amp;&amp;(implementsStensorConcept&lt; T2 &gt;)) &amp;&amp;(getSpaceDimension&lt; T2 &gt;)==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, numeric_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa319105825cf1e9bde644773a2f73b18">convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress</a> (const T &amp;S, const T2 &amp;U)</td></tr>
<tr class="memdesc:aa319105825cf1e9bde644773a2f73b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#aa319105825cf1e9bde644773a2f73b18">More...</a><br /></td></tr>
<tr class="separator:aa319105825cf1e9bde644773a2f73b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec1c73a8d6a4bdc61f8021c10220370"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a5ec1c73a8d6a4bdc61f8021c10220370"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T &gt;)==2u) &amp;&amp;(implementsStensorConcept&lt; T2 &gt;)) &amp;&amp;(getSpaceDimension&lt; T2 &gt;)==2u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, numeric_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5ec1c73a8d6a4bdc61f8021c10220370">convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress</a> (const T &amp;S, const T2 &amp;U)</td></tr>
<tr class="memdesc:a5ec1c73a8d6a4bdc61f8021c10220370"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a5ec1c73a8d6a4bdc61f8021c10220370">More...</a><br /></td></tr>
<tr class="separator:a5ec1c73a8d6a4bdc61f8021c10220370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf7a7700bcb2bbf31d84118b7f16e2f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a3bf7a7700bcb2bbf31d84118b7f16e2f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T &gt;)==3u) &amp;&amp;(implementsStensorConcept&lt; T2 &gt;)) &amp;&amp;(getSpaceDimension&lt; T2 &gt;)==3u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, numeric_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3bf7a7700bcb2bbf31d84118b7f16e2f">convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress</a> (const T &amp;S, const T2 &amp;U)</td></tr>
<tr class="memdesc:a3bf7a7700bcb2bbf31d84118b7f16e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a3bf7a7700bcb2bbf31d84118b7f16e2f">More...</a><br /></td></tr>
<tr class="separator:a3bf7a7700bcb2bbf31d84118b7f16e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49d41abdab92f2fa9cf640a58e062eb"><td class="memTemplParams" colspan="2">template&lt;typename StensorType1 , typename StensorType2 &gt; </td></tr>
<tr class="memitem:aa49d41abdab92f2fa9cf640a58e062eb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType1 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType2 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType1 &gt;)==1u) &amp;&amp;(getSpaceDimension&lt; StensorType2 &gt;)==1u)), stensor&lt; 3u, typename ResultType&lt; numeric_type&lt; StensorType1 &gt;, numeric_type&lt; StensorType2 &gt;, OpMult &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa49d41abdab92f2fa9cf640a58e062eb">symmetric_product</a> (const StensorType1 &amp;, const StensorType2 &amp;)</td></tr>
<tr class="memdesc:aa49d41abdab92f2fa9cf640a58e062eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the symmetric product of two stensors as a symmetric tensor </p><p class="formulaDsp">
\[ s1*s2+s2*s1 \]
</p>
  <a href="#aa49d41abdab92f2fa9cf640a58e062eb">More...</a><br /></td></tr>
<tr class="separator:aa49d41abdab92f2fa9cf640a58e062eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4565d4b43e42afedf1b1facb1d9827"><td class="memTemplParams" colspan="2">template&lt;typename StensorType1 , typename StensorType2 &gt; </td></tr>
<tr class="memitem:afc4565d4b43e42afedf1b1facb1d9827"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType1 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType2 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType1 &gt;)==2u) &amp;&amp;(getSpaceDimension&lt; StensorType2 &gt;)==2u)), stensor&lt; 2u, typename ResultType&lt; numeric_type&lt; StensorType1 &gt;, numeric_type&lt; StensorType2 &gt;, OpMult &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#afc4565d4b43e42afedf1b1facb1d9827">symmetric_product</a> (const StensorType1 &amp;, const StensorType2 &amp;)</td></tr>
<tr class="memdesc:afc4565d4b43e42afedf1b1facb1d9827"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the symmetric product of two stensors as a symmetric tensor: </p><p class="formulaDsp">
\[ s1*s2+s2*s1 \]
</p>
  <a href="#afc4565d4b43e42afedf1b1facb1d9827">More...</a><br /></td></tr>
<tr class="separator:afc4565d4b43e42afedf1b1facb1d9827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57a2ed542f171333483de8b7d71d724"><td class="memTemplParams" colspan="2">template&lt;typename StensorType1 , typename StensorType2 &gt; </td></tr>
<tr class="memitem:ad57a2ed542f171333483de8b7d71d724"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType1 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType2 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType1 &gt;)==3u) &amp;&amp;(getSpaceDimension&lt; StensorType2 &gt;)==3u)), stensor&lt; 3u, typename ResultType&lt; numeric_type&lt; StensorType1 &gt;, numeric_type&lt; StensorType2 &gt;, OpMult &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad57a2ed542f171333483de8b7d71d724">symmetric_product</a> (const StensorType1 &amp;, const StensorType2 &amp;)</td></tr>
<tr class="memdesc:ad57a2ed542f171333483de8b7d71d724"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the symmetric product of two stensors as a symmetric tensor </p><p class="formulaDsp">
\[ s1*s2+s2*s1 \]
</p>
  <a href="#ad57a2ed542f171333483de8b7d71d724">More...</a><br /></td></tr>
<tr class="separator:ad57a2ed542f171333483de8b7d71d724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bc48f30c8fed1b8168174b544f9859"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:ac4bc48f30c8fed1b8168174b544f9859"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac4bc48f30c8fed1b8168174b544f9859">computeDeterminantDerivative</a> (const StensorType &amp;s)</td></tr>
<tr class="separator:ac4bc48f30c8fed1b8168174b544f9859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23f6c82a8f24e6c16c644fa9078a0a9"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:af23f6c82a8f24e6c16c644fa9078a0a9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af23f6c82a8f24e6c16c644fa9078a0a9">computeDeviatorDeterminantDerivative</a> (const StensorType &amp;s)</td></tr>
<tr class="separator:af23f6c82a8f24e6c16c644fa9078a0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c098d789adbbac9dc1af953b4c5ba27"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a4c098d789adbbac9dc1af953b4c5ba27"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a> ()</td></tr>
<tr class="memdesc:a4c098d789adbbac9dc1af953b4c5ba27"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a></code>.  <a href="#a4c098d789adbbac9dc1af953b4c5ba27">More...</a><br /></td></tr>
<tr class="separator:a4c098d789adbbac9dc1af953b4c5ba27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085b6d7d59fda78126e3437db00443e8"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a085b6d7d59fda78126e3437db00443e8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a085b6d7d59fda78126e3437db00443e8">abs</a> (const StensorType &amp;)</td></tr>
<tr class="separator:a085b6d7d59fda78126e3437db00443e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7798d5763f3e45187fffdd5a5edbc0b0"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a7798d5763f3e45187fffdd5a5edbc0b0"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7798d5763f3e45187fffdd5a5edbc0b0">trace</a> (const StensorType &amp;)</td></tr>
<tr class="separator:a7798d5763f3e45187fffdd5a5edbc0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3159288830267591720ed8bfdca8d9db"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a3159288830267591720ed8bfdca8d9db"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3159288830267591720ed8bfdca8d9db">sigmaeq</a> (const StensorType &amp;)</td></tr>
<tr class="separator:a3159288830267591720ed8bfdca8d9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37444837cda7a92cff9cf482eb93c722"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a37444837cda7a92cff9cf482eb93c722"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#af77fbcb0679a70e562fe1e0f10f5e61c">EvaluationResult</a>&lt; StensorType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a37444837cda7a92cff9cf482eb93c722">deviator</a> (const StensorType &amp;)</td></tr>
<tr class="separator:a37444837cda7a92cff9cf482eb93c722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe30dbf021798da2b686fac6763c127"><td class="memItemLeft" align="right" valign="top">TFELMATH_VISIBILITY_EXPORT unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#abfe30dbf021798da2b686fac6763c127">getStensorSize</a> (const unsigned short)</td></tr>
<tr class="memdesc:abfe30dbf021798da2b686fac6763c127"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the size of a symmetric tensor for the given dimension  <a href="#abfe30dbf021798da2b686fac6763c127">More...</a><br /></td></tr>
<tr class="separator:abfe30dbf021798da2b686fac6763c127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9de733baac066421cc5c9d577b8367"><td class="memTemplParams" colspan="2">template&lt;typename StensorResultType , typename StensorType &gt; </td></tr>
<tr class="memitem:a9b9de733baac066421cc5c9d577b8367"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorResultType &gt; &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9b9de733baac066421cc5c9d577b8367">computeDeterminantDerivative</a> (StensorResultType &amp;, const StensorType &amp;)</td></tr>
<tr class="memdesc:a9b9de733baac066421cc5c9d577b8367"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="#a9b9de733baac066421cc5c9d577b8367">More...</a><br /></td></tr>
<tr class="separator:a9b9de733baac066421cc5c9d577b8367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60da59c3c50f7be9b71433847e9a3c2"><td class="memTemplParams" colspan="2">template&lt;typename StensorResultType , typename StensorType &gt; </td></tr>
<tr class="memitem:af60da59c3c50f7be9b71433847e9a3c2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorResultType &gt; &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af60da59c3c50f7be9b71433847e9a3c2">computeDeviatorDeterminantDerivative</a> (StensorResultType &amp;, const StensorType &amp;)</td></tr>
<tr class="memdesc:af60da59c3c50f7be9b71433847e9a3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="#af60da59c3c50f7be9b71433847e9a3c2">More...</a><br /></td></tr>
<tr class="separator:af60da59c3c50f7be9b71433847e9a3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbbb935b9c9751cc73b9da3e9a314c8"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a5bbbb935b9c9751cc73b9da3e9a314c8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5bbbb935b9c9751cc73b9da3e9a314c8">trace</a> (const StensorType &amp;s)</td></tr>
<tr class="separator:a5bbbb935b9c9751cc73b9da3e9a314c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b980d05e09c20fd34c7e1ab744898b"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a51b980d05e09c20fd34c7e1ab744898b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a51b980d05e09c20fd34c7e1ab744898b">sigmaeq</a> (const StensorType &amp;s)</td></tr>
<tr class="separator:a51b980d05e09c20fd34c7e1ab744898b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a6e326869ee581a702c71f809ae43a"><td class="memTemplParams" colspan="2"><a id="ac0a6e326869ee581a702c71f809ae43a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0a6e326869ee581a702c71f809ae43a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac0a6e326869ee581a702c71f809ae43a">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:ac0a6e326869ee581a702c71f809ae43a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialisation operator. <br /></td></tr>
<tr class="separator:ac0a6e326869ee581a702c71f809ae43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9692f591f3005f80756e42cfbadebc0b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a9692f591f3005f80756e42cfbadebc0b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T1 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T1 &gt;)==1u &amp;&amp;getSpaceDimension&lt; T2 &gt;)==1u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9692f591f3005f80756e42cfbadebc0b">operator|</a> (const T1 &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a9692f591f3005f80756e42cfbadebc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af585e46dd234e0b0dd291dfd20028d4c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af585e46dd234e0b0dd291dfd20028d4c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T1 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T1 &gt;)==2u &amp;&amp;getSpaceDimension&lt; T2 &gt;)==2u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af585e46dd234e0b0dd291dfd20028d4c">operator|</a> (const T1 &amp;, const T2 &amp;)</td></tr>
<tr class="separator:af585e46dd234e0b0dd291dfd20028d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9812d2b7dfd0fc2e31c4ad31cc92f94a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a9812d2b7dfd0fc2e31c4ad31cc92f94a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T1 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T1 &gt;)==3u &amp;&amp;getSpaceDimension&lt; T2 &gt;)==3u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; T1, T2, OpDotProduct &gt;::Result &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9812d2b7dfd0fc2e31c4ad31cc92f94a">operator|</a> (const T1 &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a9812d2b7dfd0fc2e31c4ad31cc92f94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbccaf104544092a9ea902a4024a522"><td class="memTemplParams" colspan="2"><a id="addbccaf104544092a9ea902a4024a522"></a>
template&lt;typename StensorType1 , typename StensorType2 &gt; </td></tr>
<tr class="memitem:addbccaf104544092a9ea902a4024a522"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType1 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType1 &gt;)==1u &amp;&amp;getSpaceDimension&lt; StensorType2 &gt;)==1u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; StensorType1, StensorType2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; StensorType1, StensorType2, OpDotProduct &gt;::Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const StensorType1 &amp;a, const StensorType2 &amp;b)</td></tr>
<tr class="separator:addbccaf104544092a9ea902a4024a522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549fb2c52063887b7e1d680022f237ad"><td class="memTemplParams" colspan="2"><a id="a549fb2c52063887b7e1d680022f237ad"></a>
template&lt;typename StensorType1 , typename StensorType2 &gt; </td></tr>
<tr class="memitem:a549fb2c52063887b7e1d680022f237ad"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType1 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType1 &gt;)==2u &amp;&amp;getSpaceDimension&lt; StensorType2 &gt;)==2u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; StensorType1, StensorType2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; StensorType1, StensorType2, OpDotProduct &gt;::Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const StensorType1 &amp;a, const StensorType2 &amp;b)</td></tr>
<tr class="separator:a549fb2c52063887b7e1d680022f237ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a2e38d096990404c52f4f7cdcc086e"><td class="memTemplParams" colspan="2"><a id="a82a2e38d096990404c52f4f7cdcc086e"></a>
template&lt;typename StensorType1 , typename StensorType2 &gt; </td></tr>
<tr class="memitem:a82a2e38d096990404c52f4f7cdcc086e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType1 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType1 &gt;)==3u &amp;&amp;getSpaceDimension&lt; StensorType2 &gt;)==3u &amp;&amp;!tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt; StensorType1, StensorType2, OpDotProduct &gt;::Result &gt;::cond, typename ComputeBinaryResult&lt; StensorType1, StensorType2, OpDotProduct &gt;::Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const StensorType1 &amp;a, const StensorType2 &amp;b)</td></tr>
<tr class="separator:a82a2e38d096990404c52f4f7cdcc086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a868de1c98c494756b5a1be0a864ca9"><td class="memTemplParams" colspan="2"><a id="a3a868de1c98c494756b5a1be0a864ca9"></a>
template&lt;typename StensorType1 , typename StensorType2 &gt; </td></tr>
<tr class="memitem:a3a868de1c98c494756b5a1be0a864ca9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>symmetric_product_aba</b> (const StensorType1 &amp;a, const StensorType2 &amp;b) -&gt; typename std::enable_if&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType1 &gt;())&amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType2 &gt;())&amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType1 &gt;()==1u)&amp;&amp;(getSpaceDimension&lt; StensorType2 &gt;()==1u)), stensor&lt; 1u, decltype(a[0] *b[0] *a[0])&gt;&gt;::type</td></tr>
<tr class="separator:a3a868de1c98c494756b5a1be0a864ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f058f2ba579764f989886f5d2204cd"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a51f058f2ba579764f989886f5d2204cd"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a51f058f2ba579764f989886f5d2204cd">change_basis</a> (const StensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;&gt; &amp;)</td></tr>
<tr class="memdesc:a51f058f2ba579764f989886f5d2204cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotate a symmetric tensor using a rotation matrix  <a href="#a51f058f2ba579764f989886f5d2204cd">More...</a><br /></td></tr>
<tr class="separator:a51f058f2ba579764f989886f5d2204cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a67f43dab4f94e3f7a172984841e9b"><td class="memTemplParams" colspan="2"><a id="a10a67f43dab4f94e3f7a172984841e9b"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a10a67f43dab4f94e3f7a172984841e9b"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>invert</b> (const StensorType &amp;)</td></tr>
<tr class="separator:a10a67f43dab4f94e3f7a172984841e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16dde7f5526001ceb060ac2ee922bad7"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a16dde7f5526001ceb060ac2ee922bad7"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, numeric_type&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a16dde7f5526001ceb060ac2ee922bad7">logarithm</a> (const StensorType &amp;, const bool=false)</td></tr>
<tr class="memdesc:a16dde7f5526001ceb060ac2ee922bad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the logarithm of a symmetric tensor  <a href="#a16dde7f5526001ceb060ac2ee922bad7">More...</a><br /></td></tr>
<tr class="separator:a16dde7f5526001ceb060ac2ee922bad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1459e865f0ecd60229c9ba2777cf30b4"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a1459e865f0ecd60229c9ba2777cf30b4"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u)||(getSpaceDimension&lt; StensorType &gt;)==3u)) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; getSpaceDimension&lt; StensorType &gt;), numeric_type&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1459e865f0ecd60229c9ba2777cf30b4">logarithm</a> (const StensorType &amp;, const bool=false)</td></tr>
<tr class="memdesc:a1459e865f0ecd60229c9ba2777cf30b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the logarithm of a symmetric tensor  <a href="#a1459e865f0ecd60229c9ba2777cf30b4">More...</a><br /></td></tr>
<tr class="separator:a1459e865f0ecd60229c9ba2777cf30b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1a7c23d454975e920f67292f6166c4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a5f1a7c23d454975e920f67292f6166c4"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T &gt;)==1u) &amp;&amp;(implementsStensorConcept&lt; T2 &gt;)) &amp;&amp;(getSpaceDimension&lt; T2 &gt;)==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, numeric_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5f1a7c23d454975e920f67292f6166c4">convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="memdesc:a5f1a7c23d454975e920f67292f6166c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a5f1a7c23d454975e920f67292f6166c4">More...</a><br /></td></tr>
<tr class="separator:a5f1a7c23d454975e920f67292f6166c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0656220b299ad4e90cedbbc859795c95"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a0656220b299ad4e90cedbbc859795c95"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T &gt;)==2u) &amp;&amp;(implementsStensorConcept&lt; T2 &gt;)) &amp;&amp;(getSpaceDimension&lt; T2 &gt;)==2u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, numeric_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0656220b299ad4e90cedbbc859795c95">convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="memdesc:a0656220b299ad4e90cedbbc859795c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a0656220b299ad4e90cedbbc859795c95">More...</a><br /></td></tr>
<tr class="separator:a0656220b299ad4e90cedbbc859795c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7848eac865ac7a03f5a066bbbb84b7ef"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a7848eac865ac7a03f5a066bbbb84b7ef"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T &gt;)==3u) &amp;&amp;(implementsStensorConcept&lt; T2 &gt;)) &amp;&amp;(getSpaceDimension&lt; T2 &gt;)==3u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, numeric_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7848eac865ac7a03f5a066bbbb84b7ef">convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="memdesc:a7848eac865ac7a03f5a066bbbb84b7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a7848eac865ac7a03f5a066bbbb84b7ef">More...</a><br /></td></tr>
<tr class="separator:a7848eac865ac7a03f5a066bbbb84b7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213f38bbf9ab17938a77246991925d71"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a213f38bbf9ab17938a77246991925d71"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T &gt;)==1u) &amp;&amp;(implementsStensorConcept&lt; T2 &gt;)) &amp;&amp;(getSpaceDimension&lt; T2 &gt;)==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; T2 &gt; &gt;::cond)), stensor&lt; 1u, numeric_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a213f38bbf9ab17938a77246991925d71">convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="memdesc:a213f38bbf9ab17938a77246991925d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a213f38bbf9ab17938a77246991925d71">More...</a><br /></td></tr>
<tr class="separator:a213f38bbf9ab17938a77246991925d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9970951902efc0e635ffe55dc21a7ead"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a9970951902efc0e635ffe55dc21a7ead"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T &gt;)==2u) &amp;&amp;(implementsStensorConcept&lt; T2 &gt;)) &amp;&amp;(getSpaceDimension&lt; T2 &gt;)==2u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; T2 &gt; &gt;::cond)), stensor&lt; 2u, numeric_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9970951902efc0e635ffe55dc21a7ead">convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="memdesc:a9970951902efc0e635ffe55dc21a7ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a9970951902efc0e635ffe55dc21a7ead">More...</a><br /></td></tr>
<tr class="separator:a9970951902efc0e635ffe55dc21a7ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4122960126737bee5dc4be477c2d304c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a4122960126737bee5dc4be477c2d304c"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T &gt;)==3u) &amp;&amp;(implementsStensorConcept&lt; T2 &gt;)) &amp;&amp;(getSpaceDimension&lt; T2 &gt;)==3u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; T2 &gt; &gt;::cond)), stensor&lt; 3u, numeric_type&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4122960126737bee5dc4be477c2d304c">convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress</a> (const T &amp;, const T2 &amp;)</td></tr>
<tr class="memdesc:a4122960126737bee5dc4be477c2d304c"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
  <a href="#a4122960126737bee5dc4be477c2d304c">More...</a><br /></td></tr>
<tr class="separator:a4122960126737bee5dc4be477c2d304c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78fe00c681ff46339dec85d0759c2d9"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:ad78fe00c681ff46339dec85d0759c2d9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toT2Type &gt;)==1u) &amp;&amp;implementsT2toT2Concept&lt; T2toT2Type &gt;)), t2tost2&lt; 1u, numeric_type&lt; T2toT2Type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad78fe00c681ff46339dec85d0759c2d9">convertToT2toST2</a> (const T2toT2Type &amp;t)</td></tr>
<tr class="separator:ad78fe00c681ff46339dec85d0759c2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7a5a0e31742130e108506ba579c312"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:a6f7a5a0e31742130e108506ba579c312"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toT2Type &gt;)==2u) &amp;&amp;implementsT2toT2Concept&lt; T2toT2Type &gt;)), t2tost2&lt; 2u, numeric_type&lt; T2toT2Type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6f7a5a0e31742130e108506ba579c312">convertToT2toST2</a> (const T2toT2Type &amp;t)</td></tr>
<tr class="separator:a6f7a5a0e31742130e108506ba579c312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38af0aa5982cdefbba8a050e7c5dd30"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:ab38af0aa5982cdefbba8a050e7c5dd30"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toT2Type &gt;)==3u) &amp;&amp;implementsT2toT2Concept&lt; T2toT2Type &gt;)), t2tost2&lt; 3u, numeric_type&lt; T2toT2Type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab38af0aa5982cdefbba8a050e7c5dd30">convertToT2toST2</a> (const T2toT2Type &amp;t)</td></tr>
<tr class="separator:ab38af0aa5982cdefbba8a050e7c5dd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e3d77920aa3d04c4930dbf4cf04890"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a14e3d77920aa3d04c4930dbf4cf04890"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==1u), t2tost2&lt; 1u, numeric_type&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a14e3d77920aa3d04c4930dbf4cf04890">computeRateOfDeformationDerivative</a> (const TensorType &amp;F)</td></tr>
<tr class="separator:a14e3d77920aa3d04c4930dbf4cf04890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2e2188caf4906eb42a0aae4bd4f912"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:ada2e2188caf4906eb42a0aae4bd4f912"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==2u), t2tost2&lt; 2u, numeric_type&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ada2e2188caf4906eb42a0aae4bd4f912">computeRateOfDeformationDerivative</a> (const TensorType &amp;F)</td></tr>
<tr class="separator:ada2e2188caf4906eb42a0aae4bd4f912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7238e18fd93e6ecad55e2f43c1baf4c5"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a7238e18fd93e6ecad55e2f43c1baf4c5"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==3u), t2tost2&lt; 3u, numeric_type&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7238e18fd93e6ecad55e2f43c1baf4c5">computeRateOfDeformationDerivative</a> (const TensorType &amp;F)</td></tr>
<tr class="separator:a7238e18fd93e6ecad55e2f43c1baf4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16d930cb30282a40d1d77d65ff03a79"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:ac16d930cb30282a40d1d77d65ff03a79"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac16d930cb30282a40d1d77d65ff03a79">computeCauchyStressDerivativeFromKirchhoffStressDerivative</a> (const T2toST2Type &amp;, const StensorType &amp;, const TensorType &amp;)</td></tr>
<tr class="memdesc:ac16d930cb30282a40d1d77d65ff03a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Cauchy stress derivative from the Kirchhoff stress derivative  <a href="#ac16d930cb30282a40d1d77d65ff03a79">More...</a><br /></td></tr>
<tr class="separator:ac16d930cb30282a40d1d77d65ff03a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedeb1ec5f7ff7879b81d46ec9f202b25"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:aedeb1ec5f7ff7879b81d46ec9f202b25"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aedeb1ec5f7ff7879b81d46ec9f202b25">computeKirchhoffStressDerivativeFromCauchyStressDerivative</a> (const T2toST2Type &amp;, const StensorType &amp;, const TensorType &amp;)</td></tr>
<tr class="memdesc:aedeb1ec5f7ff7879b81d46ec9f202b25"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Cauchy stress derivative from the Kirchhoff stress derivative  <a href="#aedeb1ec5f7ff7879b81d46ec9f202b25">More...</a><br /></td></tr>
<tr class="separator:aedeb1ec5f7ff7879b81d46ec9f202b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa8a94975a47a18f8c2d8fea0846460"><td class="memTemplParams" colspan="2"><a id="a4aa8a94975a47a18f8c2d8fea0846460"></a>
template&lt;typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:a4aa8a94975a47a18f8c2d8fea0846460"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computePushForwardDerivative</b> (const T2toST2Type &amp;K, const StensorType &amp;S, const TensorType &amp;F)</td></tr>
<tr class="separator:a4aa8a94975a47a18f8c2d8fea0846460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4773b39cfd8bb4428265941a317c0d"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2Type &gt; </td></tr>
<tr class="memitem:a6c4773b39cfd8bb4428265941a317c0d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;)==1u)), t2tost2&lt; 1u, numeric_type&lt; T2toST2Type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6c4773b39cfd8bb4428265941a317c0d">change_basis</a> (const T2toST2Type &amp;s, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;&gt; &amp;)</td></tr>
<tr class="separator:a6c4773b39cfd8bb4428265941a317c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fcf6fb8e901b3db130cbcb4d3d5bfc"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2Type &gt; </td></tr>
<tr class="memitem:a80fcf6fb8e901b3db130cbcb4d3d5bfc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;) !=1u)), t2tost2&lt; getSpaceDimension&lt; T2toST2Type &gt;), numeric_type&lt; T2toST2Type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a80fcf6fb8e901b3db130cbcb4d3d5bfc">change_basis</a> (const T2toST2Type &amp;s, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;&gt; &amp;r)</td></tr>
<tr class="separator:a80fcf6fb8e901b3db130cbcb4d3d5bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a2225d9c9e564112e9f173838042a6"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2Type &gt; </td></tr>
<tr class="memitem:af2a2225d9c9e564112e9f173838042a6"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a> ()</td></tr>
<tr class="memdesc:af2a2225d9c9e564112e9f173838042a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a></code>.  <a href="#af2a2225d9c9e564112e9f173838042a6">More...</a><br /></td></tr>
<tr class="separator:af2a2225d9c9e564112e9f173838042a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7321215b0ebadaae5a3014e35c5f46f2"><td class="memTemplParams" colspan="2"><a id="a7321215b0ebadaae5a3014e35c5f46f2"></a>
template&lt;typename T2toST2Type &gt; </td></tr>
<tr class="memitem:a7321215b0ebadaae5a3014e35c5f46f2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;), typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt; &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const T2toST2Type &amp;)</td></tr>
<tr class="separator:a7321215b0ebadaae5a3014e35c5f46f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b583fdf3548912d7cfa9142b3313f6"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:a13b583fdf3548912d7cfa9142b3313f6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2ResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==1u &amp;&amp;getSpaceDimension&lt; T2toST2Type &gt;)==1u &amp;&amp;getSpaceDimension&lt; StensorType &gt;)==1u &amp;&amp;getSpaceDimension&lt; TensorType &gt;)==1u &amp;&amp;tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; TensorType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeBinaryResult&lt; numeric_type&lt; T2toST2Type &gt;, numeric_type&lt; StensorType &gt;, OpPlus &gt;::Result, numeric_type&lt; T2toST2ResultType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a13b583fdf3548912d7cfa9142b3313f6">computePushForwardDerivative</a> (T2toST2ResultType &amp;, const T2toST2Type &amp;, const StensorType &amp;, const TensorType &amp;)</td></tr>
<tr class="memdesc:a13b583fdf3548912d7cfa9142b3313f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient knowing the value of this derivative in the initial configuration.  <a href="#a13b583fdf3548912d7cfa9142b3313f6">More...</a><br /></td></tr>
<tr class="separator:a13b583fdf3548912d7cfa9142b3313f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3555b49b9ca6aece066d4bd0e06b163f"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:a3555b49b9ca6aece066d4bd0e06b163f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2ResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==2u &amp;&amp;getSpaceDimension&lt; T2toST2Type &gt;)==2u &amp;&amp;getSpaceDimension&lt; StensorType &gt;)==2u &amp;&amp;getSpaceDimension&lt; TensorType &gt;)==2u &amp;&amp;tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; TensorType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeBinaryResult&lt; numeric_type&lt; T2toST2Type &gt;, numeric_type&lt; StensorType &gt;, OpPlus &gt;::Result, numeric_type&lt; T2toST2ResultType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3555b49b9ca6aece066d4bd0e06b163f">computePushForwardDerivative</a> (T2toST2ResultType &amp;, const T2toST2Type &amp;, const StensorType &amp;, const TensorType &amp;)</td></tr>
<tr class="memdesc:a3555b49b9ca6aece066d4bd0e06b163f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient knowing the value of this derivative in the initial configuration.  <a href="#a3555b49b9ca6aece066d4bd0e06b163f">More...</a><br /></td></tr>
<tr class="separator:a3555b49b9ca6aece066d4bd0e06b163f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cdbd1f152a98b46f4032da97da159c"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:af7cdbd1f152a98b46f4032da97da159c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2ResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==3u &amp;&amp;getSpaceDimension&lt; T2toST2Type &gt;)==3u &amp;&amp;getSpaceDimension&lt; StensorType &gt;)==3u &amp;&amp;getSpaceDimension&lt; TensorType &gt;)==3u &amp;&amp;tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; TensorType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeBinaryResult&lt; numeric_type&lt; T2toST2Type &gt;, numeric_type&lt; StensorType &gt;, OpPlus &gt;::Result, numeric_type&lt; T2toST2ResultType &gt; &gt;::cond, void &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af7cdbd1f152a98b46f4032da97da159c">computePushForwardDerivative</a> (T2toST2ResultType &amp;, const T2toST2Type &amp;, const StensorType &amp;, const TensorType &amp;)</td></tr>
<tr class="memdesc:af7cdbd1f152a98b46f4032da97da159c"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient knowing the value of this derivative in the initial configuration.  <a href="#af7cdbd1f152a98b46f4032da97da159c">More...</a><br /></td></tr>
<tr class="separator:af7cdbd1f152a98b46f4032da97da159c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83c0c88dc13f3a63b043829e9476d85"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:ae83c0c88dc13f3a63b043829e9476d85"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2ResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2ResultType &gt; &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae83c0c88dc13f3a63b043829e9476d85">computeCauchyStressDerivativeFromKirchhoffStressDerivative</a> (T2toST2ResultType &amp;, const T2toST2Type &amp;, const StensorType &amp;, const TensorType &amp;)</td></tr>
<tr class="memdesc:ae83c0c88dc13f3a63b043829e9476d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Cauchy stress derivative from the Kirchhoff stress derivative with respect to the deformation gradient  <a href="#ae83c0c88dc13f3a63b043829e9476d85">More...</a><br /></td></tr>
<tr class="separator:ae83c0c88dc13f3a63b043829e9476d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6b2c3bbdb5429dd31dcd9ad1d25eb7"><td class="memTemplParams" colspan="2">template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:adb6b2c3bbdb5429dd31dcd9ad1d25eb7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2ResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2ResultType &gt; &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#adb6b2c3bbdb5429dd31dcd9ad1d25eb7">computeKirchhoffStressDerivativeFromCauchyStressDerivative</a> (T2toST2ResultType &amp;, const T2toST2Type &amp;, const StensorType &amp;, const TensorType &amp;)</td></tr>
<tr class="memdesc:adb6b2c3bbdb5429dd31dcd9ad1d25eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Kirchhoff stress derivative from the Cauchy stress derivative with respect to the deformation gradient  <a href="#adb6b2c3bbdb5429dd31dcd9ad1d25eb7">More...</a><br /></td></tr>
<tr class="separator:adb6b2c3bbdb5429dd31dcd9ad1d25eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3996c4fd98445b5408781edb2cabc11"><td class="memTemplParams" colspan="2"><a id="ad3996c4fd98445b5408781edb2cabc11"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad3996c4fd98445b5408781edb2cabc11"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:ad3996c4fd98445b5408781edb2cabc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f0b002169adeb6c0a9d2d92580fed6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a39f0b002169adeb6c0a9d2d92580fed6"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; T1 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2 &gt;) &amp;&amp;!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Handle &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a39f0b002169adeb6c0a9d2d92580fed6">operator|</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a39f0b002169adeb6c0a9d2d92580fed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabc8f24a5af1bc52c7dd2c7158f7231"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:aeabc8f24a5af1bc52c7dd2c7158f7231"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toT2Type &gt;)==1u) &amp;&amp;implementsT2toT2Concept&lt; T2toT2Type &gt;)), t2tost2&lt; 1u, numeric_type&lt; T2toT2Type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aeabc8f24a5af1bc52c7dd2c7158f7231">convertToT2toST2</a> (const T2toT2Type &amp;)</td></tr>
<tr class="separator:aeabc8f24a5af1bc52c7dd2c7158f7231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf9cfac53f2c7faa1a4d5c662dfad76"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:a8bf9cfac53f2c7faa1a4d5c662dfad76"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toT2Type &gt;)==2u) &amp;&amp;implementsT2toT2Concept&lt; T2toT2Type &gt;)), t2tost2&lt; 2u, numeric_type&lt; T2toT2Type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8bf9cfac53f2c7faa1a4d5c662dfad76">convertToT2toST2</a> (const T2toT2Type &amp;)</td></tr>
<tr class="separator:a8bf9cfac53f2c7faa1a4d5c662dfad76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ef36f3eca9a7a5eede27a0a37ae738"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:aa7ef36f3eca9a7a5eede27a0a37ae738"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toT2Type &gt;)==3u) &amp;&amp;implementsT2toT2Concept&lt; T2toT2Type &gt;)), t2tost2&lt; 3u, numeric_type&lt; T2toT2Type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa7ef36f3eca9a7a5eede27a0a37ae738">convertToT2toST2</a> (const T2toT2Type &amp;)</td></tr>
<tr class="separator:aa7ef36f3eca9a7a5eede27a0a37ae738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7480737e8f2f94319b4d4908978ff51"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:ad7480737e8f2f94319b4d4908978ff51"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==1u), t2tost2&lt; 1u, numeric_type&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad7480737e8f2f94319b4d4908978ff51">computeRateOfDeformationDerivative</a> (const TensorType &amp;)</td></tr>
<tr class="separator:ad7480737e8f2f94319b4d4908978ff51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e2a6404efc797b0b27f03d0a20d1d4"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename stress , typename real &gt; </td></tr>
<tr class="memitem:ae9e2a6404efc797b0b27f03d0a20d1d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae9e2a6404efc797b0b27f03d0a20d1d4">convertFirstPiolaKirchoffStressDerivativeToKirchhoffStressDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;)</td></tr>
<tr class="memdesc:ae9e2a6404efc797b0b27f03d0a20d1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the derivative of the first Piola-Kirchhoff stress with first Piola-Kirchhoff deformation gradient to the derivative of the Kirchhoff stress with respect to the deformation gradient.  <a href="#ae9e2a6404efc797b0b27f03d0a20d1d4">More...</a><br /></td></tr>
<tr class="separator:ae9e2a6404efc797b0b27f03d0a20d1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7670684c63476243218ae3531e597546"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename stress , typename real &gt; </td></tr>
<tr class="memitem:a7670684c63476243218ae3531e597546"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7670684c63476243218ae3531e597546">convertFirstPiolaKirchoffStressDerivativeToKirchhoffStressDerivative</a> (<a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;)</td></tr>
<tr class="memdesc:a7670684c63476243218ae3531e597546"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the derivative of the first Piola-Kirchhoff stress with first Piola-Kirchhoff deformation gradient to the derivative of the Kirchhoff stress with respect to the deformation gradient.  <a href="#a7670684c63476243218ae3531e597546">More...</a><br /></td></tr>
<tr class="separator:a7670684c63476243218ae3531e597546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600d19fd973cd5038b585498516862dc"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename stress , typename real &gt; </td></tr>
<tr class="memitem:a600d19fd973cd5038b585498516862dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a600d19fd973cd5038b585498516862dc">convertCauchyStressDerivativeToFirstPiolaKirchoffStressDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;)</td></tr>
<tr class="memdesc:a600d19fd973cd5038b585498516862dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the derivative of the Cauchy stress with respect to the deformation gradient to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient.  <a href="#a600d19fd973cd5038b585498516862dc">More...</a><br /></td></tr>
<tr class="separator:a600d19fd973cd5038b585498516862dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7008df38bf4fc3f8170249537b46190a"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename stress , typename real &gt; </td></tr>
<tr class="memitem:a7008df38bf4fc3f8170249537b46190a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7008df38bf4fc3f8170249537b46190a">convertCauchyStressDerivativeToFirstPiolaKirchoffStressDerivative</a> (<a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;)</td></tr>
<tr class="memdesc:a7008df38bf4fc3f8170249537b46190a"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the derivative of the Cauchy stress with respect to the deformation gradient to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient.  <a href="#a7008df38bf4fc3f8170249537b46190a">More...</a><br /></td></tr>
<tr class="separator:a7008df38bf4fc3f8170249537b46190a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce7f75958777ea853a9b64d93d6a994"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename stress , typename real &gt; </td></tr>
<tr class="memitem:acce7f75958777ea853a9b64d93d6a994"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#acce7f75958777ea853a9b64d93d6a994">convertSecondPiolaKirchhoffStressDerivativeToFirstPiolaKirchoffStressDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;)</td></tr>
<tr class="memdesc:acce7f75958777ea853a9b64d93d6a994"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the derivative of the second Piola-Kirchoff stress with respect to the Green-Lagrange strain to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient.  <a href="#acce7f75958777ea853a9b64d93d6a994">More...</a><br /></td></tr>
<tr class="separator:acce7f75958777ea853a9b64d93d6a994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f42fbb8c13638c5a527d08c44ab55a"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename stress , typename real &gt; </td></tr>
<tr class="memitem:af2f42fbb8c13638c5a527d08c44ab55a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af2f42fbb8c13638c5a527d08c44ab55a">convertSecondPiolaKirchhoffStressDerivativeToFirstPiolaKirchoffStressDerivative</a> (<a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;)</td></tr>
<tr class="memdesc:af2f42fbb8c13638c5a527d08c44ab55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the derivative of the second Piola-Kirchoff stress with respect to the Green-Lagrange strain to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient.  <a href="#af2f42fbb8c13638c5a527d08c44ab55a">More...</a><br /></td></tr>
<tr class="separator:af2f42fbb8c13638c5a527d08c44ab55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb613e701d1ad4958d1deade781b4414"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:acb613e701d1ad4958d1deade781b4414"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#ab4449faeb9fd598523593e35ee14b53b">implementsT2toT2Concept</a>&lt; T2toT2Type &gt;), <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toT2Type &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toT2Type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#acb613e701d1ad4958d1deade781b4414">change_basis</a> (const T2toT2Type &amp;s, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toT2Type &gt;&gt; &amp;r)</td></tr>
<tr class="separator:acb613e701d1ad4958d1deade781b4414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7139107f7382d90f0261c27affceeb1d"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a7139107f7382d90f0261c27affceeb1d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7139107f7382d90f0261c27affceeb1d">computeVelocityGradientDerivative</a> (const TensorType &amp;F)</td></tr>
<tr class="separator:a7139107f7382d90f0261c27affceeb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c9a04955d98725842deead7aa1e71f"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:ad8c9a04955d98725842deead7aa1e71f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad8c9a04955d98725842deead7aa1e71f">computeSpinRateDerivative</a> (const TensorType &amp;F)</td></tr>
<tr class="separator:ad8c9a04955d98725842deead7aa1e71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d35d9d4f8833c39ec7d4709c8d8787"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a30d35d9d4f8833c39ec7d4709c8d8787"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a30d35d9d4f8833c39ec7d4709c8d8787">computeDeterminantSecondDerivative</a> (const TensorType &amp;)</td></tr>
<tr class="memdesc:a30d35d9d4f8833c39ec7d4709c8d8787"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the second derivative of the determinant of a symmetric tensor  <a href="#a30d35d9d4f8833c39ec7d4709c8d8787">More...</a><br /></td></tr>
<tr class="separator:a30d35d9d4f8833c39ec7d4709c8d8787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d88f436f61622a08d032845ad46c33"><td class="memTemplParams" colspan="2"><a id="a55d88f436f61622a08d032845ad46c33"></a>
template&lt;typename T , typename T2toST2Type &gt; </td></tr>
<tr class="memitem:a55d88f436f61622a08d032845ad46c33"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;)) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;, T &gt;::cond)), <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert</b> (<a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;(), T &gt; &amp;d, const T2toST2Type &amp;s)</td></tr>
<tr class="separator:a55d88f436f61622a08d032845ad46c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4449faeb9fd598523593e35ee14b53b"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:ab4449faeb9fd598523593e35ee14b53b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab4449faeb9fd598523593e35ee14b53b">implementsT2toT2Concept</a> ()</td></tr>
<tr class="memdesc:ab4449faeb9fd598523593e35ee14b53b"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_t2to_t2_concept.html">T2toT2Concept</a></code>.  <a href="#ab4449faeb9fd598523593e35ee14b53b">More...</a><br /></td></tr>
<tr class="separator:ab4449faeb9fd598523593e35ee14b53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ae7a699ed1149acc4c76a51b02b68a"><td class="memTemplParams" colspan="2"><a id="a59ae7a699ed1149acc4c76a51b02b68a"></a>
template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:a59ae7a699ed1149acc4c76a51b02b68a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#ab4449faeb9fd598523593e35ee14b53b">implementsT2toT2Concept</a>&lt; T2toT2Type &gt;), typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toT2Type &gt; &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const T2toT2Type &amp;)</td></tr>
<tr class="separator:a59ae7a699ed1149acc4c76a51b02b68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e51f6336446d61234a7fc928ad7f67a"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:a7e51f6336446d61234a7fc928ad7f67a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#ab4449faeb9fd598523593e35ee14b53b">implementsT2toT2Concept</a>&lt; T2toT2Type &gt;) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toT2Type &gt;)==1u) &amp;&amp;tfel::typetraits::IsScalar&lt; numeric_type&lt; T2toT2Type &gt; &gt;::cond, typename ComputeUnaryResult&lt; numeric_type&lt; T2toT2Type &gt;, Power&lt; 3 &gt; &gt;::Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7e51f6336446d61234a7fc928ad7f67a">det</a> (const T2toT2Type &amp;)</td></tr>
<tr class="separator:a7e51f6336446d61234a7fc928ad7f67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5bdd60d3fef329cd3283287b3a4bc7"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:aad5bdd60d3fef329cd3283287b3a4bc7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#ab4449faeb9fd598523593e35ee14b53b">implementsT2toT2Concept</a>&lt; T2toT2Type &gt;) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toT2Type &gt;)==2u)||(getSpaceDimension&lt; T2toT2Type &gt;)==3u)) &amp;&amp;tfel::typetraits::IsScalar&lt; numeric_type&lt; T2toT2Type &gt; &gt;::cond, typename ComputeUnaryResult&lt; numeric_type&lt; T2toT2Type &gt;, Power&lt; getSpaceDimension&lt; T2toT2Type &gt;)&gt; &gt;::Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aad5bdd60d3fef329cd3283287b3a4bc7">det</a> (const T2toT2Type &amp;)</td></tr>
<tr class="separator:aad5bdd60d3fef329cd3283287b3a4bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c64a752e581d0e8d89bab0f465a3210"><td class="memTemplParams" colspan="2"><a id="a1c64a752e581d0e8d89bab0f465a3210"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1c64a752e581d0e8d89bab0f465a3210"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_t2to_t2_concept.html">T2toT2Concept</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:a1c64a752e581d0e8d89bab0f465a3210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f2206e9e01e27254f765cc3719e2de"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a36f2206e9e01e27254f765cc3719e2de"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; T1 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#ab4449faeb9fd598523593e35ee14b53b">implementsT2toT2Concept</a>&lt; T2 &gt;) &amp;&amp;!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Handle &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a36f2206e9e01e27254f765cc3719e2de">operator|</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a36f2206e9e01e27254f765cc3719e2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a3824dc0d8f442e4503f40aeca68ab"><td class="memTemplParams" colspan="2">template&lt;typename T2toT2Type &gt; </td></tr>
<tr class="memitem:a55a3824dc0d8f442e4503f40aeca68ab"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#ab4449faeb9fd598523593e35ee14b53b">implementsT2toT2Concept</a>&lt; T2toT2Type &gt;), <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toT2Type &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toT2Type &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a55a3824dc0d8f442e4503f40aeca68ab">change_basis</a> (const T2toT2Type &amp;, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toT2Type &gt;&gt; &amp;)</td></tr>
<tr class="separator:a55a3824dc0d8f442e4503f40aeca68ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9289437d989515475c5188ad01e77dbe"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a9289437d989515475c5188ad01e77dbe"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9289437d989515475c5188ad01e77dbe">computeVelocityGradientDerivative</a> (const TensorType &amp;)</td></tr>
<tr class="separator:a9289437d989515475c5188ad01e77dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ced7406fddd581d8abd8d371e460921"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a4ced7406fddd581d8abd8d371e460921"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4ced7406fddd581d8abd8d371e460921">computeSpinRateDerivative</a> (const TensorType &amp;)</td></tr>
<tr class="separator:a4ced7406fddd581d8abd8d371e460921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8c77834aaa2d947b8eb36a8f1350bc"><td class="memTemplParams" colspan="2"><a id="a6f8c77834aaa2d947b8eb36a8f1350bc"></a>
template&lt;unsigned short N, typename T , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a6f8c77834aaa2d947b8eb36a8f1350bc"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exportToBaseTypeArray</b> (const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, T &gt; &amp;t, OutputIterator p)</td></tr>
<tr class="separator:a6f8c77834aaa2d947b8eb36a8f1350bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ff893cb01f4a14bb40456f16eabbb4"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a54ff893cb01f4a14bb40456f16eabbb4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a54ff893cb01f4a14bb40456f16eabbb4">invert</a> (const TensorType &amp;t) noexcept</td></tr>
<tr class="separator:a54ff893cb01f4a14bb40456f16eabbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1499e2aa52c9ec314f85c8bf0c162ecd"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a1499e2aa52c9ec314f85c8bf0c162ecd"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1499e2aa52c9ec314f85c8bf0c162ecd">computeDeterminantDerivative</a> (const TensorType &amp;F)</td></tr>
<tr class="separator:a1499e2aa52c9ec314f85c8bf0c162ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b352e7024d14f544f90b5177d63c150"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a7b352e7024d14f544f90b5177d63c150"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7b352e7024d14f544f90b5177d63c150">change_basis</a> (const TensorType &amp;t, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;&gt; &amp;r) noexcept</td></tr>
<tr class="memdesc:a7b352e7024d14f544f90b5177d63c150"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotate a tensor using a rotation matrix  <a href="#a7b352e7024d14f544f90b5177d63c150">More...</a><br /></td></tr>
<tr class="separator:a7b352e7024d14f544f90b5177d63c150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6c67001903d98952f71c2c60c49df4"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:aea6c67001903d98952f71c2c60c49df4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aea6c67001903d98952f71c2c60c49df4">unsyme</a> (const StensorType &amp;s)</td></tr>
<tr class="separator:aea6c67001903d98952f71c2c60c49df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c82810ca888e374837d24894cfc389"><td class="memTemplParams" colspan="2">template&lt;typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:a98c82810ca888e374837d24894cfc389"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), typename <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a98c82810ca888e374837d24894cfc389">convertCauchyStressToFirstPiolaKirchhoffStress</a> (const StensorType &amp;s, const TensorType &amp;F)</td></tr>
<tr class="memdesc:a98c82810ca888e374837d24894cfc389"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the Cauchy stress to the first Piola-Kirchhoff stress.  <a href="#a98c82810ca888e374837d24894cfc389">More...</a><br /></td></tr>
<tr class="separator:a98c82810ca888e374837d24894cfc389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71aa7e88b74745f06895b0661b09c2c"><td class="memTemplParams" colspan="2">template&lt;typename TensorType , typename TensorType2 &gt; </td></tr>
<tr class="memitem:ae71aa7e88b74745f06895b0661b09c2c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType2 &gt;)), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), typename <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType2 &gt;, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae71aa7e88b74745f06895b0661b09c2c">convertFirstPiolaKirchhoffStressToCauchyStress</a> (const TensorType &amp;, const TensorType2 &amp;)</td></tr>
<tr class="memdesc:ae71aa7e88b74745f06895b0661b09c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the first Piola-Kirchhoff stress to the Cauchy stress  <a href="#ae71aa7e88b74745f06895b0661b09c2c">More...</a><br /></td></tr>
<tr class="separator:ae71aa7e88b74745f06895b0661b09c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86a6ca34a7c9d413943e709cfdb4426"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:af86a6ca34a7c9d413943e709cfdb4426"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a> ()</td></tr>
<tr class="memdesc:af86a6ca34a7c9d413943e709cfdb4426"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a></code>.  <a href="#af86a6ca34a7c9d413943e709cfdb4426">More...</a><br /></td></tr>
<tr class="separator:af86a6ca34a7c9d413943e709cfdb4426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2235e818f496748de3274acb98950623"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a2235e818f496748de3274acb98950623"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2235e818f496748de3274acb98950623">abs</a> (const TensorType &amp;)</td></tr>
<tr class="separator:a2235e818f496748de3274acb98950623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a3023fa09a65452c5c2b6a9861cd9d"><td class="memTemplParams" colspan="2"><a id="a35a3023fa09a65452c5c2b6a9861cd9d"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a35a3023fa09a65452c5c2b6a9861cd9d"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trace</b> (const TensorType &amp;s)</td></tr>
<tr class="separator:a35a3023fa09a65452c5c2b6a9861cd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc41067e6b472830e7affe7d77e2f8"><td class="memTemplParams" colspan="2"><a id="a12fc41067e6b472830e7affe7d77e2f8"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a12fc41067e6b472830e7affe7d77e2f8"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>syme</b> (const TensorType &amp;)</td></tr>
<tr class="separator:a12fc41067e6b472830e7affe7d77e2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770c2a48e5f3209fbd3ea423f2e795f4"><td class="memTemplParams" colspan="2"><a id="a770c2a48e5f3209fbd3ea423f2e795f4"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a770c2a48e5f3209fbd3ea423f2e795f4"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeRightCauchyGreenTensor</b> (const TensorType &amp;)</td></tr>
<tr class="separator:a770c2a48e5f3209fbd3ea423f2e795f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925890b29d18f3d8e86c462fcce409dd"><td class="memTemplParams" colspan="2"><a id="a925890b29d18f3d8e86c462fcce409dd"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a925890b29d18f3d8e86c462fcce409dd"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeLeftCauchyGreenTensor</b> (const TensorType &amp;)</td></tr>
<tr class="separator:a925890b29d18f3d8e86c462fcce409dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74803bb851816cd666b2c47798e75313"><td class="memTemplParams" colspan="2"><a id="a74803bb851816cd666b2c47798e75313"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a74803bb851816cd666b2c47798e75313"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeGreenLagrangeTensor</b> (const TensorType &amp;)</td></tr>
<tr class="separator:a74803bb851816cd666b2c47798e75313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad489dcf8ec0b50bdac502ed711fa9dd6"><td class="memTemplParams" colspan="2">template&lt;typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:ad489dcf8ec0b50bdac502ed711fa9dd6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;::cond)), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad489dcf8ec0b50bdac502ed711fa9dd6">pushForward</a> (const StensorType &amp;, const TensorType &amp;)</td></tr>
<tr class="separator:ad489dcf8ec0b50bdac502ed711fa9dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e407e883f8e2646cb621989d89e7024"><td class="memTemplParams" colspan="2">template&lt;typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:a8e407e883f8e2646cb621989d89e7024"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;::cond)), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8e407e883f8e2646cb621989d89e7024">push_forward</a> (const StensorType &amp;, const TensorType &amp;)</td></tr>
<tr class="separator:a8e407e883f8e2646cb621989d89e7024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2e91754ca3fb53fdc130542a37e28e"><td class="memTemplParams" colspan="2"><a id="a2b2e91754ca3fb53fdc130542a37e28e"></a>
template&lt;typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:a2b2e91754ca3fb53fdc130542a37e28e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond)), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertCauchyStressToSecondPiolaKirchhoffStress</b> (const StensorType &amp;, const TensorType &amp;)</td></tr>
<tr class="separator:a2b2e91754ca3fb53fdc130542a37e28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedfebe4a4afb05c82297e1820c8ea65"><td class="memTemplParams" colspan="2"><a id="afedfebe4a4afb05c82297e1820c8ea65"></a>
template&lt;typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:afedfebe4a4afb05c82297e1820c8ea65"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond)), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertSecondPiolaKirchhoffStressToCauchyStress</b> (const StensorType &amp;, const TensorType &amp;)</td></tr>
<tr class="separator:afedfebe4a4afb05c82297e1820c8ea65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bc45dc6c615562c3e63c51c9e32d52"><td class="memTemplParams" colspan="2"><a id="aa0bc45dc6c615562c3e63c51c9e32d52"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:aa0bc45dc6c615562c3e63c51c9e32d52"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const TensorType &amp;)</td></tr>
<tr class="separator:aa0bc45dc6c615562c3e63c51c9e32d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d6145614cfc7a02b44142898494444"><td class="memTemplParams" colspan="2">template&lt;typename TensorResultType , typename TensorType &gt; </td></tr>
<tr class="memitem:a67d6145614cfc7a02b44142898494444"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorResultType &gt; &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a67d6145614cfc7a02b44142898494444">computeDeterminantDerivative</a> (TensorResultType &amp;, const TensorType &amp;)</td></tr>
<tr class="memdesc:a67d6145614cfc7a02b44142898494444"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="#a67d6145614cfc7a02b44142898494444">More...</a><br /></td></tr>
<tr class="separator:a67d6145614cfc7a02b44142898494444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb049882646b6a957e22b11fd026d07c"><td class="memTemplParams" colspan="2">template&lt;typename TensorType , typename StensorType , typename TensorType2 &gt; </td></tr>
<tr class="memitem:adb049882646b6a957e22b11fd026d07c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;std::is_same&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType2 &gt; &gt;::value &amp;&amp;std::is_same&lt; <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType2 &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::value &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType2 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==1u), void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#adb049882646b6a957e22b11fd026d07c">polar_decomposition</a> (TensorType &amp;, StensorType &amp;, const TensorType2 &amp;)</td></tr>
<tr class="memdesc:adb049882646b6a957e22b11fd026d07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide the polar decomposition of a tensor  <a href="#adb049882646b6a957e22b11fd026d07c">More...</a><br /></td></tr>
<tr class="separator:adb049882646b6a957e22b11fd026d07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5edbd2084512e9cebe5bef088ed081"><td class="memTemplParams" colspan="2">template&lt;typename TensorType , typename StensorType , typename TensorType2 &gt; </td></tr>
<tr class="memitem:a8f5edbd2084512e9cebe5bef088ed081"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;std::is_same&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType2 &gt; &gt;::value &amp;&amp;std::is_same&lt; <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType2 &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::value &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType2 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==2u)||(getSpaceDimension&lt; TensorType &gt;)==3u)), void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8f5edbd2084512e9cebe5bef088ed081">polar_decomposition</a> (TensorType &amp;, StensorType &amp;, const TensorType2 &amp;)</td></tr>
<tr class="memdesc:a8f5edbd2084512e9cebe5bef088ed081"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide the polar decomposition of a tensor  <a href="#a8f5edbd2084512e9cebe5bef088ed081">More...</a><br /></td></tr>
<tr class="separator:a8f5edbd2084512e9cebe5bef088ed081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507d330263341b0cc7a246b267eb16fa"><td class="memTemplParams" colspan="2"><a id="a507d330263341b0cc7a246b267eb16fa"></a>
template&lt;class TensorType &gt; </td></tr>
<tr class="memitem:a507d330263341b0cc7a246b267eb16fa"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trace</b> (const TensorType &amp;s)</td></tr>
<tr class="separator:a507d330263341b0cc7a246b267eb16fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cfda68928e56aad7d2ce896e5b81ec"><td class="memTemplParams" colspan="2"><a id="ae4cfda68928e56aad7d2ce896e5b81ec"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:ae4cfda68928e56aad7d2ce896e5b81ec"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>syme</b> (const TensorType &amp;t)</td></tr>
<tr class="separator:ae4cfda68928e56aad7d2ce896e5b81ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18ff98017d62c11964a0e646b74ed08"><td class="memTemplParams" colspan="2"><a id="af18ff98017d62c11964a0e646b74ed08"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:af18ff98017d62c11964a0e646b74ed08"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond)), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeRightCauchyGreenTensor</b> (const TensorType &amp;t)</td></tr>
<tr class="separator:af18ff98017d62c11964a0e646b74ed08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ade75b3e342f1ff0601951f77deedfc"><td class="memTemplParams" colspan="2"><a id="a1ade75b3e342f1ff0601951f77deedfc"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a1ade75b3e342f1ff0601951f77deedfc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeLeftCauchyGreenTensor</b> (const TensorType &amp;t)</td></tr>
<tr class="separator:a1ade75b3e342f1ff0601951f77deedfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff466b7c2daf7013e90ad88be14f387a"><td class="memTemplParams" colspan="2"><a id="aff466b7c2daf7013e90ad88be14f387a"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:aff466b7c2daf7013e90ad88be14f387a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond)), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computeGreenLagrangeTensor</b> (const TensorType &amp;t)</td></tr>
<tr class="separator:aff466b7c2daf7013e90ad88be14f387a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6d44218744912ecdf77495d7e5e4f4"><td class="memTemplParams" colspan="2"><a id="a8b6d44218744912ecdf77495d7e5e4f4"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a8b6d44218744912ecdf77495d7e5e4f4"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>matrix_view</b> (TensorType &amp;&amp;t) -&gt; typename std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;(), <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3u, 3u, numeric_type&lt; decltype(t)&gt;&gt;, MatrixViewFromTensorExpr&lt; decltype(t)&gt;&gt;&gt;::type</td></tr>
<tr class="separator:a8b6d44218744912ecdf77495d7e5e4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca714984acb0999714cf6e285319a13e"><td class="memTemplParams" colspan="2"><a id="aca714984acb0999714cf6e285319a13e"></a>
template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:aca714984acb0999714cf6e285319a13e"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (TensorType &amp;&amp;t) -&gt; typename std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;() &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;()==1u), Expr&lt; tensor&lt; 1u, numeric_type&lt; decltype(t)&gt;&gt;, TensorTransposeExpr1D&lt; decltype(t)&gt;&gt;&gt;::type</td></tr>
<tr class="separator:aca714984acb0999714cf6e285319a13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171ceede8daa6d044991e62768ed67ee"><td class="memTemplParams" colspan="2"><a id="a171ceede8daa6d044991e62768ed67ee"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a171ceede8daa6d044991e62768ed67ee"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:a171ceede8daa6d044991e62768ed67ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a3caef3aae091a3bb3776b6c00bb4b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad4a3caef3aae091a3bb3776b6c00bb4b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; T1 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; T2 &gt;) &amp;&amp;!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::Result &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad4a3caef3aae091a3bb3776b6c00bb4b">operator|</a> (const T1 &amp;, const T2 &amp;)</td></tr>
<tr class="separator:ad4a3caef3aae091a3bb3776b6c00bb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc8767e0b16172004cf25f1bc2cc760"><td class="memTemplParams" colspan="2"><a id="a5cc8767e0b16172004cf25f1bc2cc760"></a>
template&lt;typename TensorType1 , typename TensorType2 &gt; </td></tr>
<tr class="memitem:a5cc8767e0b16172004cf25f1bc2cc760"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType1 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType2 &gt;) &amp;&amp;!<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; TensorType1, TensorType2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::Result &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; TensorType1, TensorType2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator|</b> (const TensorType1 &amp;a, const TensorType2 &amp;b)</td></tr>
<tr class="separator:a5cc8767e0b16172004cf25f1bc2cc760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5a2d39d6b1efa7070e2dbfcb7ef4b2"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:aed5a2d39d6b1efa7070e2dbfcb7ef4b2"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;::Result &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aed5a2d39d6b1efa7070e2dbfcb7ef4b2">invert</a> (const TensorType &amp;) noexcept</td></tr>
<tr class="separator:aed5a2d39d6b1efa7070e2dbfcb7ef4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9315cc19517d0879d4ec83c207c5f12f"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:a9315cc19517d0879d4ec83c207c5f12f"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9315cc19517d0879d4ec83c207c5f12f">change_basis</a> (const TensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;&gt; &amp;) noexcept</td></tr>
<tr class="memdesc:a9315cc19517d0879d4ec83c207c5f12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotate a tensor using a rotation matrix  <a href="#a9315cc19517d0879d4ec83c207c5f12f">More...</a><br /></td></tr>
<tr class="separator:a9315cc19517d0879d4ec83c207c5f12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78872ee963817439070ace05dbdd693e"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a78872ee963817439070ace05dbdd693e"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a78872ee963817439070ace05dbdd693e">unsyme</a> (const StensorType &amp;)</td></tr>
<tr class="separator:a78872ee963817439070ace05dbdd693e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d03ae4884ce7c6aa873a80adb3987b5"><td class="memTemplParams" colspan="2">template&lt;typename StensorType , typename TensorType &gt; </td></tr>
<tr class="memitem:a6d03ae4884ce7c6aa873a80adb3987b5"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), typename <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6d03ae4884ce7c6aa873a80adb3987b5">convertCauchyStressToFirstPiolaKirchhoffStress</a> (const StensorType &amp;, const TensorType &amp;)</td></tr>
<tr class="memdesc:a6d03ae4884ce7c6aa873a80adb3987b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the Cauchy stress to the first Piola-Kirchhoff stress.  <a href="#a6d03ae4884ce7c6aa873a80adb3987b5">More...</a><br /></td></tr>
<tr class="separator:a6d03ae4884ce7c6aa873a80adb3987b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f4e4b81aa24f4b7a034c15c08ae69a"><td class="memTemplParams" colspan="2"><a id="a05f4e4b81aa24f4b7a034c15c08ae69a"></a>
template&lt;typename T , typename Operation &gt; </td></tr>
<tr class="memitem:a05f4e4b81aa24f4b7a034c15c08ae69a"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 2, 2, T &gt;, Operation &gt; &amp;)</td></tr>
<tr class="separator:a05f4e4b81aa24f4b7a034c15c08ae69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4efb662f0e25b4e9876e32cafe589108"><td class="memTemplParams" colspan="2"><a id="a4efb662f0e25b4e9876e32cafe589108"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4efb662f0e25b4e9876e32cafe589108"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 2, 2, T &gt; &amp;)</td></tr>
<tr class="separator:a4efb662f0e25b4e9876e32cafe589108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e6bf086ae830e33cd39fcafdc29f37"><td class="memTemplParams" colspan="2"><a id="a16e6bf086ae830e33cd39fcafdc29f37"></a>
template&lt;typename T , typename Operation &gt; </td></tr>
<tr class="memitem:a16e6bf086ae830e33cd39fcafdc29f37"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3, 3, T &gt;, Operation &gt; &amp;)</td></tr>
<tr class="separator:a16e6bf086ae830e33cd39fcafdc29f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e2f92a9b08a94e2cca7ee54b556a33"><td class="memTemplParams" colspan="2"><a id="a14e2f92a9b08a94e2cca7ee54b556a33"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14e2f92a9b08a94e2cca7ee54b556a33"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 3 &gt; &gt;::Result&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3, 3, T &gt; &amp;)</td></tr>
<tr class="separator:a14e2f92a9b08a94e2cca7ee54b556a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302fcc3dcd4eab55fb584c3465e2e8aa"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , unsigned short N&gt; </td></tr>
<tr class="memitem:a302fcc3dcd4eab55fb584c3465e2e8aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, typename std::result_of&lt; F(T)&gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a302fcc3dcd4eab55fb584c3465e2e8aa">map</a> (F, const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="memdesc:a302fcc3dcd4eab55fb584c3465e2e8aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new tvector by applying a functor  <a href="#a302fcc3dcd4eab55fb584c3465e2e8aa">More...</a><br /></td></tr>
<tr class="separator:a302fcc3dcd4eab55fb584c3465e2e8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfd1950e41dfff10fc785c9593a06ca"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a2cfd1950e41dfff10fc785c9593a06ca"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2cfd1950e41dfff10fc785c9593a06ca">exportToBaseTypeArray</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, OutputIterator)</td></tr>
<tr class="separator:a2cfd1950e41dfff10fc785c9593a06ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffaaab80f308d5fd407efcecf405178"><td class="memTemplParams" colspan="2"><a id="a6ffaaab80f308d5fd407efcecf405178"></a>
template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a6ffaaab80f308d5fd407efcecf405178"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;v)</td></tr>
<tr class="separator:a6ffaaab80f308d5fd407efcecf405178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5de08fae58f6088ce519ec296c0a67"><td class="memTemplParams" colspan="2"><a id="a0e5de08fae58f6088ce519ec296c0a67"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e5de08fae58f6088ce519ec296c0a67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 1u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeTVector1D</b> (const T)</td></tr>
<tr class="separator:a0e5de08fae58f6088ce519ec296c0a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3048a1ee4df7868d5c78f1c490eb998e"><td class="memTemplParams" colspan="2"><a id="a3048a1ee4df7868d5c78f1c490eb998e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3048a1ee4df7868d5c78f1c490eb998e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 2u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeTVector2D</b> (const T, const T)</td></tr>
<tr class="separator:a3048a1ee4df7868d5c78f1c490eb998e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add32e06c219189f4e88c71c4f6311938"><td class="memTemplParams" colspan="2"><a id="add32e06c219189f4e88c71c4f6311938"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:add32e06c219189f4e88c71c4f6311938"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeTVector3D</b> (const T, const T, const T)</td></tr>
<tr class="separator:add32e06c219189f4e88c71c4f6311938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5631275fe3ba3b491e6dd7e6f3147cf9"><td class="memTemplParams" colspan="2"><a id="a5631275fe3ba3b491e6dd7e6f3147cf9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5631275fe3ba3b491e6dd7e6f3147cf9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cross_product</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 2u, T &gt; &amp;, const tvector&lt; 2u, T &gt; &amp;)</td></tr>
<tr class="separator:a5631275fe3ba3b491e6dd7e6f3147cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddef4e732fbd8c38d696fdc530e90fd"><td class="memTemplParams" colspan="2"><a id="aaddef4e732fbd8c38d696fdc530e90fd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaddef4e732fbd8c38d696fdc530e90fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cross_product</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;, const tvector&lt; 3u, T &gt; &amp;)</td></tr>
<tr class="separator:aaddef4e732fbd8c38d696fdc530e90fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7ba97d16e5ab2f5b2efa56b6640bf3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b7ba97d16e5ab2f5b2efa56b6640bf3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1b7ba97d16e5ab2f5b2efa56b6640bf3">find_perpendicular_vector</a> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;, const tvector&lt; 3u, T &gt; &amp;)</td></tr>
<tr class="separator:a1b7ba97d16e5ab2f5b2efa56b6640bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae312eb70d31a3763c304cbf296791856"><td class="memTemplParams" colspan="2">template&lt;unsigned short I, unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:ae312eb70d31a3763c304cbf296791856"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N - I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; N - I, N, I, T, false &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae312eb70d31a3763c304cbf296791856">slice</a> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="memdesc:ae312eb70d31a3763c304cbf296791856"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a slice from a tiny vector  <a href="#ae312eb70d31a3763c304cbf296791856">More...</a><br /></td></tr>
<tr class="separator:ae312eb70d31a3763c304cbf296791856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbcc9f199633d9837f1b4b5a38d19cd"><td class="memTemplParams" colspan="2">template&lt;unsigned short I, unsigned short J, unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:affbcc9f199633d9837f1b4b5a38d19cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; J - I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; J - I, N, I, T, false &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#affbcc9f199633d9837f1b4b5a38d19cd">slice</a> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="memdesc:affbcc9f199633d9837f1b4b5a38d19cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a slice from a tiny vector  <a href="#affbcc9f199633d9837f1b4b5a38d19cd">More...</a><br /></td></tr>
<tr class="separator:affbcc9f199633d9837f1b4b5a38d19cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d9519eaa015451b0f1c35c9d7e6d9f"><td class="memTemplParams" colspan="2">template&lt;unsigned short I, unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a05d9519eaa015451b0f1c35c9d7e6d9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N - I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; N - I, N, I, T, true &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a05d9519eaa015451b0f1c35c9d7e6d9f">slice</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="memdesc:a05d9519eaa015451b0f1c35c9d7e6d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a slice from a tiny vector  <a href="#a05d9519eaa015451b0f1c35c9d7e6d9f">More...</a><br /></td></tr>
<tr class="separator:a05d9519eaa015451b0f1c35c9d7e6d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb819c9fb29ebad868f667144cd942e4"><td class="memTemplParams" colspan="2">template&lt;unsigned short I, unsigned short J, unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:afb819c9fb29ebad868f667144cd942e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; J - I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; J - I, N, I, T, true &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#afb819c9fb29ebad868f667144cd942e4">slice</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="memdesc:afb819c9fb29ebad868f667144cd942e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a slice from a tiny vector (const version)  <a href="#afb819c9fb29ebad868f667144cd942e4">More...</a><br /></td></tr>
<tr class="separator:afb819c9fb29ebad868f667144cd942e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afa7af5d0f55bb8b74a9a5383ec6e38"><td class="memTemplParams" colspan="2"><a id="a3afa7af5d0f55bb8b74a9a5383ec6e38"></a>
template&lt;unsigned short N, unsigned short Mn, unsigned short In, typename T , bool b&gt; </td></tr>
<tr class="memitem:a3afa7af5d0f55bb8b74a9a5383ec6e38"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; N, Mn, In, T, b &gt; &gt; &amp;)</td></tr>
<tr class="separator:a3afa7af5d0f55bb8b74a9a5383ec6e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d1c6351f7f9aaef376d03446012741"><td class="memTemplParams" colspan="2"><a id="a75d1c6351f7f9aaef376d03446012741"></a>
template&lt;unsigned short N, unsigned short Mn, unsigned short In, unsigned short Nn, typename T &gt; </td></tr>
<tr class="memitem:a75d1c6351f7f9aaef376d03446012741"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; Nn, <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_of_stensor_from_tiny_vector_view_expr.html">TinyVectorOfStensorFromTinyVectorViewExpr</a>&lt; N, Mn, In, Nn, T &gt; &gt; &amp;)</td></tr>
<tr class="separator:a75d1c6351f7f9aaef376d03446012741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bba9b97fe1241ad76a414704f426f97"><td class="memTemplParams" colspan="2"><a id="a0bba9b97fe1241ad76a414704f426f97"></a>
template&lt;unsigned short N, unsigned short Mn, unsigned short In, unsigned short Nn, typename T &gt; </td></tr>
<tr class="memitem:a0bba9b97fe1241ad76a414704f426f97"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; Nn, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_of_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorOfTinyVectorFromTinyVectorViewExpr</a>&lt; N, Mn, In, Nn, T &gt; &gt; &amp;)</td></tr>
<tr class="separator:a0bba9b97fe1241ad76a414704f426f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4573c0a7cd2796c5bcb7070c395547a4"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a4573c0a7cd2796c5bcb7070c395547a4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4573c0a7cd2796c5bcb7070c395547a4">exportToBaseTypeArray</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;v, OutputIterator p)</td></tr>
<tr class="separator:a4573c0a7cd2796c5bcb7070c395547a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2068d090b1d786cbce7f05b9e5c3c1"><td class="memTemplParams" colspan="2"><a id="a5e2068d090b1d786cbce7f05b9e5c3c1"></a>
template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a5e2068d090b1d786cbce7f05b9e5c3c1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt; T &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>norm</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;vec)</td></tr>
<tr class="separator:a5e2068d090b1d786cbce7f05b9e5c3c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfd390603da694737c9329a6120b74e"><td class="memTemplParams" colspan="2"><a id="afdfd390603da694737c9329a6120b74e"></a>
template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:afdfd390603da694737c9329a6120b74e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;v)</td></tr>
<tr class="separator:afdfd390603da694737c9329a6120b74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8170997bd1d8dec188c9438e592ae222"><td class="memTemplParams" colspan="2"><a id="a8170997bd1d8dec188c9438e592ae222"></a>
template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a8170997bd1d8dec188c9438e592ae222"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="separator:a8170997bd1d8dec188c9438e592ae222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9dde0e44d24c8523bfa7b9b0f79d44"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b9dde0e44d24c8523bfa7b9b0f79d44"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt; T &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8b9dde0e44d24c8523bfa7b9b0f79d44">norm</a> (const <a class="el" href="classtfel_1_1math_1_1vector.html">vector</a>&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a8b9dde0e44d24c8523bfa7b9b0f79d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the euclidian norm of a vector  <a href="#a8b9dde0e44d24c8523bfa7b9b0f79d44">More...</a><br /></td></tr>
<tr class="separator:a8b9dde0e44d24c8523bfa7b9b0f79d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5424b5a3d5ff40da6e4ef6abacb5b2be"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a5424b5a3d5ff40da6e4ef6abacb5b2be"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5424b5a3d5ff40da6e4ef6abacb5b2be">implementsVectorConcept</a> ()</td></tr>
<tr class="memdesc:a5424b5a3d5ff40da6e4ef6abacb5b2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_vector_concept.html">VectorConcept</a></code>.  <a href="#a5424b5a3d5ff40da6e4ef6abacb5b2be">More...</a><br /></td></tr>
<tr class="separator:a5424b5a3d5ff40da6e4ef6abacb5b2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cecd8225f0f242c76c1715d8f07a8c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a28cecd8225f0f242c76c1715d8f07a8c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structtfel_1_1math_1_1_is_vector_vector_operation_valid.html">IsVectorVectorOperationValid</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::Result &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a28cecd8225f0f242c76c1715d8f07a8c">operator|</a> (const T1 &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a28cecd8225f0f242c76c1715d8f07a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184f3b4d642b96100d4299d258db1f9b"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:a184f3b4d642b96100d4299d258db1f9b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structtfel_1_1math_1_1_is_euclidian_norm_valid.html">IsEuclidianNormValid</a>&lt; T1 &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T1, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::Result &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a184f3b4d642b96100d4299d258db1f9b">norm</a> (const T1 &amp;)</td></tr>
<tr class="memdesc:a184f3b4d642b96100d4299d258db1f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the euclidian norm of a tvector  <a href="#a184f3b4d642b96100d4299d258db1f9b">More...</a><br /></td></tr>
<tr class="separator:a184f3b4d642b96100d4299d258db1f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a399608ee9d96a24fe5899334bd7d8a42"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a399608ee9d96a24fe5899334bd7d8a42"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt; T &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a399608ee9d96a24fe5899334bd7d8a42">norm</a> (const <a class="el" href="classtfel_1_1math_1_1vector.html">vector</a>&lt; T &gt; &amp;)</td></tr>
<tr class="memdesc:a399608ee9d96a24fe5899334bd7d8a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the euclidian norm of a vector  <a href="#a399608ee9d96a24fe5899334bd7d8a42">More...</a><br /></td></tr>
<tr class="separator:a399608ee9d96a24fe5899334bd7d8a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace contains various classes and functions défining mathematical objects and numerical algorithms. </p>
<h1><a class="anchor" id="Tensorial"></a>
Tensorial objects</h1>
<p>The <code>TFEL/Math</code> library provides two classes for second order tensors:</p><ul>
<li>The <code>stensor</code> class which describes <em>symmetric</em> second order tensors.</li>
<li>The <code>tensor</code> class which describes general second order (symmetric and unsymmetric) tensors.</li>
</ul>
<p>Fourth order tensors are linear transformations of second order tensors. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ab0ea413b09d061d87404c592457b8214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ea413b09d061d87404c592457b8214">&#9670;&nbsp;</a></span>acceleration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a8e7809b7b7e3800ebc6fea939690938e">Acceleration</a>&gt; <a class="el" href="namespacetfel_1_1math.html#ab0ea413b09d061d87404c592457b8214">tfel::math::acceleration</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines an acceleration. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a8e7809b7b7e3800ebc6fea939690938e" title="Declares the Acceleration unit. ">Acceleration</a> </dd></dl>

</div>
</div>
<a id="a8e7809b7b7e3800ebc6fea939690938e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7809b7b7e3800ebc6fea939690938e">&#9670;&nbsp;</a></span>Acceleration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,1,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a8e7809b7b7e3800ebc6fea939690938e">tfel::math::Acceleration</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Acceleration unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="afca7dcdc304bb2813a61e03b923ad68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca7dcdc304bb2813a61e03b923ad68a">&#9670;&nbsp;</a></span>ampere</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a4c502ed4a6dd50e17f17022f7327d74e">Ampere</a>&gt; <a class="el" href="namespacetfel_1_1math.html#afca7dcdc304bb2813a61e03b923ad68a">tfel::math::ampere</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines an ampere. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a4c502ed4a6dd50e17f17022f7327d74e" title="Declares the Ampere unit. ">Ampere</a> </dd></dl>

</div>
</div>
<a id="a4c502ed4a6dd50e17f17022f7327d74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c502ed4a6dd50e17f17022f7327d74e">&#9670;&nbsp;</a></span>Ampere</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,0,1,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a4c502ed4a6dd50e17f17022f7327d74e">tfel::math::Ampere</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Ampere unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a3ed3cb42e97e262d9a0aedcd40bf0aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed3cb42e97e262d9a0aedcd40bf0aca">&#9670;&nbsp;</a></span>candela</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a6c9f10c92636c52b23d750dc1d146992">Candela</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a3ed3cb42e97e262d9a0aedcd40bf0aca">tfel::math::candela</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a candela. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a6c9f10c92636c52b23d750dc1d146992" title="Declares the Candela unit. ">Candela</a> </dd></dl>

</div>
</div>
<a id="a6c9f10c92636c52b23d750dc1d146992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9f10c92636c52b23d750dc1d146992">&#9670;&nbsp;</a></span>Candela</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,0,0,0,1,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a6c9f10c92636c52b23d750dc1d146992">tfel::math::Candela</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Candela unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a037360e732078b2d8b6bee5f80a0c819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037360e732078b2d8b6bee5f80a0c819">&#9670;&nbsp;</a></span>Complex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">tfel::math::Complex</a> = typedef <a class="el" href="structstd_1_1complex.html">std::complex</a>&lt;ValueType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an alias <a class="el" href="structstd_1_1complex.html">std::complex</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ValueType,underlying</td><td>type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structstd_1_1complex.html">std::complex</a>. </dd></dl>

</div>
</div>
<a id="a7aac068b26a121174ac002a67805e86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aac068b26a121174ac002a67805e86c">&#9670;&nbsp;</a></span>Density</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,-3,0,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a7aac068b26a121174ac002a67805e86c">tfel::math::Density</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Density unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="ade22387cb208d66abb4cf8cf1bcbd76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade22387cb208d66abb4cf8cf1bcbd76f">&#9670;&nbsp;</a></span>Energy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,2,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#ade22387cb208d66abb4cf8cf1bcbd76f">tfel::math::Energy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Energy unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a31a34e2674b7e7563d24f1550c17f649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a34e2674b7e7563d24f1550c17f649">&#9670;&nbsp;</a></span>EnergyDensity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,-1,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a31a34e2674b7e7563d24f1550c17f649">tfel::math::EnergyDensity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the EnergyDensity unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="ae4753cbd852f9c874ade45013232ba78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4753cbd852f9c874ade45013232ba78">&#9670;&nbsp;</a></span>force</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a898eea1d4e2c1327c6234c96102c970e">Force</a>&gt; <a class="el" href="namespacetfel_1_1math.html#ae4753cbd852f9c874ade45013232ba78">tfel::math::force</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a force. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a898eea1d4e2c1327c6234c96102c970e" title="Declares the Momentum unit. ">Force</a> </dd></dl>

</div>
</div>
<a id="a898eea1d4e2c1327c6234c96102c970e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898eea1d4e2c1327c6234c96102c970e">&#9670;&nbsp;</a></span>Force</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,1,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a898eea1d4e2c1327c6234c96102c970e">tfel::math::Force</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Momentum unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a4ec6d506c79e1d01840880bc03a54df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec6d506c79e1d01840880bc03a54df4">&#9670;&nbsp;</a></span>Frequency</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,-1,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a4ec6d506c79e1d01840880bc03a54df4">tfel::math::Frequency</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Frequency unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a780717c8aea48d1f920aabd64af09270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a780717c8aea48d1f920aabd64af09270">&#9670;&nbsp;</a></span>invlength</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f">Length</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a780717c8aea48d1f920aabd64af09270">tfel::math::invlength</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a invlength. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a4cafc93655e0e08a3438947be78f1130" title="Declares the InvLength unit. ">InvLength</a> </dd></dl>

</div>
</div>
<a id="a4cafc93655e0e08a3438947be78f1130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cafc93655e0e08a3438947be78f1130">&#9670;&nbsp;</a></span>InvLength</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,-1,0,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a4cafc93655e0e08a3438947be78f1130">tfel::math::InvLength</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the InvLength unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a9a1838b2eecf37fb347a5efb709afed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1838b2eecf37fb347a5efb709afed4">&#9670;&nbsp;</a></span>InvTemperature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,0,0,-1,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a9a1838b2eecf37fb347a5efb709afed4">tfel::math::InvTemperature</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the InvTemperature unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a8b7684b7496f5c9bd09f2947b5b8d537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7684b7496f5c9bd09f2947b5b8d537">&#9670;&nbsp;</a></span>Kelvin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,0,0,1,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a8b7684b7496f5c9bd09f2947b5b8d537">tfel::math::Kelvin</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Kelvin unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a06d97ccd2592515a92ba2a4eb662bb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d97ccd2592515a92ba2a4eb662bb4b">&#9670;&nbsp;</a></span>length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f">Length</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a06d97ccd2592515a92ba2a4eb662bb4b">tfel::math::length</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a length. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f" title="Declares the Length unit. ">Length</a> </dd></dl>

</div>
</div>
<a id="aeab4cd4dbbabfa81beade7e23a81aa9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab4cd4dbbabfa81beade7e23a81aa9f">&#9670;&nbsp;</a></span>Length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,1,0,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#aeab4cd4dbbabfa81beade7e23a81aa9f">tfel::math::Length</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Length unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a1b9fe942a2790b56c3082717ed99ef2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9fe942a2790b56c3082717ed99ef2b">&#9670;&nbsp;</a></span>mass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a0f6aaddfab53e1c567c1f210d3031d7f">Mass</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a1b9fe942a2790b56c3082717ed99ef2b">tfel::math::mass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a mass. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a0f6aaddfab53e1c567c1f210d3031d7f" title="Declares the Mass unit. ">Mass</a> </dd></dl>

</div>
</div>
<a id="a0f6aaddfab53e1c567c1f210d3031d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6aaddfab53e1c567c1f210d3031d7f">&#9670;&nbsp;</a></span>Mass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,0,0,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a0f6aaddfab53e1c567c1f210d3031d7f">tfel::math::Mass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Mass unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a60efadb57e60e9757e189196f3667e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60efadb57e60e9757e189196f3667e68">&#9670;&nbsp;</a></span>mole</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#af22c96cecfa5347958619e2672a9e0e4">Mole</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a60efadb57e60e9757e189196f3667e68">tfel::math::mole</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a mole. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#af22c96cecfa5347958619e2672a9e0e4" title="Declares the Mole unit. ">Mole</a> </dd></dl>

</div>
</div>
<a id="af22c96cecfa5347958619e2672a9e0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22c96cecfa5347958619e2672a9e0e4">&#9670;&nbsp;</a></span>Mole</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,0,0,0,0,1&gt;::type <a class="el" href="namespacetfel_1_1math.html#af22c96cecfa5347958619e2672a9e0e4">tfel::math::Mole</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Mole unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a8ff986de4d5db9845fdb1ed04f5ba6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ff986de4d5db9845fdb1ed04f5ba6f2">&#9670;&nbsp;</a></span>momentum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a95dd04d79c3a9114074eda5a6080fbc6">Momentum</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a8ff986de4d5db9845fdb1ed04f5ba6f2">tfel::math::momentum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a momentum. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a95dd04d79c3a9114074eda5a6080fbc6" title="Declares the Momentum unit. ">Momentum</a> </dd></dl>

</div>
</div>
<a id="a95dd04d79c3a9114074eda5a6080fbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95dd04d79c3a9114074eda5a6080fbc6">&#9670;&nbsp;</a></span>Momentum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,1,-1,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a95dd04d79c3a9114074eda5a6080fbc6">tfel::math::Momentum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Momentum unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="adc5a1bcf7b721fde538e7a19f99bbd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5a1bcf7b721fde538e7a19f99bbd36">&#9670;&nbsp;</a></span>Newton</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,1,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#adc5a1bcf7b721fde538e7a19f99bbd36">tfel::math::Newton</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Newton unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a0066b6a6803bbb311c229240d6b6263b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0066b6a6803bbb311c229240d6b6263b">&#9670;&nbsp;</a></span>Pressure</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,-1,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a0066b6a6803bbb311c229240d6b6263b">tfel::math::Pressure</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Pressure unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a5240f42645c61228638106cf2724850a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5240f42645c61228638106cf2724850a">&#9670;&nbsp;</a></span>Stress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,-1,-2,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a5240f42645c61228638106cf2724850a">tfel::math::Stress</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Stress unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a9e5861e18a76bb1552c699bdebe327c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5861e18a76bb1552c699bdebe327c2">&#9670;&nbsp;</a></span>StressRate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1,-1,-3,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a9e5861e18a76bb1552c699bdebe327c2">tfel::math::StressRate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the StressRate unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="ad522fc0823cac19370b9ade552cc679f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad522fc0823cac19370b9ade552cc679f">&#9670;&nbsp;</a></span>temperature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#aaf2a11fc25b0491377347962a2219cf7">Temperature</a>&gt; <a class="el" href="namespacetfel_1_1math.html#ad522fc0823cac19370b9ade552cc679f">tfel::math::temperature</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a temperature. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#aaf2a11fc25b0491377347962a2219cf7" title="Declares the Temperature unit. ">Temperature</a> </dd></dl>

</div>
</div>
<a id="aaf2a11fc25b0491377347962a2219cf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2a11fc25b0491377347962a2219cf7">&#9670;&nbsp;</a></span>Temperature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,0,0,1,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#aaf2a11fc25b0491377347962a2219cf7">tfel::math::Temperature</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Temperature unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a3215b75eb5815603d8919a02502241da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3215b75eb5815603d8919a02502241da">&#9670;&nbsp;</a></span>time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#ad1f1c4734361bfe475e361a040a1ece5">Time</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a3215b75eb5815603d8919a02502241da">tfel::math::time</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a time. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#ad1f1c4734361bfe475e361a040a1ece5" title="Declares the Time unit. ">Time</a> </dd></dl>

</div>
</div>
<a id="ad1f1c4734361bfe475e361a040a1ece5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f1c4734361bfe475e361a040a1ece5">&#9670;&nbsp;</a></span>Time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,0,1,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#ad1f1c4734361bfe475e361a040a1ece5">tfel::math::Time</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Time unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a30a10ed49c61273a39121565bb011e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a10ed49c61273a39121565bb011e11">&#9670;&nbsp;</a></span>velocity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtfel_1_1math_1_1qt.html">qt</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a6b4c6c3374a01fa6e86eadcf85cb55ed">Velocity</a>&gt; <a class="el" href="namespacetfel_1_1math.html#a30a10ed49c61273a39121565bb011e11">tfel::math::velocity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines a velocity. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1qt.html" title="This class describes numbers with unit. qt must be has efficient and simple to use that standard nume...">qt</a>, <a class="el" href="namespacetfel_1_1math.html#a6b4c6c3374a01fa6e86eadcf85cb55ed" title="Declares the Velocity unit. ">Velocity</a> </dd></dl>

</div>
</div>
<a id="a6b4c6c3374a01fa6e86eadcf85cb55ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4c6c3374a01fa6e86eadcf85cb55ed">&#9670;&nbsp;</a></span>Velocity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0,1,-1,0,0,0,0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a6b4c6c3374a01fa6e86eadcf85cb55ed">tfel::math::Velocity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Velocity unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a085b6d7d59fda78126e3437db00443e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085b6d7d59fda78126e3437db00443e8">&#9670;&nbsp;</a></span>abs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;::type &gt; tfel::math::abs </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of the absolute values of all components of a symmetric tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2235e818f496748de3274acb98950623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2235e818f496748de3274acb98950623">&#9670;&nbsp;</a></span>abs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), typename <a class="el" href="structtfel_1_1typetraits_1_1_abs_type.html">tfel::typetraits::AbsType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::type &gt; tfel::math::abs </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of the absolute value of the components of a tensor </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorType</td><td>type of the tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95d1b3d4dfb55a05fa4373f8279055b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d1b3d4dfb55a05fa4373f8279055b9">&#9670;&nbsp;</a></span>absolute_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, numeric_type&lt; StensorType &gt; &gt; &gt; tfel::math::absolute_value </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the absolute value of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8081fec1cda633aab4f62e383ceb7ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8081fec1cda633aab4f62e383ceb7ada">&#9670;&nbsp;</a></span>absolute_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u)||(getSpaceDimension&lt; StensorType &gt;)==3u)) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; getSpaceDimension&lt; StensorType &gt;), numeric_type&lt; StensorType &gt; &gt; &gt; tfel::math::absolute_value </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the absolute value of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8df1977dfb39b746fe9f020b3e6df49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8df1977dfb39b746fe9f020b3e6df49">&#9670;&nbsp;</a></span>areIndexingPoliciesCompatibleAtRunTime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::areIndexingPoliciesCompatibleAtRunTime </td>
          <td>(</td>
          <td class="paramtype">const IndexingPolicy1 &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexingPolicy2 &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if two indexing policies are compatible at runtime. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy1</td><td>first indexing policy </td></tr>
    <tr><td class="paramname">IndexingPolicy2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>first indexing policy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function is a simple wrapper around <code>IndexingPoliciesCompatiblityCheck::runtimeTimeCheck</code>. </dd></dl>

</div>
</div>
<a id="a25be866f4fe5021c58672780177c7825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25be866f4fe5021c58672780177c7825">&#9670;&nbsp;</a></span>broyden() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt; tfel::math::broyden </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root of a function using the first Broyden algorithm</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>: size of the unknown </td></tr>
    <tr><td class="paramname">T</td><td>: numerical type </td></tr>
    <tr><td class="paramname">f</td><td>: function which root is sought after </td></tr>
    <tr><td class="paramname">x0</td><td>: initial guess </td></tr>
    <tr><td class="paramname">A</td><td>: initial approximation of the jacobian </td></tr>
    <tr><td class="paramname">e</td><td>: convergence criterium </td></tr>
    <tr><td class="paramname">n</td><td>: maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair whose first member is true is the algorithm converged and whose second member contains the solution </dd></dl>

</div>
</div>
<a id="a8437c41fb14f7fbda25b1f07c9dcbf94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8437c41fb14f7fbda25b1f07c9dcbf94">&#9670;&nbsp;</a></span>broyden() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt; tfel::math::broyden </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root of a function using the first Broyden algorithm. The jacobian is initially approximated by the identity matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>: size of the unknown </td></tr>
    <tr><td class="paramname">T</td><td>: numerical type </td></tr>
    <tr><td class="paramname">f</td><td>: function which root is sought after </td></tr>
    <tr><td class="paramname">x0</td><td>: initial guess </td></tr>
    <tr><td class="paramname">e</td><td>: convergence criterium </td></tr>
    <tr><td class="paramname">n</td><td>: maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair whose first member is true is the algorithm converged and whose second member contains the solution </dd></dl>

</div>
</div>
<a id="a7d43a352f91a795ab4c35cc9cdb69d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d43a352f91a795ab4c35cc9cdb69d44">&#9670;&nbsp;</a></span>broyden2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt; tfel::math::broyden2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root of a function using the second Broyden algorithm</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>: size of the unknown </td></tr>
    <tr><td class="paramname">T</td><td>: numerical type </td></tr>
    <tr><td class="paramname">f</td><td>: function which root is sought after </td></tr>
    <tr><td class="paramname">x0</td><td>: initial guess </td></tr>
    <tr><td class="paramname">A</td><td>: initial approximation of the jacobian </td></tr>
    <tr><td class="paramname">e</td><td>: convergence criterium </td></tr>
    <tr><td class="paramname">n</td><td>: maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair whose first member is true is the algorithm converged and whose second member contains the solution </dd></dl>

</div>
</div>
<a id="ab12b80ec6e7aad8e4d37e970ecdc0a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12b80ec6e7aad8e4d37e970ecdc0a9d">&#9670;&nbsp;</a></span>broyden2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt; tfel::math::broyden2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root of a function using the first Broyden algorithm. The jacobian is initially approximated by the identity matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>: size of the unknown </td></tr>
    <tr><td class="paramname">T</td><td>: numerical type </td></tr>
    <tr><td class="paramname">f</td><td>: function which root is sought after </td></tr>
    <tr><td class="paramname">x0</td><td>: initial guess </td></tr>
    <tr><td class="paramname">e</td><td>: convergence criterium </td></tr>
    <tr><td class="paramname">n</td><td>: maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair whose first member is true is the algorithm converged and whose second member contains the solution </dd></dl>

</div>
</div>
<a id="a92faf512abe19e1716bd5aeeb215727a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92faf512abe19e1716bd5aeeb215727a">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type&gt;), <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;ST2toST2Type&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;ST2toST2Type&gt; &gt; &gt; tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const ST2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>change the basis of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>: rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9315cc19517d0879d4ec83c207c5f12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9315cc19517d0879d4ec83c207c5f12f">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;TensorType&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;TensorType&gt; &gt; &gt; tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>rotate a tensor using a rotation matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor to be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated tensor </dd></dl>

</div>
</div>
<a id="a55a3824dc0d8f442e4503f40aeca68ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55a3824dc0d8f442e4503f40aeca68ab">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#ab4449faeb9fd598523593e35ee14b53b">implementsT2toT2Concept</a>&lt;T2toT2Type&gt;), <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T2toT2Type&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;T2toT2Type&gt; &gt; &gt; tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const T2toT2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toT2Type &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>change the basis of a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>: rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b352e7024d14f544f90b5177d63c150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b352e7024d14f544f90b5177d63c150">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;TensorType&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;TensorType&gt; &gt; &gt; tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>rotate a tensor using a rotation matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor to be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated tensor </dd></dl>

</div>
</div>
<a id="a785578fb243ba7379d14469310bffb53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785578fb243ba7379d14469310bffb53">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type&gt;), <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;ST2toST2Type&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;ST2toST2Type&gt; &gt; &gt; tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const ST2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>change the basis of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>: rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c4773b39cfd8bb4428265941a317c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4773b39cfd8bb4428265941a317c0d">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;)==1u)), t2tost2&lt; 1u, numeric_type&lt; T2toST2Type &gt; &gt; &gt; tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>change the basis of a 1D <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80fcf6fb8e901b3db130cbcb4d3d5bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fcf6fb8e901b3db130cbcb4d3d5bfc">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;) !=1u)), t2tost2&lt; getSpaceDimension&lt; T2toST2Type &gt;), numeric_type&lt; T2toST2Type &gt; &gt; &gt; tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>change the basis of a 2D or 3D <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb613e701d1ad4958d1deade781b4414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb613e701d1ad4958d1deade781b4414">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#ab4449faeb9fd598523593e35ee14b53b">implementsT2toT2Concept</a>&lt;T2toT2Type&gt;), <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T2toT2Type&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;T2toT2Type&gt; &gt; &gt; tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const T2toT2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toT2Type &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>change the basis of a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>: rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51f058f2ba579764f989886f5d2204cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f058f2ba579764f989886f5d2204cd">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;StensorType&gt; &gt; &gt; tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>rotate a symmetric tensor using a rotation matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor to be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated symmetric tensor </dd></dl>

</div>
</div>
<a id="a331c0a1318f53ec008ca94d6576d179a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331c0a1318f53ec008ca94d6576d179a">&#9670;&nbsp;</a></span>checkIndexingPoliciesCompatiblity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::checkIndexingPoliciesCompatiblity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if two indexing policies can be compatible. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy1</td><td>first indexing policy </td></tr>
    <tr><td class="paramname">IndexingPolicy2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function is a simple wrapper around <code>IndexingPoliciesCompatiblityCheck::checkIndexingPoliciesCompatiblity</code>. </dd></dl>

</div>
</div>
<a id="a80897c96d06d4e3ddf5ff306dd6ea018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80897c96d06d4e3ddf5ff306dd6ea018">&#9670;&nbsp;</a></span>checkIndexingPoliciesRuntimeCompatiblity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::checkIndexingPoliciesRuntimeCompatiblity </td>
          <td>(</td>
          <td class="paramtype">const IndexingPolicy1 &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexingPolicy2 &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if two indexing policies are compatible at runtime. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy1</td><td>first indexing policy </td></tr>
    <tr><td class="paramname">IndexingPolicy2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>first indexing policy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function simply calls <code>areIndexingPoliciesCompatibleAtRunTime</code> and reports a contract violation if the two indexing policies are not compatible. </dd></dl>

</div>
</div>
<a id="a36f3980e1f02e7bf0310aa5055381e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f3980e1f02e7bf0310aa5055381e21">&#9670;&nbsp;</a></span>checkIndicesValiditity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy , typename... Indices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::checkIndicesValiditity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a simple function to check that the type of the indices are compatible with the given indexing policy </p>
<p><code>IndexingPolicy</code> concept</p>
<p>A class matching the <code>IndexingPolicy</code> concept must provide:</p>
<ul>
<li>An alias called <code>size_type</code> to the type used to index data.</li>
<li>An alias called <code>RowMajorIndexingPolicy</code> which can be used to import data from raw <code>C</code> pointers.</li>
<li>A static member data called <code>arity</code> of type <code>size_type</code>.</li>
<li>A static boolean data member called <code>hasFixedSizes</code>. If this data member is <code>true</code>, the class must be stateless, i.e. empty.</li>
<li>A static boolean data member called <code>areDataContiguous</code> which states if the data are continous</li>
<li>A member function called <code>size</code> which takes no argument returning the number of data values accessible by the indexing policy. This member function must be <code>constexpr</code> if <code>hasFixedSizes</code> is true.</li>
<li>A member function called <code>size</code> which takes a <code>size_type</code> argument returning range in the given dimension. This member function must be <code>constexpr</code> if <code>hasFixedSizes</code> is true.</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy</td><td>the indexing policy </td></tr>
    <tr><td class="paramname">Indices</td><td>list of indices types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae83c0c88dc13f3a63b043829e9476d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83c0c88dc13f3a63b043829e9476d85">&#9670;&nbsp;</a></span>computeCauchyStressDerivativeFromKirchhoffStressDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2ResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2ResultType &gt; &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt;::type tfel::math::computeCauchyStressDerivativeFromKirchhoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype">T2toST2ResultType &amp;&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname"><em>dt_K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the Cauchy stress derivative from the Kirchhoff stress derivative with respect to the deformation gradient </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ds</td><td>: Cauchy stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt_K</td><td>: Kirchhoff stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac16d930cb30282a40d1d77d65ff03a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16d930cb30282a40d1d77d65ff03a79">&#9670;&nbsp;</a></span>computeCauchyStressDerivativeFromKirchhoffStressDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result &gt; &gt; tfel::math::computeCauchyStressDerivativeFromKirchhoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the Cauchy stress derivative from the Kirchhoff stress derivative </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Kirchhoff stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b9de733baac066421cc5c9d577b8367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9de733baac066421cc5c9d577b8367">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorResultType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorResultType &gt; &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt; tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">StensorResultType &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dJ</td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67d6145614cfc7a02b44142898494444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67d6145614cfc7a02b44142898494444">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorResultType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorResultType &gt; &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt; tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">TensorResultType &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1499e2aa52c9ec314f85c8bf0c162ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1499e2aa52c9ec314f85c8bf0c162ecd">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result &gt; &gt; tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of the determinant </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>tensor where the the determinant is evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4bc48f30c8fed1b8168174b544f9859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bc48f30c8fed1b8168174b544f9859">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result &gt; &gt; tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of the determinant </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor where the the determinant is evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30d35d9d4f8833c39ec7d4709c8d8787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d35d9d4f8833c39ec7d4709c8d8787">&#9670;&nbsp;</a></span>computeDeterminantSecondDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt; &gt; tfel::math::computeDeterminantSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the second derivative of the determinant of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af60da59c3c50f7be9b71433847e9a3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60da59c3c50f7be9b71433847e9a3c2">&#9670;&nbsp;</a></span>computeDeviatorDeterminantDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorResultType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorResultType &gt; &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt; tfel::math::computeDeviatorDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">StensorResultType &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dJ</td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af23f6c82a8f24e6c16c644fa9078a0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23f6c82a8f24e6c16c644fa9078a0a9">&#9670;&nbsp;</a></span>computeDeviatorDeterminantDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_power.html">Power</a>&lt; 2 &gt; &gt;::Result &gt; &gt; tfel::math::computeDeviatorDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of the determinant of the deviator of symmetric tensor.</dd></dl>
<p>Let \(\underline{s}\) be a symmetric tensor and \(J_{3}\) be the determinant of \(\underline{s}&#39;\) the deviator of \(\underline{s}\): </p><p class="formulaDsp">
\[ J_{3} = \mathrm{det}\left(\underline{s}&#39;\right) = \mathrm{det}\left(\underline{s}-\mathrm{tr}\left(\underline{s}&#39;\right)\,\underline{I}\right) \]
</p>
<p>This function computes \(\displaystyle\frac{\partial J_{3}}{\partial \underline{\sigma}}\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor where the the determinant is evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97f7cc831deb38e98a6990381de38c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f7cc831deb38e98a6990381de38c58">&#9670;&nbsp;</a></span>computeDeviatorDeterminantSecondDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;::cond, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt; tfel::math::computeDeviatorDeterminantSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the second derivative of determinant of the deviator of a symmetric tensor with respect to this tensor. </p>
<p>compute the second derivative of the determinant of the deviator of symmetric tensor.</p>
<p>Let \(\underline{s}\) be a symmetric tensor and \(J_{3}\) be the determinant of \(\underline{s}&#39;\) the deviator of \(\underline{s}\): </p><p class="formulaDsp">
\[ J_{3} = \mathrm{det}\left(\underline{s}&#39;\right) = \mathrm{det}\left(\underline{s}-\mathrm{tr}\left(\underline{s}&#39;\right)\,\underline{I}\right) \]
</p>
<p>This function computes \(\displaystyle\frac{\partial^{2} J_{3}}{\partial \underline{\sigma}^{2}}\).</p>
<p>[ </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor</td></tr>
  </table>
  </dd>
</dl>
<p>Let \(\underline{s}\) be a symmetric tensor and \(J_{3}\) be the determinant of \(\underline{s}&#39;\) the deviator of \(\underline{s}\): </p><p class="formulaDsp">
\[ J_{3} = \mathrm{det}\left(\underline{s}&#39;\right) = \mathrm{det}\left(\underline{s}-\mathrm{tr}\left(\underline{s}&#39;\right)\,\underline{I}\right) \]
</p>
<p>This function computes \(\displaystyle\frac{\partial^{2} J_{3}}{\partial \underline{\sigma}^{2}}\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95b82be6fc5983001efb1ded3aa3fd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b82be6fc5983001efb1ded3aa3fd71">&#9670;&nbsp;</a></span>computeIsotropicFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename stensor_common::EigenSolver es, typename Function , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt; tfel::math::computeIsotropicFunction </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the value of an isotropic function </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41154073d187923d273ce8f09789b1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41154073d187923d273ce8f09789b1a7">&#9670;&nbsp;</a></span>computeIsotropicFunctionDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename stensor_common::EigenSolver es, typename Function , typename FunctionDerivative , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt; tfel::math::computeIsotropicFunctionDerivative </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctionDerivative &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of an isotropic function </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">df</td><td>derivative of the function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>criterion value used to judge if two eigenvalues are equals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad63608e2087a9dc5870e39d96df810d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad63608e2087a9dc5870e39d96df810d6">&#9670;&nbsp;</a></span>computeIsotropicFunctionDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename stensor_common::EigenSolver es, typename Function , typename FunctionDerivative , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), std::pair&lt; <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;, <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt; &gt; tfel::math::computeIsotropicFunctionDerivative </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctionDerivative &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of an isotropic function </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">df</td><td>derivative of the function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>criterion value used to judge if two eigenvalues are equals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb6b2c3bbdb5429dd31dcd9ad1d25eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6b2c3bbdb5429dd31dcd9ad1d25eb7">&#9670;&nbsp;</a></span>computeKirchhoffStressDerivativeFromCauchyStressDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2ResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_assignable_to.html">tfel::typetraits::IsAssignableTo</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2ResultType &gt; &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt;::type tfel::math::computeKirchhoffStressDerivativeFromCauchyStressDerivative </td>
          <td>(</td>
          <td class="paramtype">T2toST2ResultType &amp;&#160;</td>
          <td class="paramname"><em>dt_K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the Kirchhoff stress derivative from the Cauchy stress derivative with respect to the deformation gradient </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dt_K</td><td>: Kirchhoff stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>: Cauchy stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedeb1ec5f7ff7879b81d46ec9f202b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedeb1ec5f7ff7879b81d46ec9f202b25">&#9670;&nbsp;</a></span>computeKirchhoffStressDerivativeFromCauchyStressDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::cond, <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2Type &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; T2toST2Type &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a> &gt;::Result &gt; &gt; tfel::math::computeKirchhoffStressDerivativeFromCauchyStressDerivative </td>
          <td>(</td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the Cauchy stress derivative from the Kirchhoff stress derivative </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Kirchhoff stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13b583fdf3548912d7cfa9142b3313f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b583fdf3548912d7cfa9142b3313f6">&#9670;&nbsp;</a></span>computePushForwardDerivative() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2ResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==1u &amp;&amp;getSpaceDimension&lt; T2toST2Type &gt;)==1u &amp;&amp;getSpaceDimension&lt; StensorType &gt;)==1u &amp;&amp;getSpaceDimension&lt; TensorType &gt;)==1u &amp;&amp;tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; TensorType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeBinaryResult&lt; numeric_type&lt; T2toST2Type &gt;, numeric_type&lt; StensorType &gt;, OpPlus &gt;::Result, numeric_type&lt; T2toST2ResultType &gt; &gt;::cond, void &gt;::type tfel::math::computePushForwardDerivative </td>
          <td>(</td>
          <td class="paramtype">T2toST2ResultType &amp;&#160;</td>
          <td class="paramname"><em>dTdF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname"><em>dSdF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient knowing the value of this derivative in the initial configuration. </p>
<p>This function is typically used to compute the derivative of the Kirchhoff stress tensor knowing the derivative of the second Piola-Kirschoff stress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>derivative of the push-forward symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>derivative of the orginal tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>orginal tensor (second Piola-Kirschoff stress) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3555b49b9ca6aece066d4bd0e06b163f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3555b49b9ca6aece066d4bd0e06b163f">&#9670;&nbsp;</a></span>computePushForwardDerivative() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2ResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==2u &amp;&amp;getSpaceDimension&lt; T2toST2Type &gt;)==2u &amp;&amp;getSpaceDimension&lt; StensorType &gt;)==2u &amp;&amp;getSpaceDimension&lt; TensorType &gt;)==2u &amp;&amp;tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; TensorType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeBinaryResult&lt; numeric_type&lt; T2toST2Type &gt;, numeric_type&lt; StensorType &gt;, OpPlus &gt;::Result, numeric_type&lt; T2toST2ResultType &gt; &gt;::cond, void &gt;::type tfel::math::computePushForwardDerivative </td>
          <td>(</td>
          <td class="paramtype">T2toST2ResultType &amp;&#160;</td>
          <td class="paramname"><em>dTdF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname"><em>dSdF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient knowing the value of this derivative in the initial configuration. </p>
<p>This function is typically used to compute the derivative of the Kirchhoff stress tensor knowing the derivative of the second Piola-Kirschoff stress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>derivative of the push-forward symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>derivative of the orginal tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>orginal tensor (second Piola-Kirschoff stress) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7cdbd1f152a98b46f4032da97da159c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7cdbd1f152a98b46f4032da97da159c">&#9670;&nbsp;</a></span>computePushForwardDerivative() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2ResultType , typename T2toST2Type , typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2ResultType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt; T2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toST2ResultType &gt;)==3u &amp;&amp;getSpaceDimension&lt; T2toST2Type &gt;)==3u &amp;&amp;getSpaceDimension&lt; StensorType &gt;)==3u &amp;&amp;getSpaceDimension&lt; TensorType &gt;)==3u &amp;&amp;tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; TensorType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; typename ComputeBinaryResult&lt; numeric_type&lt; T2toST2Type &gt;, numeric_type&lt; StensorType &gt;, OpPlus &gt;::Result, numeric_type&lt; T2toST2ResultType &gt; &gt;::cond, void &gt;::type tfel::math::computePushForwardDerivative </td>
          <td>(</td>
          <td class="paramtype">T2toST2ResultType &amp;&#160;</td>
          <td class="paramname"><em>dTdF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname"><em>dSdF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient knowing the value of this derivative in the initial configuration. </p>
<p>This function is typically used to compute the derivative of the Kirchhoff stress tensor knowing the derivative of the second Piola-Kirschoff stress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>derivative of the push-forward symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>derivative of the orginal tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>orginal tensor (second Piola-Kirschoff stress) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7480737e8f2f94319b4d4908978ff51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7480737e8f2f94319b4d4908978ff51">&#9670;&nbsp;</a></span>computeRateOfDeformationDerivative() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==1u), t2tost2&lt; 1u, numeric_type&lt; TensorType &gt; &gt; &gt; tfel::math::computeRateOfDeformationDerivative </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the "derivative" of the rate of deformation  D = dD_dF: F with  D = ((delta F).F^{-1}+F^{-T}.(delta F)^{T})/2 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the rate of deformation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14e3d77920aa3d04c4930dbf4cf04890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e3d77920aa3d04c4930dbf4cf04890">&#9670;&nbsp;</a></span>computeRateOfDeformationDerivative() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;TensorType&gt;) == 1u), t2tost2&lt;1u, numeric_type&lt;TensorType&gt; &gt; &gt; tfel::math::computeRateOfDeformationDerivative </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the "derivative" of the rate of deformation  D = dD_dF: F with  D = ((delta F).F^{-1}+F^{-T}.(delta F)^{T})/2 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the rate of deformation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada2e2188caf4906eb42a0aae4bd4f912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2e2188caf4906eb42a0aae4bd4f912">&#9670;&nbsp;</a></span>computeRateOfDeformationDerivative() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==2u), t2tost2&lt; 2u, numeric_type&lt; TensorType &gt; &gt; &gt; tfel::math::computeRateOfDeformationDerivative </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the rate of deformation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7238e18fd93e6ecad55e2f43c1baf4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7238e18fd93e6ecad55e2f43c1baf4c5">&#9670;&nbsp;</a></span>computeRateOfDeformationDerivative() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; (<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;TensorType&gt;) == 3u), t2tost2&lt;3u, numeric_type&lt;TensorType&gt; &gt; &gt; tfel::math::computeRateOfDeformationDerivative </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the "derivative" of the rate of deformation  D = dD_dF: F with  D = ((delta F).F^{-1}+F^{-T}.(delta F)^{T})/2 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the rate of deformation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ced7406fddd581d8abd8d371e460921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ced7406fddd581d8abd8d371e460921">&#9670;&nbsp;</a></span>computeSpinRateDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;), <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;TensorType&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;TensorType&gt; &gt; &gt; tfel::math::computeSpinRateDerivative </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the spin rate </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8c9a04955d98725842deead7aa1e71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c9a04955d98725842deead7aa1e71f">&#9670;&nbsp;</a></span>computeSpinRateDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;), <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;TensorType&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;TensorType&gt; &gt; &gt; tfel::math::computeSpinRateDerivative </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the spin rate </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ef81fed87dcc9d816335a077ad35752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ef81fed87dcc9d816335a077ad35752">&#9670;&nbsp;</a></span>computeStensorDecompositionInPositiveAndNegativeParts() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DPPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DNPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; PPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; NPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DPPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DNPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; PPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; NPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; NPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DPPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DNPType &gt; &gt;::cond, void &gt;::type tfel::math::computeStensorDecompositionInPositiveAndNegativeParts </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname"><em>dpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DNPType &amp;&#160;</td>
          <td class="paramname"><em>dnp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NPType &amp;&#160;</td>
          <td class="paramname"><em>np</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">DNPType</td><td>: type in which derivative of the negative part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname">NPType</td><td>: type of negative part of the symmetric tensor </td></tr>
    <tr><td class="paramname">StensorType</td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dnp</td><td>: derivative of the negative part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">np</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
DNPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
NPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
StensorType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="a987e568afd7dde8e7272c2e8e887236e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987e568afd7dde8e7272c2e8e887236e">&#9670;&nbsp;</a></span>computeStensorDecompositionInPositiveAndNegativeParts() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DPPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DNPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; PPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; NPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DPPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DNPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; PPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; NPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; NPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DPPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DNPType &gt; &gt;::cond, void &gt;::type tfel::math::computeStensorDecompositionInPositiveAndNegativeParts </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname"><em>dpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DNPType &amp;&#160;</td>
          <td class="paramname"><em>dnp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NPType &amp;&#160;</td>
          <td class="paramname"><em>np</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">DNPType</td><td>: type in which derivative of the negative part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname">NPType</td><td>: type of negative part of the symmetric tensor </td></tr>
    <tr><td class="paramname">StensorType</td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dnp</td><td>: derivative of the negative part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">np</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
DNPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
NPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
StensorType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="abaafe116cda097bc610f2c0f986de95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaafe116cda097bc610f2c0f986de95f">&#9670;&nbsp;</a></span>computeStensorDecompositionInPositiveAndNegativeParts() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;DPPType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;DNPType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;PPType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;NPType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;DPPType&gt;) == <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;DNPType&gt;) == <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;PPType&gt;) == <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;NPType&gt;) == <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) == 3u &amp;&amp; tfel::typetraits::IsAssignableTo&lt;numeric_type&lt;StensorType&gt;, numeric_type&lt;PPType&gt; &gt;::cond &amp;&amp; tfel::typetraits::IsAssignableTo&lt;numeric_type&lt;StensorType&gt;, numeric_type&lt;NPType&gt; &gt;::cond &amp;&amp; tfel::typetraits::IsAssignableTo&lt; base_type&lt;numeric_type&lt;StensorType&gt; &gt;, numeric_type&lt;DPPType&gt; &gt;::cond &amp;&amp; tfel::typetraits::IsAssignableTo&lt; base_type&lt;numeric_type&lt;StensorType&gt; &gt;, numeric_type&lt;DNPType&gt; &gt;::cond, void&gt;::type tfel::math::computeStensorDecompositionInPositiveAndNegativeParts </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DNPType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NPType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">DNPType</td><td>: type in which derivative of the negative part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname">NPType</td><td>: type of negative part of the symmetric tensor </td></tr>
    <tr><td class="paramname">StensorType</td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dnp</td><td>: derivative of the negative part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">np</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
DNPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
NPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
StensorType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="a6560667a2bd69f2ab0cdb3c06aded550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6560667a2bd69f2ab0cdb3c06aded550">&#9670;&nbsp;</a></span>computeStensorDecompositionInPositiveAndNegativeParts() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename DNPType , typename PPType , typename NPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;DPPType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;DNPType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;PPType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;NPType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;DPPType&gt;) == <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;DNPType&gt;) == <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;PPType&gt;) == <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;NPType&gt;) == <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) == 3u &amp;&amp; tfel::typetraits::IsAssignableTo&lt;numeric_type&lt;StensorType&gt;, numeric_type&lt;PPType&gt; &gt;::cond &amp;&amp; tfel::typetraits::IsAssignableTo&lt;numeric_type&lt;StensorType&gt;, numeric_type&lt;NPType&gt; &gt;::cond &amp;&amp; tfel::typetraits::IsAssignableTo&lt; base_type&lt;numeric_type&lt;StensorType&gt; &gt;, numeric_type&lt;DPPType&gt; &gt;::cond &amp;&amp; tfel::typetraits::IsAssignableTo&lt; base_type&lt;numeric_type&lt;StensorType&gt; &gt;, numeric_type&lt;DNPType&gt; &gt;::cond, void&gt; tfel::math::computeStensorDecompositionInPositiveAndNegativeParts </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname"><em>dpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DNPType &amp;&#160;</td>
          <td class="paramname"><em>dnp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NPType &amp;&#160;</td>
          <td class="paramname"><em>np</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">DNPType</td><td>: type in which derivative of the negative part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname">NPType</td><td>: type of negative part of the symmetric tensor </td></tr>
    <tr><td class="paramname">StensorType</td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dnp</td><td>: derivative of the negative part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">np</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
DNPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
NPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
StensorType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="a4265adf56378e36079f0d2f1358f4550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4265adf56378e36079f0d2f1358f4550">&#9670;&nbsp;</a></span>computeStensorPositivePartAndDerivative() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename PPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DPPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; PPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DPPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; PPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DPPType &gt; &gt;::cond, void &gt; tfel::math::computeStensorPositivePartAndDerivative </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname"><em>dpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname">StensorType</td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
StensorType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="a1dc45c3738a1ef88b44173ebafb2c85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc45c3738a1ef88b44173ebafb2c85a">&#9670;&nbsp;</a></span>computeStensorPositivePartAndDerivative() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename PPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; DPPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; PPType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; DPPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; PPType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u &amp;&amp;tfel::typetraits::IsAssignableTo&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; PPType &gt; &gt;::cond &amp;&amp;tfel::typetraits::IsAssignableTo&lt; base_type&lt; numeric_type&lt; StensorType &gt; &gt;, numeric_type&lt; DPPType &gt; &gt;::cond, void &gt; tfel::math::computeStensorPositivePartAndDerivative </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname"><em>dpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname">StensorType</td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
StensorType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="a97623187184e8ceaa09e7c1abba413a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97623187184e8ceaa09e7c1abba413a7">&#9670;&nbsp;</a></span>computeStensorPositivePartAndDerivative() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename PPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;DPPType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;PPType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;DPPType&gt;) == <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;PPType&gt;) == <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) == 3u &amp;&amp; tfel::typetraits::IsAssignableTo&lt;numeric_type&lt;StensorType&gt;, numeric_type&lt;PPType&gt; &gt;::cond &amp;&amp; tfel::typetraits::IsAssignableTo&lt; base_type&lt;numeric_type&lt;StensorType&gt; &gt;, numeric_type&lt;DPPType&gt; &gt;::cond, void&gt; tfel::math::computeStensorPositivePartAndDerivative </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname">StensorType</td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
StensorType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="a50811a7e2eec21596cfcbe4e85709d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50811a7e2eec21596cfcbe4e85709d6e">&#9670;&nbsp;</a></span>computeStensorPositivePartAndDerivative() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DPPType , typename PPType , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;DPPType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;PPType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;DPPType&gt;) == <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;PPType&gt;) == <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) == 3u &amp;&amp; tfel::typetraits::IsAssignableTo&lt;numeric_type&lt;StensorType&gt;, numeric_type&lt;PPType&gt; &gt;::cond &amp;&amp; tfel::typetraits::IsAssignableTo&lt; base_type&lt;numeric_type&lt;StensorType&gt; &gt;, numeric_type&lt;DPPType&gt; &gt;::cond, void&gt;::type tfel::math::computeStensorPositivePartAndDerivative </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname"><em>dpp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname">StensorType</td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a> </dd>
<dd>
PPType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd>
<dd>
StensorType must implement the <a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a> </dd></dl>

</div>
</div>
<a id="a9289437d989515475c5188ad01e77dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9289437d989515475c5188ad01e77dbe">&#9670;&nbsp;</a></span>computeVelocityGradientDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;), <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;TensorType&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;TensorType&gt; &gt; &gt; tfel::math::computeVelocityGradientDerivative </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the velocity gradient </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7139107f7382d90f0261c27affceeb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7139107f7382d90f0261c27affceeb1d">&#9670;&nbsp;</a></span>computeVelocityGradientDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;), <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;TensorType&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;TensorType&gt; &gt; &gt; tfel::math::computeVelocityGradientDerivative </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the velocity gradient </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a600d19fd973cd5038b585498516862dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600d19fd973cd5038b585498516862dc">&#9670;&nbsp;</a></span>convertCauchyStressDerivativeToFirstPiolaKirchoffStressDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename stress , typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; tfel::math::convertCauchyStressDerivativeToFirstPiolaKirchoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the derivative of the Cauchy stress with respect to the deformation gradient to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>spatial dimension </td></tr>
    <tr><td class="paramname">stress</td><td>stress type </td></tr>
    <tr><td class="paramname">real</td><td>numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>derivative of the Cauchy stress with respect to the deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient. </dd></dl>

</div>
</div>
<a id="a7008df38bf4fc3f8170249537b46190a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7008df38bf4fc3f8170249537b46190a">&#9670;&nbsp;</a></span>convertCauchyStressDerivativeToFirstPiolaKirchoffStressDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename stress , typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::convertCauchyStressDerivativeToFirstPiolaKirchoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>dP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the derivative of the Cauchy stress with respect to the deformation gradient to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>spatial dimension </td></tr>
    <tr><td class="paramname">stress</td><td>stress type </td></tr>
    <tr><td class="paramname">real</td><td>numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dP</td><td>derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>derivative of the Cauchy stress with respect to the deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d03ae4884ce7c6aa873a80adb3987b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d03ae4884ce7c6aa873a80adb3987b5">&#9670;&nbsp;</a></span>convertCauchyStressToFirstPiolaKirchhoffStress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;)), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;), typename <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>&lt;<a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;StensorType&gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;TensorType&gt;, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;::type&gt; &gt; tfel::math::convertCauchyStressToFirstPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the Cauchy stress to the first Piola-Kirchhoff stress. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StensorType</td><td>type of the Cauchy stress </td></tr>
    <tr><td class="paramname">TensorType</td><td>type of the deformation gradient</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a98c82810ca888e374837d24894cfc389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c82810ca888e374837d24894cfc389">&#9670;&nbsp;</a></span>convertCauchyStressToFirstPiolaKirchhoffStress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;)), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;), typename <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>&lt;<a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;StensorType&gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;TensorType&gt;, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;::type&gt; &gt; tfel::math::convertCauchyStressToFirstPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the Cauchy stress to the first Piola-Kirchhoff stress. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StensorType</td><td>type of the Cauchy stress </td></tr>
    <tr><td class="paramname">TensorType</td><td>type of the deformation gradient</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a5f1a7c23d454975e920f67292f6166c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1a7c23d454975e920f67292f6166c4">&#9670;&nbsp;</a></span>convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T&gt;) == 1u) &amp;&amp; (implementsStensorConcept&lt;T2&gt;)) &amp;&amp; (getSpaceDimension&lt;T2&gt;) == 1u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;numeric_type&lt;T2&gt; &gt;::cond)), stensor&lt;1u, numeric_type&lt;T&gt; &gt; &gt; tfel::math::convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>corotationnal cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a0656220b299ad4e90cedbbc859795c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0656220b299ad4e90cedbbc859795c95">&#9670;&nbsp;</a></span>convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T&gt;) == 2u) &amp;&amp; (implementsStensorConcept&lt;T2&gt;)) &amp;&amp; (getSpaceDimension&lt;T2&gt;) == 2u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;numeric_type&lt;T2&gt; &gt;::cond)), stensor&lt;2u, numeric_type&lt;T&gt; &gt; &gt; tfel::math::convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>corotationnal cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a7848eac865ac7a03f5a066bbbb84b7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7848eac865ac7a03f5a066bbbb84b7ef">&#9670;&nbsp;</a></span>convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T&gt;) == 3u) &amp;&amp; (implementsStensorConcept&lt;T2&gt;)) &amp;&amp; (getSpaceDimension&lt;T2&gt;) == 3u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;numeric_type&lt;T2&gt; &gt;::cond)), stensor&lt;3u, numeric_type&lt;T&gt; &gt; &gt; tfel::math::convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>corotationnal cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a0f691d19432165784cf9244cde14fd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f691d19432165784cf9244cde14fd0e">&#9670;&nbsp;</a></span>convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T&gt;) == 1u) &amp;&amp; (implementsStensorConcept&lt;T2&gt;)) &amp;&amp; (getSpaceDimension&lt;T2&gt;) == 1u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;numeric_type&lt;T2&gt; &gt;::cond)), stensor&lt;1u, numeric_type&lt;T&gt; &gt; &gt; tfel::math::convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>corotationnal cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a53200c8ef0a8447da9392a83d72b3b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53200c8ef0a8447da9392a83d72b3b06">&#9670;&nbsp;</a></span>convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T&gt;) == 2u) &amp;&amp; (implementsStensorConcept&lt;T2&gt;)) &amp;&amp; (getSpaceDimension&lt;T2&gt;) == 2u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;numeric_type&lt;T2&gt; &gt;::cond)), stensor&lt;2u, numeric_type&lt;T&gt; &gt; &gt; tfel::math::convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>corotationnal cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a6f0359ce444207d45ed70c6850be838d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0359ce444207d45ed70c6850be838d">&#9670;&nbsp;</a></span>convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T&gt;) == 3u) &amp;&amp; (implementsStensorConcept&lt;T2&gt;)) &amp;&amp; (getSpaceDimension&lt;T2&gt;) == 3u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;numeric_type&lt;T2&gt; &gt;::cond)), stensor&lt;3u, numeric_type&lt;T&gt; &gt; &gt; tfel::math::convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>corotationnal cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="ae71aa7e88b74745f06895b0661b09c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71aa7e88b74745f06895b0661b09c2c">&#9670;&nbsp;</a></span>convertFirstPiolaKirchhoffStressToCauchyStress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType , typename TensorType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType2 &gt;)), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), typename <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType2 &gt;, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::type &gt; &gt; tfel::math::convertFirstPiolaKirchhoffStressToCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the first Piola-Kirchhoff stress to the Cauchy stress </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorType</td><td>type of the first Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramname">TensorType2</td><td>type of the deformation gradient</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Cauchy stress </dd></dl>

</div>
</div>
<a id="ae9e2a6404efc797b0b27f03d0a20d1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e2a6404efc797b0b27f03d0a20d1d4">&#9670;&nbsp;</a></span>convertFirstPiolaKirchoffStressDerivativeToKirchhoffStressDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename stress , typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt; tfel::math::convertFirstPiolaKirchoffStressDerivativeToKirchhoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>dP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the derivative of the first Piola-Kirchhoff stress with first Piola-Kirchhoff deformation gradient to the derivative of the Kirchhoff stress with respect to the deformation gradient. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>spatial dimension </td></tr>
    <tr><td class="paramname">stress</td><td>stress type </td></tr>
    <tr><td class="paramname">real</td><td>numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dP</td><td>derivative of first Piola-Kirchhoff stress the with respect to the deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derivative of the Kirchhoff stress with respect to the deformation gradient. </dd></dl>

</div>
</div>
<a id="a7670684c63476243218ae3531e597546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7670684c63476243218ae3531e597546">&#9670;&nbsp;</a></span>convertFirstPiolaKirchoffStressDerivativeToKirchhoffStressDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename stress , typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::convertFirstPiolaKirchoffStressDerivativeToKirchhoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>dtau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>dP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the derivative of the first Piola-Kirchhoff stress with first Piola-Kirchhoff deformation gradient to the derivative of the Kirchhoff stress with respect to the deformation gradient. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>spatial dimension </td></tr>
    <tr><td class="paramname">stress</td><td>stress type </td></tr>
    <tr><td class="paramname">real</td><td>numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ds</td><td>derivative of the Kirchhoff stress with respect to the deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dP</td><td>derivative of first Piola-Kirchhoff stress the with respect to the deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acce7f75958777ea853a9b64d93d6a994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce7f75958777ea853a9b64d93d6a994">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressDerivativeToFirstPiolaKirchoffStressDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename stress , typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; tfel::math::convertSecondPiolaKirchhoffStressDerivativeToFirstPiolaKirchoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>dS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the derivative of the second Piola-Kirchoff stress with respect to the Green-Lagrange strain to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>spatial dimension </td></tr>
    <tr><td class="paramname">stress</td><td>stress type </td></tr>
    <tr><td class="paramname">real</td><td>numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dS</td><td>derivative of the second Piola-Kirchoff stress with respect to the Green-Lagrange strain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient. </dd></dl>

</div>
</div>
<a id="af2f42fbb8c13638c5a527d08c44ab55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f42fbb8c13638c5a527d08c44ab55a">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressDerivativeToFirstPiolaKirchoffStressDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename stress , typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::convertSecondPiolaKirchhoffStressDerivativeToFirstPiolaKirchoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>dP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>dS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the derivative of the second Piola-Kirchoff stress with respect to the Green-Lagrange strain to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>spatial dimension </td></tr>
    <tr><td class="paramname">stress</td><td>stress type </td></tr>
    <tr><td class="paramname">real</td><td>numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dP</td><td>derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dS</td><td>derivative of the second Piola-Kirchoff stress with respect to the Green-Lagrange strain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a213f38bbf9ab17938a77246991925d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213f38bbf9ab17938a77246991925d71">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T&gt;) == 1u) &amp;&amp; (implementsStensorConcept&lt;T2&gt;)) &amp;&amp; (getSpaceDimension&lt;T2&gt;) == 1u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;numeric_type&lt;T2&gt; &gt;::cond)), stensor&lt;1u, numeric_type&lt;T&gt; &gt; &gt; tfel::math::convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>the second Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corotationnal cauchy stress </dd></dl>

</div>
</div>
<a id="a9970951902efc0e635ffe55dc21a7ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9970951902efc0e635ffe55dc21a7ead">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T&gt;) == 2u) &amp;&amp; (implementsStensorConcept&lt;T2&gt;)) &amp;&amp; (getSpaceDimension&lt;T2&gt;) == 2u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;numeric_type&lt;T2&gt; &gt;::cond)), stensor&lt;2u, numeric_type&lt;T&gt; &gt; &gt; tfel::math::convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>the second Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corotationnal cauchy stress </dd></dl>

</div>
</div>
<a id="a4122960126737bee5dc4be477c2d304c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4122960126737bee5dc4be477c2d304c">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T&gt;) == 3u) &amp;&amp; (implementsStensorConcept&lt;T2&gt;)) &amp;&amp; (getSpaceDimension&lt;T2&gt;) == 3u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;numeric_type&lt;T2&gt; &gt;::cond)), stensor&lt;3u, numeric_type&lt;T&gt; &gt; &gt; tfel::math::convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>the second Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corotationnal cauchy stress </dd></dl>

</div>
</div>
<a id="aa319105825cf1e9bde644773a2f73b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa319105825cf1e9bde644773a2f73b18">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T&gt;) == 1u) &amp;&amp; (implementsStensorConcept&lt;T2&gt;)) &amp;&amp; (getSpaceDimension&lt;T2&gt;) == 1u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;numeric_type&lt;T2&gt; &gt;::cond)), stensor&lt;1u, numeric_type&lt;T&gt; &gt; &gt; tfel::math::convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>the second Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corotationnal cauchy stress </dd></dl>

</div>
</div>
<a id="a5ec1c73a8d6a4bdc61f8021c10220370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec1c73a8d6a4bdc61f8021c10220370">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T&gt;) == 2u) &amp;&amp; (implementsStensorConcept&lt;T2&gt;)) &amp;&amp; (getSpaceDimension&lt;T2&gt;) == 2u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;numeric_type&lt;T2&gt; &gt;::cond)), stensor&lt;2u, numeric_type&lt;T&gt; &gt; &gt; tfel::math::convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>the second Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corotationnal cauchy stress </dd></dl>

</div>
</div>
<a id="a3bf7a7700bcb2bbf31d84118b7f16e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf7a7700bcb2bbf31d84118b7f16e2f">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T&gt;) == 3u) &amp;&amp; (implementsStensorConcept&lt;T2&gt;)) &amp;&amp; (getSpaceDimension&lt;T2&gt;) == 3u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt;numeric_type&lt;T2&gt; &gt;::cond)), stensor&lt;3u, numeric_type&lt;T&gt; &gt; &gt; tfel::math::convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p><p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>the second Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corotationnal cauchy stress </dd></dl>

</div>
</div>
<a id="aec89b9fce29718c2807dfee5fbeb93fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec89b9fce29718c2807dfee5fbeb93fc">&#9670;&nbsp;</a></span>convertSpatialModuliToKirchhoffJaumanRateModuli() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;ST2toST2Type&gt;) == 1u) &amp;&amp; (getSpaceDimension&lt;StensorType&gt;) == 1u) &amp;&amp; implementsST2toST2Concept&lt;ST2toST2Type&gt;) &amp;&amp; implementsStensorConcept&lt;StensorType&gt;) &amp;&amp; std::is_same_v&lt;numeric_type&lt;ST2toST2Type&gt;, numeric_type&lt;StensorType&gt; &gt;), st2tost2&lt;1u, numeric_type&lt;ST2toST2Type&gt; &gt; &gt;::type tfel::math::convertSpatialModuliToKirchhoffJaumanRateModuli </td>
          <td>(</td>
          <td class="paramtype">const ST2toST2Type &amp;&#160;</td>
          <td class="paramname"><em>C_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the spatial moduli in the moduli associated with Jauman rate of the Kirchhoff stress </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C_s</td><td>spatial moduli </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>Kirchhoff stress </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the moduli associated with Jauman rate of the Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a6b6e322a1f3214196833b24e8a298960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6e322a1f3214196833b24e8a298960">&#9670;&nbsp;</a></span>convertSpatialModuliToKirchhoffJaumanRateModuli() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;ST2toST2Type&gt;) == 2u) &amp;&amp; (getSpaceDimension&lt;StensorType&gt;) == 2u) &amp;&amp; implementsST2toST2Concept&lt;ST2toST2Type&gt;) &amp;&amp; implementsStensorConcept&lt;StensorType&gt;) &amp;&amp; std::is_same_v&lt;numeric_type&lt;ST2toST2Type&gt;, numeric_type&lt;StensorType&gt; &gt;), st2tost2&lt;2u, numeric_type&lt;ST2toST2Type&gt; &gt; &gt;::type tfel::math::convertSpatialModuliToKirchhoffJaumanRateModuli </td>
          <td>(</td>
          <td class="paramtype">const ST2toST2Type &amp;&#160;</td>
          <td class="paramname"><em>C_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the spatial moduli in the moduli associated with Jauman rate of the Kirchhoff stress </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C_s</td><td>spatial moduli </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>Kirchhoff stress </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the moduli associated with Jauman rate of the Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a824e8fcc7047d972cf62034191af00a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824e8fcc7047d972cf62034191af00a6">&#9670;&nbsp;</a></span>convertSpatialModuliToKirchhoffJaumanRateModuli() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;ST2toST2Type&gt;) == 3u) &amp;&amp; (getSpaceDimension&lt;StensorType&gt;) == 3u) &amp;&amp; implementsST2toST2Concept&lt;ST2toST2Type&gt;) &amp;&amp; implementsStensorConcept&lt;StensorType&gt;) &amp;&amp; std::is_same_v&lt;numeric_type&lt;ST2toST2Type&gt;, numeric_type&lt;StensorType&gt; &gt;), st2tost2&lt;3u, numeric_type&lt;ST2toST2Type&gt; &gt; &gt;::type tfel::math::convertSpatialModuliToKirchhoffJaumanRateModuli </td>
          <td>(</td>
          <td class="paramtype">const ST2toST2Type &amp;&#160;</td>
          <td class="paramname"><em>C_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the spatial moduli in the moduli associated with Jauman rate of the Kirchhoff stress </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C_s</td><td>spatial moduli </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tau</td><td>Kirchhoff stress </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the moduli associated with Jauman rate of the Kirchhoff stress </dd></dl>

</div>
</div>
<a id="ad78fe00c681ff46339dec85d0759c2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78fe00c681ff46339dec85d0759c2d9">&#9670;&nbsp;</a></span>convertToT2toST2() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T2toT2Type&gt;) == 1u) &amp;&amp; implementsT2toT2Concept&lt;T2toT2Type&gt;)), t2tost2&lt;1u, numeric_type&lt;T2toT2Type&gt; &gt; &gt; tfel::math::convertToT2toST2 </td>
          <td>(</td>
          <td class="paramtype">const T2toT2Type &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> </p>

</div>
</div>
<a id="a6f7a5a0e31742130e108506ba579c312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7a5a0e31742130e108506ba579c312">&#9670;&nbsp;</a></span>convertToT2toST2() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T2toT2Type&gt;) == 2u) &amp;&amp; implementsT2toT2Concept&lt;T2toT2Type&gt;)), t2tost2&lt;2u, numeric_type&lt;T2toT2Type&gt; &gt; &gt; tfel::math::convertToT2toST2 </td>
          <td>(</td>
          <td class="paramtype">const T2toT2Type &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> </p>

</div>
</div>
<a id="aeabc8f24a5af1bc52c7dd2c7158f7231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeabc8f24a5af1bc52c7dd2c7158f7231">&#9670;&nbsp;</a></span>convertToT2toST2() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T2toT2Type&gt;) == 1u) &amp;&amp; implementsT2toT2Concept&lt;T2toT2Type&gt;)), t2tost2&lt;1u, numeric_type&lt;T2toT2Type&gt; &gt; &gt; tfel::math::convertToT2toST2 </td>
          <td>(</td>
          <td class="paramtype">const T2toT2Type &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> </p>

</div>
</div>
<a id="ab38af0aa5982cdefbba8a050e7c5dd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38af0aa5982cdefbba8a050e7c5dd30">&#9670;&nbsp;</a></span>convertToT2toST2() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T2toT2Type&gt;) == 3u) &amp;&amp; implementsT2toT2Concept&lt;T2toT2Type&gt;)), t2tost2&lt;3u, numeric_type&lt;T2toT2Type&gt; &gt; &gt; tfel::math::convertToT2toST2 </td>
          <td>(</td>
          <td class="paramtype">const T2toT2Type &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> </p>

</div>
</div>
<a id="a8bf9cfac53f2c7faa1a4d5c662dfad76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf9cfac53f2c7faa1a4d5c662dfad76">&#9670;&nbsp;</a></span>convertToT2toST2() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T2toT2Type&gt;) == 2u) &amp;&amp; implementsT2toT2Concept&lt;T2toT2Type&gt;)), t2tost2&lt;2u, numeric_type&lt;T2toT2Type&gt; &gt; &gt; tfel::math::convertToT2toST2 </td>
          <td>(</td>
          <td class="paramtype">const T2toT2Type &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> </p>

</div>
</div>
<a id="aa7ef36f3eca9a7a5eede27a0a37ae738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ef36f3eca9a7a5eede27a0a37ae738">&#9670;&nbsp;</a></span>convertToT2toST2() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T2toT2Type&gt;) == 3u) &amp;&amp; implementsT2toT2Concept&lt;T2toT2Type&gt;)), t2tost2&lt;3u, numeric_type&lt;T2toT2Type&gt; &gt; &gt; tfel::math::convertToT2toST2 </td>
          <td>(</td>
          <td class="paramtype">const T2toT2Type &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor. ">t2tost2</a> </p>

</div>
</div>
<a id="a7e51f6336446d61234a7fc928ad7f67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e51f6336446d61234a7fc928ad7f67a">&#9670;&nbsp;</a></span>det() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#ab4449faeb9fd598523593e35ee14b53b">implementsT2toT2Concept</a>&lt; T2toT2Type &gt;) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toT2Type &gt;)==1u) &amp;&amp;tfel::typetraits::IsScalar&lt; numeric_type&lt; T2toT2Type &gt; &gt;::cond, typename ComputeUnaryResult&lt; numeric_type&lt; T2toT2Type &gt;, Power&lt; 3 &gt; &gt;::Result &gt; tfel::math::det </td>
          <td>(</td>
          <td class="paramtype">const T2toT2Type &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the determinant of a <code><a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a></code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>fourth order tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad5bdd60d3fef329cd3283287b3a4bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5bdd60d3fef329cd3283287b3a4bc7">&#9670;&nbsp;</a></span>det() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#ab4449faeb9fd598523593e35ee14b53b">implementsT2toT2Concept</a>&lt; T2toT2Type &gt;) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; T2toT2Type &gt;)==2u)||(getSpaceDimension&lt; T2toT2Type &gt;)==3u)) &amp;&amp;tfel::typetraits::IsScalar&lt; numeric_type&lt; T2toT2Type &gt; &gt;::cond, typename ComputeUnaryResult&lt; numeric_type&lt; T2toT2Type &gt;, Power&lt; getSpaceDimension&lt; T2toT2Type &gt;)&gt; &gt;::Result &gt; tfel::math::det </td>
          <td>(</td>
          <td class="paramtype">const T2toT2Type &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the determinant of a <code><a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a></code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>fourth order tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4cd77b32eb18ba423f76fcbcac0cfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4cd77b32eb18ba423f76fcbcac0cfe2">&#9670;&nbsp;</a></span>det() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==1u) &amp;&amp;tfel::typetraits::IsScalar&lt; numeric_type&lt; ST2toST2Type &gt; &gt;::cond, typename ComputeUnaryResult&lt; numeric_type&lt; ST2toST2Type &gt;, Power&lt; 3 &gt; &gt;::Result &gt; tfel::math::det </td>
          <td>(</td>
          <td class="paramtype">const ST2toST2Type &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the determinant of a <code><a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a></code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>fourth order tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff681701362e5b7d6c4ef926cebde780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff681701362e5b7d6c4ef926cebde780">&#9670;&nbsp;</a></span>det() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==2u)||(getSpaceDimension&lt; ST2toST2Type &gt;)==3u)) &amp;&amp;tfel::typetraits::IsScalar&lt; numeric_type&lt; ST2toST2Type &gt; &gt;::cond, typename ComputeUnaryResult&lt; numeric_type&lt; ST2toST2Type &gt;, Power&lt; getSpaceDimension&lt; ST2toST2Type &gt;)&gt; &gt;::Result &gt; tfel::math::det </td>
          <td>(</td>
          <td class="paramtype">const ST2toST2Type &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the determinant of a <code><a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a></code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>fourth order tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37444837cda7a92cff9cf482eb93c722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37444837cda7a92cff9cf482eb93c722">&#9670;&nbsp;</a></span>deviator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#af77fbcb0679a70e562fe1e0f10f5e61c">EvaluationResult</a>&lt; StensorType &gt; &gt; tfel::math::deviator </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the deviator of a symmetric tensor </dd></dl>

</div>
</div>
<a id="a5ce654ea4324ea12243df2df8283582e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce654ea4324ea12243df2df8283582e">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType , typename Operation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a> tfel::math::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>, Operation &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate an expression </p>
<dl class="section return"><dt>Returns</dt><dd>the computed value </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4573c0a7cd2796c5bcb7070c395547a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4573c0a7cd2796c5bcb7070c395547a4">&#9670;&nbsp;</a></span>exportToBaseTypeArray() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;T&gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&gt; tfel::math::exportToBaseTypeArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>export the given vector to an array of the </p>

</div>
</div>
<a id="a2cfd1950e41dfff10fc785c9593a06ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfd1950e41dfff10fc785c9593a06ca">&#9670;&nbsp;</a></span>exportToBaseTypeArray() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt;<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;T&gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&gt; tfel::math::exportToBaseTypeArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>export the given vector to an array of the </p>

</div>
</div>
<a id="ac1b770e53981e0bf3df3e34269c357df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b770e53981e0bf3df3e34269c357df">&#9670;&nbsp;</a></span>exportToBaseTypeArray() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt; T &gt;::cond, <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> &gt; tfel::math::exportToBaseTypeArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>export the given vector to an array of the </p>

</div>
</div>
<a id="a1b7ba97d16e5ab2f5b2efa56b6640bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7ba97d16e5ab2f5b2efa56b6640bf3">&#9670;&nbsp;</a></span>find_perpendicular_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::find_perpendicular_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>find a vector perpendicular to the second one </p>

</div>
</div>
<a id="add78759d62a38f9554085c8ecf781d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add78759d62a38f9554085c8ecf781d4d">&#9670;&nbsp;</a></span>geometricDiscretization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::geometricDiscretization </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::value_type&#160;</td>
          <td class="paramname"><em>xb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::value_type&#160;</td>
          <td class="paramname"><em>xe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::value_type&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::value_type&#160;</td>
          <td class="paramname"><em>de</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>discretize a segment into a fixed number of elements trying to satisfy as much as possible given discretization densities at the beginning and the end of the segment. Elements size grows according to a geometric progression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>: a "stl vector like" container </td></tr>
    <tr><td class="paramname">xb</td><td>: starting point </td></tr>
    <tr><td class="paramname">xe</td><td>: last point </td></tr>
    <tr><td class="paramname">db</td><td>: density of the discretization at the starting point </td></tr>
    <tr><td class="paramname">db</td><td>: density of the discretization at the last point </td></tr>
    <tr><td class="paramname">n</td><td>: number of elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0112c63107c34060f92af4389b61346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0112c63107c34060f92af4389b61346">&#9670;&nbsp;</a></span>getColumn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, unsigned short M, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; tfel::math::getColumn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>short</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the column of the matrix with the given number; </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>column number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57959b3e12df3752b3cac6fe620c08e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57959b3e12df3752b3cac6fe620c08e8">&#9670;&nbsp;</a></span>getRow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, unsigned short M, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; M, T &gt; tfel::math::getRow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>short</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the row of the matrix with the given number; </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>row number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf6b0b722659adc868abcfcc5c7c0533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6b0b722659adc868abcfcc5c7c0533">&#9670;&nbsp;</a></span>getSpaceDimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MathObjectType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned short tfel::math::getSpaceDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an helper function to retrieve the space dimension associated with a math object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MathObjectType</td><td>math object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfe30dbf021798da2b686fac6763c127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe30dbf021798da2b686fac6763c127">&#9670;&nbsp;</a></span>getStensorSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TFELMATH_VISIBILITY_EXPORT unsigned short tfel::math::getStensorSize </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>short</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the size of a symmetric tensor for the given dimension </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>space dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6978e9e809a086d009ee40a12b87d169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6978e9e809a086d009ee40a12b87d169">&#9670;&nbsp;</a></span>haveIndexingPoliciesTheSameMemoryLayout()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::haveIndexingPoliciesTheSameMemoryLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if two indexing policies have the same memory layout. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy1</td><td>first indexing policy </td></tr>
    <tr><td class="paramname">IndexingPolicy2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function is a simple wrapper around <code><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_base.html#a5df559393e5d2030bee39722b60a0afd">IndexingPoliciesCompatiblityCheck::haveTheSameMemoryLayout</a></code>. </dd></dl>

</div>
</div>
<a id="a16dd9171e96269d30fa964346b1dba57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16dd9171e96269d30fa964346b1dba57">&#9670;&nbsp;</a></span>implementsMatrixConcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::implementsMatrixConcept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_matrix_concept.html" title="A class used to model the concept of matrices. Here we use the curiously recurring template pattern...">MatrixConcept</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16bffc5a9c8d6b8cb020e9f6edcf5768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bffc5a9c8d6b8cb020e9f6edcf5768">&#9670;&nbsp;</a></span>implementsST2toST2Concept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::implementsST2toST2Concept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept.html">ST2toST2Concept</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ST2toST2Type</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0178c5e31d405f93fc7dbfade5ada5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0178c5e31d405f93fc7dbfade5ada5d5">&#9670;&nbsp;</a></span>implementsST2toT2Concept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::implementsST2toT2Concept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_concept.html">ST2toT2Concept</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ST2toT2Type</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c098d789adbbac9dc1af953b4c5ba27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c098d789adbbac9dc1af953b4c5ba27">&#9670;&nbsp;</a></span>implementsStensorConcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::implementsStensorConcept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_stensor_concept.html">StensorConcept</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StensorType</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2a2225d9c9e564112e9f173838042a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a2225d9c9e564112e9f173838042a6">&#9670;&nbsp;</a></span>implementsT2toST2Concept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::implementsT2toST2Concept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept.html">T2toST2Concept</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2toST2Type</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4449faeb9fd598523593e35ee14b53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4449faeb9fd598523593e35ee14b53b">&#9670;&nbsp;</a></span>implementsT2toT2Concept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T2toT2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::implementsT2toT2Concept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_t2to_t2_concept.html">T2toT2Concept</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2toT2Type</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af86a6ca34a7c9d413943e709cfdb4426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86a6ca34a7c9d413943e709cfdb4426">&#9670;&nbsp;</a></span>implementsTensorConcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::implementsTensorConcept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_tensor_concept.html">TensorConcept</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorType</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5424b5a3d5ff40da6e4ef6abacb5b2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5424b5a3d5ff40da6e4ef6abacb5b2be">&#9670;&nbsp;</a></span>implementsVectorConcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::implementsVectorConcept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code><a class="el" href="structtfel_1_1math_1_1_vector_concept.html">VectorConcept</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorType</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44d8364a7cc6de24932f2d1f677a78fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d8364a7cc6de24932f2d1f677a78fb">&#9670;&nbsp;</a></span>init_floating_point_exceptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::init_floating_point_exceptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>this function enables C99 floating point rounding and exception handling:</p><ul>
<li>FE_DIVBYZERO: the DivideByZero exception occurs when an operation on finite numbers produces infinity as exact answer.</li>
<li>FE_UNDERFLOW: the Overflow exception occurs when a result has to be represented as a floating point number, but has (much) larger absolute value than the largest (finite) floating point number that is representable.</li>
<li>FE_OVERFLOW: the Underflow exception occurs when a result has to be represented as a floating point number, but has smaller absolute value than the smallest positive normalized floating point number (and would lose much accuracy when represented as a denormalized number).</li>
<li>FE_INEXACT: the Inexact exception occurs when the rounded result of an operation is not equal to the infinite precision result. It may occur whenever Overflow or Underflow occurs. </li>
</ul>

</div>
</div>
<a id="aed5a2d39d6b1efa7070e2dbfcb7ef4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5a2d39d6b1efa7070e2dbfcb7ef4b2">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;TensorType&gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt;<a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;TensorType&gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;TensorType&gt;, <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a>&gt;::Result&gt; &gt; tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the invert of a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: tensor to be inverted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54ff893cb01f4a14bb40456f16eabbb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ff893cb01f4a14bb40456f16eabbb4">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;TensorType&gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt;<a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;TensorType&gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;TensorType&gt;, <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a>&gt;::Result&gt; &gt; tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the invert of a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: tensor to be inverted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d29940d33a9b67b48d9c7d91fed631a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d29940d33a9b67b48d9c7d91fed631a">&#9670;&nbsp;</a></span>invert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;), <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt;, <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a> &gt;::Result &gt; &gt; tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const ST2toST2Type &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the invert of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a> to be inverted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16dde7f5526001ceb060ac2ee922bad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16dde7f5526001ceb060ac2ee922bad7">&#9670;&nbsp;</a></span>logarithm() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) == 1u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt;StensorType&gt; &gt;::cond)), stensor&lt;1u, numeric_type&lt;StensorType&gt; &gt; &gt; tfel::math::logarithm </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the logarithm of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac089330f221f90549b5e67e468d20d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac089330f221f90549b5e67e468d20d8a">&#9670;&nbsp;</a></span>logarithm() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;)) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) == 1u) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt;StensorType&gt; &gt;::cond)), stensor&lt;1u, numeric_type&lt;StensorType&gt; &gt; &gt; tfel::math::logarithm </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the logarithm of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1459e865f0ecd60229c9ba2777cf30b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1459e865f0ecd60229c9ba2777cf30b4">&#9670;&nbsp;</a></span>logarithm() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;)) &amp;&amp; ((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) == 2u) || (getSpaceDimension&lt;StensorType&gt;) == 3u)) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt;StensorType&gt; &gt;::cond)), stensor&lt;getSpaceDimension&lt;StensorType&gt;), numeric_type&lt;StensorType&gt; &gt; &gt; tfel::math::logarithm </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the logarithm of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a594e911d65cb8770eb19e7627464ebdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a594e911d65cb8770eb19e7627464ebdd">&#9670;&nbsp;</a></span>logarithm() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; ((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;)) &amp;&amp; ((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;) == 2u) || (getSpaceDimension&lt;StensorType&gt;) == 3u)) &amp;&amp; (tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt;StensorType&gt; &gt;::cond)), stensor&lt;getSpaceDimension&lt;StensorType&gt;), numeric_type&lt;StensorType&gt; &gt; &gt; tfel::math::logarithm </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the logarithm of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a302fcc3dcd4eab55fb584c3465e2e8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302fcc3dcd4eab55fb584c3465e2e8aa">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T , unsigned short N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, typename std::result_of&lt; F(T)&gt;::type &gt; tfel::math::map </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new tvector by applying a functor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>functor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>inital value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dcaaecc493cdabdcfe86fe46983b33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcaaecc493cdabdcfe86fe46983b33e">&#9670;&nbsp;</a></span>negative_part() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, numeric_type&lt; StensorType &gt; &gt; &gt; tfel::math::negative_part </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the negative part of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4485a13170a338345bca7b8641e694e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4485a13170a338345bca7b8641e694e8">&#9670;&nbsp;</a></span>negative_part() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u)||(getSpaceDimension&lt; StensorType &gt;)==3u)) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; getSpaceDimension&lt; StensorType &gt;), numeric_type&lt; StensorType &gt; &gt; &gt; tfel::math::negative_part </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the negative part of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b9dde0e44d24c8523bfa7b9b0f79d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9dde0e44d24c8523bfa7b9b0f79d44">&#9670;&nbsp;</a></span>norm() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt;<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;T&gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt;T&gt;::type&gt; tfel::math::norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtfel_1_1math_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the euclidian norm of a vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>vector&lt;T&gt;&amp;, the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename tfel::typetraits::RealPartType&lt;T&gt;::type, the result </dd></dl>

</div>
</div>
<a id="a184f3b4d642b96100d4299d258db1f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184f3b4d642b96100d4299d258db1f9b">&#9670;&nbsp;</a></span>norm() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structtfel_1_1math_1_1_is_euclidian_norm_valid.html">IsEuclidianNormValid</a>&lt; T1 &gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T1, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::Result &gt;::type &gt; tfel::math::norm </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the euclidian norm of a tvector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>: the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename tfel::typetraits::RealPartType&lt;T&gt;::type, the result </dd></dl>

</div>
</div>
<a id="a399608ee9d96a24fe5899334bd7d8a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a399608ee9d96a24fe5899334bd7d8a42">&#9670;&nbsp;</a></span>norm() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;T&gt;::cond, typename <a class="el" href="structtfel_1_1typetraits_1_1_real_part_type.html">tfel::typetraits::RealPartType</a>&lt;T&gt;::type&gt; tfel::math::norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtfel_1_1math_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the euclidian norm of a vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>vector&lt;T&gt;&amp;, the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename tfel::typetraits::RealPartType&lt;T&gt;::type, the result </dd></dl>

</div>
</div>
<a id="ae18e7a16497abdb0408f6a78ec1eb5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18e7a16497abdb0408f6a78ec1eb5fe">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::operator* </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;
      <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt;decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;::
              value &amp;&amp;
          (!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;std::decay_t&lt;T1&gt;&gt;::cond) &amp;&amp;
             (<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;std::decay_t&lt;T2&gt;&gt;::cond))),
      <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt;decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multiply to mathematical object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpMult&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="a9768b53386714e990d318ef601ed007a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9768b53386714e990d318ef601ed007a">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::operator+ </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;
      <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt;decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a>&gt;::
              value &amp;&amp;
          (!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;std::decay_t&lt;T1&gt;&gt;::cond) &amp;&amp;
             (<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;std::decay_t&lt;T2&gt;&gt;::cond))),
      <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt;decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_plus.html">OpPlus</a>&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add to mathematical object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpPlus&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="a300173c899a17288ed49569f89a2f35a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300173c899a17288ed49569f89a2f35a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; std::enable_if_t&lt;
      <a class="el" href="namespacetfel_1_1math.html#a8c2abca9d653c8ef4f1f2cfaf31eccaa">isUnaryOperationResultTypeValid</a>&lt;decltype(a), <a class="el" href="structtfel_1_1math_1_1_op_neg.html">OpNeg</a>&gt;::value,
      <a class="el" href="namespacetfel_1_1math.html#a300520fa6148e3df294b597830d63e9b">UnaryOperationHandler</a>&lt;decltype(a), <a class="el" href="structtfel_1_1math_1_1_op_neg.html">OpNeg</a>&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>negate a mathematical object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation.</dd></dl>
<p>This operator is defined if the ComputeUnaryResult&lt;T1,T2,OpPlus&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="abeaf610ff7113226347634268bcd0bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeaf610ff7113226347634268bcd0bed">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;
      <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt;decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_minus.html">OpMinus</a>&gt;::
              value &amp;&amp;
          (!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;std::decay_t&lt;T1&gt;&gt;::cond) &amp;&amp;
             (<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;std::decay_t&lt;T2&gt;&gt;::cond))),
      <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt;decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_minus.html">OpMinus</a>&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>substract to mathematical object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpMinus&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="a2d751ad016e9a92453975678b7edf2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d751ad016e9a92453975678b7edf2ce">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::operator/ </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;
      <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt;decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a>&gt;::
              value &amp;&amp;
          (!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;std::decay_t&lt;T1&gt;&gt;::cond) &amp;&amp;
             (<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;std::decay_t&lt;T2&gt;&gt;::cond))),
      <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt;decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_div.html">OpDiv</a>&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>divide a mathematical object by another </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpDiv&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="a2b759ee7f33caa991286726bb496361a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b759ee7f33caa991286726bb496361a">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericType , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; tfel::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_aitken_acceleration_algorithm.html">AitkenAccelerationAlgorithm</a>&lt; NumericType, IndexType &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>output stream operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>output operator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2a2fc98dcdf453463e8a57d050ad943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a2fc98dcdf453463e8a57d050ad943">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; tfel::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_bissection_algorithm_data.html">BissectionAlgorithmData</a>&lt; NumericType &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>output stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a150aa17b4b9b5abbb5f87489adaf663f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150aa17b4b9b5abbb5f87489adaf663f">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; tfel::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_bissection_algorithm_base.html">BissectionAlgorithmBase</a>&lt; NumericType &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>output stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>acceleration algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3eea710246d89ef2318640956a6bd089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eea710246d89ef2318640956a6bd089">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::operator^ </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;
      <a class="el" href="namespacetfel_1_1math.html#a7f47b467a56d1e49b49a3a711178364e">isBinaryOperationResultTypeValid</a>&lt;decltype(a),
                                       decltype(b),
                                       <a class="el" href="structtfel_1_1math_1_1_op_diadic_product.html">OpDiadicProduct</a>&gt;::value &amp;&amp;
          (!((<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;std::decay_t&lt;T1&gt;&gt;::cond) &amp;&amp;
             (<a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;std::decay_t&lt;T2&gt;&gt;::cond))),
      <a class="el" href="namespacetfel_1_1math.html#a1e6928d0a344b02c1df04bcf982f9b04">BinaryOperationHandler</a>&lt;decltype(a), decltype(b), <a class="el" href="structtfel_1_1math_1_1_op_diadic_product.html">OpDiadicProduct</a>&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>diadic product between two mathematical objects </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpDiadicProduct&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="a36f2206e9e01e27254f765cc3719e2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f2206e9e01e27254f765cc3719e2de">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;T1&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#ab4449faeb9fd598523593e35ee14b53b">implementsT2toT2Concept</a>&lt;T2&gt;) &amp;&amp; !<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt;T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;::Result&gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt;T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;::Handle&gt; tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left stensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right stensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="aa15c8c5daef1fee3fb42c6f293be9a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15c8c5daef1fee3fb42c6f293be9a7d">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T1&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;T2&gt;) &amp;&amp; !<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt;T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;::Result&gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt;T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;::Handle&gt;::type tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left stensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right stensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="a28cecd8225f0f242c76c1715d8f07a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28cecd8225f0f242c76c1715d8f07a8c">&#9670;&nbsp;</a></span>operator|() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="structtfel_1_1math_1_1_is_vector_vector_operation_valid.html">IsVectorVectorOperationValid</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a> &gt;::Result &gt; tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left vector. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="a9692f591f3005f80756e42cfbadebc0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9692f591f3005f80756e42cfbadebc0b">&#9670;&nbsp;</a></span>operator|() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T1&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T2&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T1&gt;) == 1u &amp;&amp; getSpaceDimension&lt;T2&gt;) == 1u &amp;&amp; !tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt;T1, T2, OpDotProduct&gt;::Result&gt;::cond, typename ComputeBinaryResult&lt;T1, T2, OpDotProduct&gt;::Result&gt;::type tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left stensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right stensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the inner product of a vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left vector. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="af585e46dd234e0b0dd291dfd20028d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af585e46dd234e0b0dd291dfd20028d4c">&#9670;&nbsp;</a></span>operator|() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T1&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T2&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T1&gt;) == 2u &amp;&amp; getSpaceDimension&lt;T2&gt;) == 2u &amp;&amp; !tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt;T1, T2, OpDotProduct&gt;::Result&gt;::cond, typename ComputeBinaryResult&lt;T1, T2, OpDotProduct&gt;::Result&gt;::type tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left stensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right stensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the inner product of a vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left vector. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="a9812d2b7dfd0fc2e31c4ad31cc92f94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9812d2b7dfd0fc2e31c4ad31cc92f94a">&#9670;&nbsp;</a></span>operator|() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T1&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T2&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;T1&gt;) == 3u &amp;&amp; getSpaceDimension&lt;T2&gt;) == 3u &amp;&amp; !tfel::typetraits::IsInvalid&lt; typename ComputeBinaryResult&lt;T1, T2, OpDotProduct&gt;::Result&gt;::cond, typename ComputeBinaryResult&lt;T1, T2, OpDotProduct&gt;::Result&gt;::type tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left stensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right stensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the inner product of a vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left vector. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="a39f0b002169adeb6c0a9d2d92580fed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f0b002169adeb6c0a9d2d92580fed6">&#9670;&nbsp;</a></span>operator|() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;T1&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#af2a2225d9c9e564112e9f173838042a6">implementsT2toST2Concept</a>&lt;T2&gt;) &amp;&amp; !<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt;T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;::Result&gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt;T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;::Handle&gt;::type tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left stensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right stensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="ad5107fdde4aaff7f19cbd82da08dca59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5107fdde4aaff7f19cbd82da08dca59">&#9670;&nbsp;</a></span>operator|() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::enable_if&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;T1&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a0178c5e31d405f93fc7dbfade5ada5d5">implementsST2toT2Concept</a>&lt;T2&gt;) &amp;&amp; !<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt;T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;::Result&gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt;T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a>&gt;::Handle&gt;::type tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left stensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right stensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="ad4a3caef3aae091a3bb3776b6c00bb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a3caef3aae091a3bb3776b6c00bb4b">&#9670;&nbsp;</a></span>operator|() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;T1&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;T2&gt;) &amp;&amp; !<a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html">tfel::typetraits::IsInvalid</a>&lt; typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt;T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a>&gt;::Result&gt;::cond, typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt;T1, T2, <a class="el" href="structtfel_1_1math_1_1_op_dot_product.html">OpDotProduct</a>&gt;::Result&gt; tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left tensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the inner product of a stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left stensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right stensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the inner product of a vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left vector. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="adb049882646b6a957e22b11fd026d07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb049882646b6a957e22b11fd026d07c">&#9670;&nbsp;</a></span>polar_decomposition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType , typename StensorType , typename TensorType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;std::is_same&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType2 &gt; &gt;::value &amp;&amp;std::is_same&lt; <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType2 &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::value &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType2 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==1u), void &gt; tfel::math::polar_decomposition </td>
          <td>(</td>
          <td class="paramtype">TensorType &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StensorType &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType2 &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>provide the polar decomposition of a tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rotation</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stretch</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f5edbd2084512e9cebe5bef088ed081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5edbd2084512e9cebe5bef088ed081">&#9670;&nbsp;</a></span>polar_decomposition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType , typename StensorType , typename TensorType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType2 &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;std::is_same&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType2 &gt; &gt;::value &amp;&amp;std::is_same&lt; <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType2 &gt; &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt; &gt;::value &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType2 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;)==2u)||(getSpaceDimension&lt; TensorType &gt;)==3u)), void &gt; tfel::math::polar_decomposition </td>
          <td>(</td>
          <td class="paramtype">TensorType &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StensorType &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType2 &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>provide the polar decomposition of a tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">rotation</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stretch</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2749fbd3f6ae56cbb776156d5115af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2749fbd3f6ae56cbb776156d5115af9">&#9670;&nbsp;</a></span>positive_part() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; 1u, numeric_type&lt; StensorType &gt; &gt; &gt; tfel::math::positive_part </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the positive part of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c6e4027c87851f6b6c07ad6180fd2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6e4027c87851f6b6c07ad6180fd2ee">&#9670;&nbsp;</a></span>positive_part() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;((<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u)||(getSpaceDimension&lt; StensorType &gt;)==3u)) &amp;&amp;(tfel::typetraits::IsFundamentalNumericType&lt; numeric_type&lt; StensorType &gt; &gt;::cond)), stensor&lt; getSpaceDimension&lt; StensorType &gt;), numeric_type&lt; StensorType &gt; &gt; &gt; tfel::math::positive_part </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the positive part of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfda655d34d39ce7e596d82d133cd26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfda655d34d39ce7e596d82d133cd26a">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type2&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;ST2toST2Type&gt;) == 1u &amp;&amp; getSpaceDimension&lt;ST2toST2Type2&gt;) == 1u &amp; getSpaceDimension&lt;TensorType&gt;) == 1u, void&gt;::type tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">ST2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST2toST2Type2 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Ct</td><td>result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07f79c9a625ee8791fd35ac85a5392f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f79c9a625ee8791fd35ac85a5392f0">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type2&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;ST2toST2Type&gt;) == 2u &amp;&amp; getSpaceDimension&lt;ST2toST2Type2&gt;) == 2u &amp; getSpaceDimension&lt;TensorType&gt;) == 2u, void&gt;::type tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">ST2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST2toST2Type2 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Ct</td><td>result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a390bb97667687287c841ef849eb72359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390bb97667687287c841ef849eb72359">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type2&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;ST2toST2Type&gt;) == 1u &amp;&amp; getSpaceDimension&lt;ST2toST2Type2&gt;) == 1u &amp; getSpaceDimension&lt;TensorType&gt;) == 1u, void&gt; tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">ST2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST2toST2Type2 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Ct</td><td>result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af780ee7660b6d43a34d4337f321351eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af780ee7660b6d43a34d4337f321351eb">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type2&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;ST2toST2Type&gt;) == 2u &amp;&amp; getSpaceDimension&lt;ST2toST2Type2&gt;) == 2u &amp; getSpaceDimension&lt;TensorType&gt;) == 2u, void&gt; tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">ST2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST2toST2Type2 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Ct</td><td>result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad6401de57bbca960e9de5c231dacd3d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6401de57bbca960e9de5c231dacd3d5">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type2&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;ST2toST2Type&gt;) == 3u &amp;&amp; getSpaceDimension&lt;ST2toST2Type2&gt;) == 3u &amp; getSpaceDimension&lt;TensorType&gt;) == 3u, void&gt; tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">ST2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST2toST2Type2 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Ct</td><td>result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e407e883f8e2646cb621989d89e7024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e407e883f8e2646cb621989d89e7024">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;::cond)), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt; tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the product: [F.s.F^{T}] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>a tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the same as pushForward </dd></dl>

</div>
</div>
<a id="accc6fe3fb4d367b46678f77ba7df9477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc6fe3fb4d367b46678f77ba7df9477">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename ST2toST2Type2 , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt;ST2toST2Type2&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt;TensorType&gt;) &amp;&amp; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;ST2toST2Type&gt;) == 3u &amp;&amp; getSpaceDimension&lt;ST2toST2Type2&gt;) == 3u &amp; getSpaceDimension&lt;TensorType&gt;) == 3u, void&gt;::type tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">ST2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST2toST2Type2 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Ct</td><td>result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b7f716b1f1e9f23fff20e841c44e84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7f716b1f1e9f23fff20e841c44e84f">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;)==<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; TensorType &gt;), <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; ST2toST2Type &gt;), typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; ST2toST2Type &gt;, <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; TensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_op_mult.html">OpMult</a> &gt;::Result &gt; &gt; tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">const ST2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors. ">st2tost2</a>: <p class="formulaDsp">
\[ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} \]
</p>
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad489dcf8ec0b50bdac502ed711fa9dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad489dcf8ec0b50bdac502ed711fa9dd6">&#9670;&nbsp;</a></span>pushForward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType , typename TensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#af86a6ca34a7c9d413943e709cfdb4426">implementsTensorConcept</a>&lt; TensorType &gt;)) &amp;&amp;(<a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt;::cond)), <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt; StensorType &gt; &gt; &gt; tfel::math::pushForward </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the product: [F.s.F^{T}] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>a tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af944b60fb53c166c7f8f18f25fc2f702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af944b60fb53c166c7f8f18f25fc2f702">&#9670;&nbsp;</a></span>regularisedFischerBurmeisterFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real tfel::math::regularisedFischerBurmeisterFunction </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"> = <code>real{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a regularised version of the Fischer-Burmeister function defined by: [ f(x,y)=x+y-{x^{2}+y^{2}+^{2}} ] This function is such that: [ f(x,y)=0  x 0, y 0 and {2\,x\,y}=^{2} ] </p>
<blockquote class="doxtable">
<p>A Regularized and Smoothed Fischer-Burmeister Method for Quadratic Programming with Applications to Model Predictive Control. Dominic Liao-McPherson, Mike Huang, and Ilya Kolmanovsky </p>
</blockquote>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>regularisation parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the Fischer-Burmeister function </dd></dl>

</div>
</div>
<a id="ae39472ec66a29e42a7851d566a5304f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39472ec66a29e42a7851d566a5304f2">&#9670;&nbsp;</a></span>regularisedFischerBurmeisterFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE real tfel::math::regularisedFischerBurmeisterFunction </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"> = <code>real{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a regularised version of the Fischer-Burmeister function defined by: [ f(x,y)=x+y-{x^{2}+y^{2}+^{2}} ] This function is such that: [ f(x,y)=0  x 0, y 0 and {2\,x\,y}=^{2} ] </p>
<blockquote class="doxtable">
<p>A Regularized and Smoothed Fischer-Burmeister Method for Quadratic Programming with Applications to Model Predictive Control. Dominic Liao-McPherson, Mike Huang, and Ilya Kolmanovsky </p>
</blockquote>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>regularisation parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the Fischer-Burmeister function </dd></dl>

</div>
</div>
<a id="a1eeb7dd9cc4a53a955127f9b48dfe6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eeb7dd9cc4a53a955127f9b48dfe6ea">&#9670;&nbsp;</a></span>regularisedFischerBurmeisterFunctionFirstDerivatives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;real, real&gt; tfel::math::regularisedFischerBurmeisterFunctionFirstDerivatives </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivatives of the regularised version of the Fischer-Burmeister function </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>regularisation parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6b44a8d886f9e1a6748429141a4bb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b44a8d886f9e1a6748429141a4bb99">&#9670;&nbsp;</a></span>regularisedFischerBurmeisterFunctionFirstDerivatives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::tuple&lt;real, real&gt; tfel::math::regularisedFischerBurmeisterFunctionFirstDerivatives </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivatives of the regularised version of the Fischer-Burmeister function </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>regularisation parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa34bde6a62da31a11e114a9d1a2f8cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34bde6a62da31a11e114a9d1a2f8cfa">&#9670;&nbsp;</a></span>scalarNewtonRaphson() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename Criterion , typename NumericType , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, NumericType, IndexType &gt; tfel::math::scalarNewtonRaphson </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Criterion &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumericType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the root of the given function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>type of a generalised function returning the value of the objective function and its derivative </td></tr>
    <tr><td class="paramname">Criterion</td><td>type of a function which computes the stopping criterion </td></tr>
    <tr><td class="paramname">NumericType</td><td>type of the root </td></tr>
    <tr><td class="paramname">IndexType</td><td>type of the iteration counter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>generalised function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>criterion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>initial guess </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">im</td><td>maximum number of iterations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple whose first field is a boolean giving the convergence status and the second field the last estimate of the solution. </dd></dl>

</div>
</div>
<a id="a721b69ae40bf0e14b7e34b6b703e53eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721b69ae40bf0e14b7e34b6b703e53eb">&#9670;&nbsp;</a></span>scalarNewtonRaphson() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename Criterion , typename NumericType , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; bool, NumericType, IndexType &gt; tfel::math::scalarNewtonRaphson </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Criterion &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_scalar_newton_raphson_parameters.html">ScalarNewtonRaphsonParameters</a>&lt; NumericType, IndexType &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the root of the given function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>type of a generalised function returning the value of the objective function and its derivative </td></tr>
    <tr><td class="paramname">Criterion</td><td>type of a function which computes the stopping criterion </td></tr>
    <tr><td class="paramname">NumericType</td><td>type of the root </td></tr>
    <tr><td class="paramname">IndexType</td><td>type of the iteration counter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>generalised function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>criterion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>newton parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple whose first field is a boolean giving the convergence status and the second field the last estimate of the solution. </dd></dl>

</div>
</div>
<a id="a51b980d05e09c20fd34c7e1ab744898b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b980d05e09c20fd34c7e1ab744898b">&#9670;&nbsp;</a></span>sigmaeq() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;StensorType&gt; &gt; tfel::math::sigmaeq </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the von Mises stress of a symmetric tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3159288830267591720ed8bfdca8d9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3159288830267591720ed8bfdca8d9db">&#9670;&nbsp;</a></span>sigmaeq() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE2 std::enable_if_t&lt;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;StensorType&gt; &gt; tfel::math::sigmaeq </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the von Mises stress of a symmetric tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae312eb70d31a3763c304cbf296791856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae312eb70d31a3763c304cbf296791856">&#9670;&nbsp;</a></span>slice() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short I, unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N - I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; N - I, N, I, T, false &gt; &gt; tfel::math::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a slice from a tiny vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the slice object contains a reference to the source vector, so this vector shall not be destroyed before the slice </dd></dl>

</div>
</div>
<a id="affbcc9f199633d9837f1b4b5a38d19cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbcc9f199633d9837f1b4b5a38d19cd">&#9670;&nbsp;</a></span>slice() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short I, unsigned short J, unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; J - I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; J - I, N, I, T, false &gt; &gt; tfel::math::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a slice from a tiny vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the slice object contains a reference to the source vector, so this vector shall not be destroyed before the slice </dd></dl>

</div>
</div>
<a id="a05d9519eaa015451b0f1c35c9d7e6d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d9519eaa015451b0f1c35c9d7e6d9f">&#9670;&nbsp;</a></span>slice() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short I, unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N - I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; N - I, N, I, T, true &gt; &gt; tfel::math::slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a slice from a tiny vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the slice object contains a reference to the source vector, so this vector shall not be destroyed before the slice </dd></dl>

</div>
</div>
<a id="afb819c9fb29ebad868f667144cd942e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb819c9fb29ebad868f667144cd942e4">&#9670;&nbsp;</a></span>slice() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short I, unsigned short J, unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; J - I, T &gt;, <a class="el" href="structtfel_1_1math_1_1_tiny_vector_from_tiny_vector_view_expr.html">TinyVectorFromTinyVectorViewExpr</a>&lt; J - I, N, I, T, true &gt; &gt; tfel::math::slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a slice from a tiny vector (const version) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the slice object contains a reference to the source vector, so this vector shall not be destroyed before the slice </dd></dl>

</div>
</div>
<a id="ae99f8a0e285e6a533b479bb940b5873d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99f8a0e285e6a533b479bb940b5873d">&#9670;&nbsp;</a></span>square() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==1u, stensor&lt; 1u, typename ComputeBinaryResult&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; StensorType &gt;, OpMult &gt;::Result &gt; &gt; tfel::math::square </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the square of a symmetric stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: squared tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a588d51c77222cf153592863162f3a23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588d51c77222cf153592863162f3a23a">&#9670;&nbsp;</a></span>square() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==2u, stensor&lt; 2u, typename ComputeBinaryResult&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; StensorType &gt;, OpMult &gt;::Result &gt; &gt; tfel::math::square </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the square of a symmetric stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: squared tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90d40223c816e1a7bb39cd2f1041a6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d40223c816e1a7bb39cd2f1041a6f4">&#9670;&nbsp;</a></span>square() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType &gt;) &amp;&amp;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType &gt;)==3u, stensor&lt; 3u, typename ComputeBinaryResult&lt; numeric_type&lt; StensorType &gt;, numeric_type&lt; StensorType &gt;, OpMult &gt;::Result &gt; &gt; tfel::math::square </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the square of a symmetric stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: squared tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af28368afe179eb2a167faa54d1b75af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28368afe179eb2a167faa54d1b75af3">&#9670;&nbsp;</a></span>squaredFischerBurmeisterFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real tfel::math::squaredFischerBurmeisterFunction </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the square of the Fischer-Burmeister function </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6373c72a52fe938120ffcfb6a6952789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6373c72a52fe938120ffcfb6a6952789">&#9670;&nbsp;</a></span>squaredFischerBurmeisterFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE real tfel::math::squaredFischerBurmeisterFunction </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the square of the Fischer-Burmeister function </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd7650a0a577ea13922c56515f287436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7650a0a577ea13922c56515f287436">&#9670;&nbsp;</a></span>squaredFischerBurmeisterFunctionFirstDerivatives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;real,real&gt; tfel::math::squaredFischerBurmeisterFunctionFirstDerivatives </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivatives of the square of the Fischer-Burmeister function </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae946a12af0950352569b2d4961fac39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae946a12af0950352569b2d4961fac39f">&#9670;&nbsp;</a></span>squaredFischerBurmeisterFunctionFirstDerivatives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::tuple&lt;real, real&gt; tfel::math::squaredFischerBurmeisterFunctionFirstDerivatives </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivatives of the square of the Fischer-Burmeister function </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa49d41abdab92f2fa9cf640a58e062eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49d41abdab92f2fa9cf640a58e062eb">&#9670;&nbsp;</a></span>symmetric_product() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType1 , typename StensorType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType1 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType2 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType1 &gt;)==1u) &amp;&amp;(getSpaceDimension&lt; StensorType2 &gt;)==1u)), stensor&lt; 3u, typename ResultType&lt; numeric_type&lt; StensorType1 &gt;, numeric_type&lt; StensorType2 &gt;, OpMult &gt;::type &gt; &gt; tfel::math::symmetric_product </td>
          <td>(</td>
          <td class="paramtype">const StensorType1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the symmetric product of two stensors as a symmetric tensor </p><p class="formulaDsp">
\[ s1*s2+s2*s1 \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>first tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>second tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc4565d4b43e42afedf1b1facb1d9827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4565d4b43e42afedf1b1facb1d9827">&#9670;&nbsp;</a></span>symmetric_product() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType1 , typename StensorType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType1 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType2 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType1 &gt;)==2u) &amp;&amp;(getSpaceDimension&lt; StensorType2 &gt;)==2u)), stensor&lt; 2u, typename ResultType&lt; numeric_type&lt; StensorType1 &gt;, numeric_type&lt; StensorType2 &gt;, OpMult &gt;::type &gt; &gt; tfel::math::symmetric_product </td>
          <td>(</td>
          <td class="paramtype">const StensorType1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the symmetric product of two stensors as a symmetric tensor: </p><p class="formulaDsp">
\[ s1*s2+s2*s1 \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>first tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>second tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad57a2ed542f171333483de8b7d71d724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57a2ed542f171333483de8b7d71d724">&#9670;&nbsp;</a></span>symmetric_product() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType1 , typename StensorType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;((<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType1 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt; StensorType2 &gt;)) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt; StensorType1 &gt;)==3u) &amp;&amp;(getSpaceDimension&lt; StensorType2 &gt;)==3u)), stensor&lt; 3u, typename ResultType&lt; numeric_type&lt; StensorType1 &gt;, numeric_type&lt; StensorType2 &gt;, OpMult &gt;::type &gt; &gt; tfel::math::symmetric_product </td>
          <td>(</td>
          <td class="paramtype">const StensorType1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the symmetric product of two stensors as a symmetric tensor </p><p class="formulaDsp">
\[ s1*s2+s2*s1 \]
</p>
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>first tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>second tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bbbb935b9c9751cc73b9da3e9a314c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbbb935b9c9751cc73b9da3e9a314c8">&#9670;&nbsp;</a></span>trace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;StensorType&gt; &gt; tfel::math::trace </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the trace of a symmetric tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7798d5763f3e45187fffdd5a5edbc0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7798d5763f3e45187fffdd5a5edbc0b0">&#9670;&nbsp;</a></span>trace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::enable_if_t&lt;<a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;StensorType&gt; &gt; tfel::math::trace </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the trace of a symmetric tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e39a1ce5b47f1cfdf174a3a306d4dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e39a1ce5b47f1cfdf174a3a306d4dff">&#9670;&nbsp;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tfel::math::transpose </td>
          <td>(</td>
          <td class="paramtype">ST2toST2Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt;  std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;(), <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="namespacetfel_1_1math.html#af77fbcb0679a70e562fe1e0f10f5e61c">EvaluationResult</a>&lt; ST2toST2Type &gt;, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html">ST2toST2TransposeExpr</a>&lt; decltype(t)&gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a transposed view </dd></dl>

</div>
</div>
<a id="a76cbf9140ff4e646564528f4ee402080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cbf9140ff4e646564528f4ee402080">&#9670;&nbsp;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE auto tfel::math::transpose </td>
          <td>(</td>
          <td class="paramtype">ST2toST2Type &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> -&gt;  std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a16bffc5a9c8d6b8cb020e9f6edcf5768">implementsST2toST2Concept</a>&lt; ST2toST2Type &gt;(), <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="namespacetfel_1_1math.html#af77fbcb0679a70e562fe1e0f10f5e61c">EvaluationResult</a>&lt; ST2toST2Type &gt;, <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html">ST2toST2TransposeExpr</a>&lt; decltype(t)&gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a transposed view </dd></dl>

</div>
</div>
<a id="a956390f6acfa8185d8420636dc422898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956390f6acfa8185d8420636dc422898">&#9670;&nbsp;</a></span>tresca() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T tfel::math::tresca </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; 1u, T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the tresca stress for a symmetric tensor.</p>
<p>Partial specialisation in 1D</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2b78db087c9dbda87742fa94d15e769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b78db087c9dbda87742fa94d15e769">&#9670;&nbsp;</a></span>tresca() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T tfel::math::tresca </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the tresca stress for a symmetric tensor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a78872ee963817439070ace05dbdd693e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78872ee963817439070ace05dbdd693e">&#9670;&nbsp;</a></span>unsyme() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;StensorType&gt; &gt; &gt; tfel::math::unsyme </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the unsymmetric tensor corresponding to the given symmetric tensor. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea6c67001903d98952f71c2c60c49df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6c67001903d98952f71c2c60c49df4">&#9670;&nbsp;</a></span>unsyme() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; <a class="el" href="namespacetfel_1_1math.html#a4c098d789adbbac9dc1af953b4c5ba27">implementsStensorConcept</a>&lt;StensorType&gt;), <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt;<a class="el" href="namespacetfel_1_1math.html#abf6b0b722659adc868abcfcc5c7c0533">getSpaceDimension</a>&lt;StensorType&gt;), <a class="el" href="namespacetfel_1_1math.html#aa89ae24543be8292214ca296a43fbc19">numeric_type</a>&lt;StensorType&gt; &gt; &gt; tfel::math::unsyme </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the unsymmetric tensor corresponding to the given symmetric tensor. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 3 2021 21:24:48 for tfel by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
