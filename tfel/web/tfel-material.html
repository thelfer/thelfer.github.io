

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>The TFEL/Material library</title>
        <meta name="author" content="Thomas Helfer" />
            <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
    <style type="text/css">code{white-space: pre;}</style>
            <style type="text/css">
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f8f8f8; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ef2929; } /* Alert */
      code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #204a87; } /* Attribute */
      code span.bn { color: #0000cf; } /* BaseN */
      code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4e9a06; } /* Char */
      code span.cn { color: #8f5902; } /* Constant */
      code span.co { color: #8f5902; font-style: italic; } /* Comment */
      code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
      code span.dt { color: #204a87; } /* DataType */
      code span.dv { color: #0000cf; } /* DecVal */
      code span.er { color: #a40000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #0000cf; } /* Float */
      code span.fu { color: #204a87; font-weight: bold; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
      code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
      code span.ot { color: #8f5902; } /* Other */
      code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
      code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
      code span.ss { color: #4e9a06; } /* SpecialString */
      code span.st { color: #4e9a06; } /* String */
      code span.va { color: #000000; } /* Variable */
      code span.vs { color: #4e9a06; } /* VerbatimString */
      code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
    </style>
            <link rel="stylesheet" href="css/normalize.css"/>
    <link rel="stylesheet" href="css/main.css"/>
        <script
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
        type="text/javascript"></script>
          </head>
  <body>
    <!--[if lt IE 7]>
        <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]-->
        <header>
      <ul id="nav">
	<li><a href="news.html">News</a></li>
	<li><a href="index.html">Overview</a>
	  <ul>
	    <li><a>Domain specific languages</a>
	      <ul>
		<li><a href="material-properties.html">Material properties</a></li>
		<li><a href="behaviours.html">Mechanical behaviours</a></li>
		<li><a href="models.html">Models</a></li>
	      </ul>
            </li>
	    <li><a href="interfaces.html">Available interfaces</a></li>
	    <li><a href="associated-projects.html">Associated projects</a></li>
     	    <li><a>Tools</a>
	      <ul>
	        <li><a href="mfront-doc.html">mfront-doc</a></li>
	        <li><a href="mtest.html">mtest</a></li>
	        <li><a href="mfm.html">mfm</a></li>
	        <li><a href="mfm-test-generator.html">mfm-test-generator</a></li>
	        <li><a href="tfel-check.html">tfel-check</a></li>
	      </ul>
	    </li>
	  </ul>
	</li>
	<li><a>Getting started</a>
	  <ul>
	    <li><a href="https://github.com/thelfer/tfel/">Github repository</a></li>
	    <li><a href="https://github.com/thelfer/tfel/releases">Download</a></li>
	    <li><a href="release-notes.html">Release notes</a>
	      <ul>
		<li><a>Versions 2.0.x</a>
                  <ul>
                    <li><a href="release-notes.html">Versions prior to 2.0.5</a></li>
	 	    <li><a href="release-notes-2.0.5.html">Version 2.0.5</a></li>
                  </ul>
		</li>
		<li><a>Versions 3.0.x</a>
                  <ul>
		    <li><a href="release-notes-3.0.html">Version 3.0.0</a></li>
		    <li><a href="release-notes-3.0.1.html">Version 3.0.1</a></li>
		    <li><a href="release-notes-3.0.2.html">Version 3.0.2</a></li>
		    <li><a href="release-notes-3.0.3.html">Version 3.0.3</a></li>
		    <li><a href="release-notes-3.0.4.html">Version 3.0.4</a></li>
		    <li><a href="release-notes-3.0.5.html">Version 3.0.5</a></li>
		    <li><a href="release-notes-3.0.6.html">Version 3.0.6</a></li>
		    <li><a href="release-notes-3.0.7.html">Version 3.0.7</a></li>
		    <li><a href="release-notes-3.0.8.html">Version 3.0.8</a></li>
		    <li><a href="release-notes-3.0.9.html">Version 3.0.9</a></li>
		    <li><a href="release-notes-3.0.10.html">Version 3.0.10</a></li>
		    <li><a href="release-notes-3.0.11.html">Version 3.0.11</a></li>
		    <li><a href="release-notes-3.0.12.html">Version 3.0.12</a></li>
		    <li><a href="release-notes-3.0.13.html">Version 3.0.13</a></li>
		    <li><a href="release-notes-3.0.14.html">Version 3.0.14</a></li>
		    <li><a href="release-notes-3.0.15.html">Version 3.0.15</a></li>
		    <li><a href="release-notes-3.0.16.html">Version 3.0.16</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.1.x</a>
		  <ul>
		    <li><a href="release-notes-3.1.html">Version 3.1.0</a></li>
		    <li><a href="release-notes-3.1.1.html">Version 3.1.1</a></li>
		    <li><a href="release-notes-3.1.2.html">Version 3.1.2</a></li>
		    <li><a href="release-notes-3.1.3.html">Version 3.1.3</a></li>
		    <li><a href="release-notes-3.1.4.html">Version 3.1.4</a></li>
		    <li><a href="release-notes-3.1.5.html">Version 3.1.5</a></li>
		    <li><a href="release-notes-3.1.6.html">Version 3.1.6</a></li>
		    <li><a href="release-notes-3.1.7.html">Version 3.1.7</a></li>
		    <li><a href="release-notes-3.1.8.html">Version 3.1.8</a></li>
		    <li><a href="release-notes-3.1.9.html">Version 3.1.9</a></li>
		    <li><a href="release-notes-3.1.10.html">Version 3.1.10</a></li>
		    <li><a href="release-notes-3.1.11.html">Version 3.1.11</a></li>
		    <li><a href="release-notes-3.1.12.html">Version 3.1.12</a></li>
		    <li><a href="release-notes-3.1.13.html">Version 3.1.13</a></li>
		    <li><a href="release-notes-3.1.14.html">Version 3.1.14</a></li>
		    <li><a href="release-notes-3.1.15.html">Version 3.1.15</a></li>
		    <li><a href="release-notes-3.1.16.html">Version 3.1.16</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.2.x</a>
		  <ul>
		    <li><a href="release-notes-3.2.html">Version 3.2.0</a></li>
		    <li><a href="release-notes-3.2.1.html">Version 3.2.1</a></li>
		    <li><a href="release-notes-3.2.2.html">Version 3.2.2</a></li>
		    <li><a href="release-notes-3.2.3.html">Version 3.2.3</a></li>
		    <li><a href="release-notes-3.2.4.html">Version 3.2.4</a></li>
		    <li><a href="release-notes-3.2.5.html">Version 3.2.5</a></li>
		    <li><a href="release-notes-3.2.6.html">Version 3.2.6</a></li>
		    <li><a href="release-notes-3.2.7.html">Version 3.2.7</a></li>
		    <li><a href="release-notes-3.2.8.html">Version 3.2.8</a></li>
		    <li><a href="release-notes-3.2.9.html">Version 3.2.9</a></li>
		    <li><a href="release-notes-3.2.10.html">Version 3.2.10</a></li>
		    <li><a href="release-notes-3.2.11.html">Version 3.2.11</a></li>
		    <li><a href="release-notes-3.2.12.html">Version 3.2.12</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.3.x</a>
		  <ul>
		    <li><a href="release-notes-3.3.html">Version 3.3.0</a></li>
		    <li><a href="release-notes-3.3.1.html">Version 3.3.1</a></li>
		    <li><a href="release-notes-3.3.1.html">Version 3.3.2</a></li>
		    <li><a href="release-notes-3.3.2.html">Version 3.3.2</a></li>
		    <li><a href="release-notes-3.3.3.html">Version 3.3.3</a></li>
		    <li><a href="release-notes-3.3.4.html">Version 3.3.4</a></li>
		    <li><a href="release-notes-3.3.5.html">Version 3.3.5</a></li>
		    <li><a href="release-notes-3.3.6.html">Version 3.3.6</a></li>
		    <li><a href="release-notes-3.3.7.html">Version 3.3.7</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.4.x</a>
		  <ul>
		    <li><a href="release-notes-3.4.html">Version 3.4.0</a></li>
		    <li><a href="release-notes-3.4.1.html">Version 3.4.1</a></li>
		    <li><a href="release-notes-3.4.2.html">Version 3.4.2</a></li>
		    <li><a href="release-notes-3.4.3.html">Version 3.4.3</a></li>
		    <li><a href="release-notes-3.4.4.html">Version 3.4.4</a></li>
		    <li><a href="release-notes-3.4.5.html">Version 3.4.5</a></li>
		    <li><a href="release-notes-3.4.6.html">Version 3.4.6</a></li>
		    <li><a href="release-notes-3.4.7.html">Version 3.4.7</a></li>
		    <li><a href="release-notes-3.4.8.html">Version 3.4.8</a></li>
		    <li><a href="release-notes-3.4.9.html">Version 3.4.9</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.0.x</a>
		  <ul>
		    <li><a href="release-notes-4.0.html">Version 4.0.0</a></li>
		    <li><a href="release-notes-4.0.1.html">Version 4.0.1</a></li>
		    <li><a href="release-notes-4.0.2.html">Version 4.0.2</a></li>
		    <li><a href="release-notes-4.0.3.html">Version 4.0.3</a></li>
		    <li><a href="release-notes-4.0.4.html">Version 4.0.4</a></li>
		    <li><a href="release-notes-4.0.5.html">Version 4.0.5</a></li>
		    <li><a href="release-notes-4.0.6.html">Version 4.0.6</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.1.x</a>
		  <ul>
		    <li><a href="release-notes-4.1.html">Version 4.1.0</a></li>
		    <li><a href="release-notes-4.1.1.html">Version 4.1.1</a></li>
		    <li><a href="release-notes-4.1.2.html">Version 4.1.2</a></li>
		    <li><a href="release-notes-4.1.3.html">Version 4.1.3</a></li>
		    <li><a href="release-notes-4.1.4.html">Version 4.1.4</a></li>
		    <li><a href="release-notes-4.1.5.html">Version 4.1.5</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.2.x</a>
		  <ul>
		    <li><a href="release-notes-4.2.html">Version 4.2.0</a></li>
		    <li><a href="release-notes-4.2.1.html">Version 4.2.1</a></li>
		    <li><a href="release-notes-4.2.2.html">Version 4.2.2</a></li>
		    <li><a href="release-notes-4.2.3.html">Version 4.2.3</a></li>
		  </ul>
		</li>
		<li><a>Versions 5.0.x</a>
		  <ul>
		    <li><a href="release-notes-5.0.html">Version 5.0.0</a></li>
		    <li><a href="release-notes-5.0.1.html">Version 5.0.1</a></li>
		    <li><a href="release-notes-5.0.2.html">Version 5.0.2</a></li>
		  </ul>
		</li>
		<li><a>Versions 5.1.x</a>
		  <ul>
		    <li><a href="release-notes-5.1.html">Version 5.1.0</a></li>
		  </ul>
		</li>
	      </ul>
	    </li>
	    <li><a href="coverity-scan.html">Coverity scan</a></li>
	    <li><a href="install.html">Installation</a></li>
	  </ul>
	</li>
	<li><a>Documentation</a>
	  <ul>
	    <li><a href="documentations.html">General documentation</a></li>
	    <li><a href="gallery.html">Gallery</a></li>
<!--	    
	    <li><a href="http://tfel.sourceforge.net/doxygen/index.html">Doxygen documentation</a></li>
-->
	    <li><a>Behaviours</a>
	      <ul>
		<li><a href="tutorial.html">Tutorial</a></li>
		<li><a href="implicit-dsl.html">The Implicit DSL</a></li>
		<li><a href="benchmark.html">Benchmark</a></li>
		<li><a href="parameters.html">Parameters</a></li>
		<li><a href="BehaviourBricks.html">Behaviour bricks</a></li>
		<li><a href="interfaces.html">Solver interfaces</a>
		  <ul>
		    <li><a href="castem.html">Cast3M</a></li>
		    <li><a href="amitex.html">AMITEX_FFTP</a></li>
		    <li><a href="aster.html">Code-Aster</a></li>
    		    <li><a href="abaqus.html">Abaqus</a></li>
		    <li><a href="zmat.html">ZeBuLoN</a></li>
   		    <li><a href="calculix.html">CalculiX</a></li>
		    <!-- <li><a >TMFFT</a></li> -->
		    <li><a href="cyrano.html">Cyrano</a></li>
   		    <li><a href="generic-material-property-interface.html">Generic interface for material properties</a></li>
   		    <li><a href="generic-behaviours-interface.html">Generic interface for behaviours</a></li>
		  </ul>
		</li>
	      </ul>
	    </li>
	    <li><a>TFEL libraries</a>
	      <ul>
		<li><a href="libraries_usage.html">Usage of the TFEL libraries in C++</a></li>
		<li><a href="tfel-math.html">TFEL/Math</a></li>
		<li><a href="tfel-material.html">TFEL/Material</a></li>
	      </ul>
	    </li>
	    <li><a>Python modules</a>
	      <ul>
		<li><a href="tfel-python.html">TFEL modules</a></li>
		<li><a href="mfront-python.html">mfront module</a></li>
		<li><a href="mtest-python.html">mtest module</a></li>
	      </ul>
	    </li>
	    <li><a>MFront keywords</a>
	      <ul>
	        <li><a href="Default-keywords.html">Default</a></li>
	        <li><a href="DefaultCZM-keywords.html">DefaultCZM</a></li>
	        <li><a href="DefaultFiniteStrain-keywords.html">DefaultFiniteStrain</a></li>
	        <li><a href="DefaultGenericBehaviour-keywords.html">DefaultGenericBehaviour</a></li>
	        <li><a href="DefaultModel-keywords.html">DefaultModel</a></li>
	        <li><a href="Implicit-keywords.html">Implicit</a></li>
	        <li><a href="ImplicitCZM-keywords.html">ImplicitCZM</a></li>
	        <li><a href="ImplicitFiniteStrain-keywords.html">ImplicitFiniteStrain</a></li>
	        <li><a href="ImplicitGenericBehaviour-keywords.html">ImplicitGenericBehaviour</a></li>
	        <li><a href="ImplicitModel-keywords.html">ImplicitModel</a></li>
	        <li><a href="ImplicitII-keywords.html">ImplicitII</a></li>
	        <li><a href="IsotropicMisesCreep-keywords.html">IsotropicMisesCreep</a></li>
	        <li><a href="IsotropicMisesPlasticFlow-keywords.html">IsotropicMisesPlasticFlow</a></li>
	        <li><a href="IsotropicPlasticMisesFlow-keywords.html">IsotropicPlasticMisesFlow</a></li>
	        <li><a href="IsotropicStrainHardeningMisesCreep-keywords.html">IsotropicStrainHardeningMisesCreep</a></li>
	        <li><a href="MaterialLaw-keywords.html">MaterialLaw</a></li>
	        <li><a href="MaterialProperty-keywords.html">MaterialProperty</a></li>
	        <li><a href="Model-keywords.html">Model</a></li>
	        <li><a href="MultipleIsotropicMisesFlows-keywords.html">MultipleIsotropicMisesFlows</a></li>
	        <li><a href="RungeKutta-keywords.html">RungeKutta</a></li>
	        <li><a href="RungeKuttaFiniteStrain-keywords.html">RungeKuttaFiniteStrain</a></li>
	        <li><a href="RungeKuttaGenericBehaviour-keywords.html">RungeKuttaGenericBehaviour</a></li>
	        <li><a href="RungeKuttaModel-keywords.html">RungeKuttaModel</a></li>
	      </ul>
	    </li>
	    <li><a href="MTest-keywords.html">MTest keywords</a></li>
	    <li><a href="physical-constants.html">Physical constants</a></li>
	    <li><a href="glossary.html">Glossary</a></li>
	    <li><a href="publications.html">Publications</a></li>
	    <li><a href="faq.html">FAQ</a></li>
	    <li><a href="about.html">About</a></li>
	  </ul>
	</li>
	<li><a>Contributing</a>
	  <ul>
	    <li><a href="https://github.com/thelfer/tfel">Access to sources</a></li>
	    <li><a href="contributing.html">Contributing guidelines</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Report bugs</a></li>
	  </ul>
	</li>
	<li><a>Getting Help</a>
	  <ul>
	    <li><a href="search.html">Search on this site</a></li>
	    <li><a href="https://github.com/thelfer/tfel/discussions">Forum</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Bug report</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Feature request</a></li>
	    <li><a href="mailto:tfel-contact@cea.fr">Contact</a></li>
	  </ul>
	</li>
      </ul>
    </header>
<div id="header">
<h1 class="title">The TFEL/Material library</h1>
<h2 class="author">Thomas Helfer</h2>
<h3 class="date">19/12/2017</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#equivalent-stress" id="toc-equivalent-stress">Equivalent
stress</a>
<ul>
<li><a href="#sec:hosford" id="toc-sec:hosford">Hosford equivalent
stress</a></li>
<li><a href="#sec:barlat" id="toc-sec:barlat">Barlat equivalent
stress</a></li>
</ul></li>
<li><a href="#general-functionalities"
id="toc-general-functionalities">General functionalities</a>
<ul>
<li><a href="#computation-of-the-inverse-of-the-langevin-function"
id="toc-computation-of-the-inverse-of-the-langevin-function">Computation
of the inverse of the Langevin function</a></li>
<li><a href="#example-of-usage" id="toc-example-of-usage">Example of
usage</a></li>
<li><a href="#pi-plane" id="toc-pi-plane"><span
class="math inline">\(\pi\)</span>-plane</a></li>
</ul></li>
<li><a href="#orthotropic-axes-convention"
id="toc-orthotropic-axes-convention">Orthotropic axes
convention</a></li>
<li><a href="#isotropic-elastic-moduli"
id="toc-isotropic-elastic-moduli">Isotropic elastic moduli</a></li>
<li><a href="#homogenization" id="toc-homogenization">Homogenization</a>
<ul>
<li><a href="#eshelby-hill-and-localisation-tensors"
id="toc-eshelby-hill-and-localisation-tensors">Eshelby, Hill and
localisation tensors</a></li>
<li><a href="#computation-in-anisotropic-reference-medium"
id="toc-computation-in-anisotropic-reference-medium">Computation in
anisotropic reference medium</a></li>
<li><a href="#homogenization-schemes-for-biphasic-media"
id="toc-homogenization-schemes-for-biphasic-media">Homogenization
schemes for biphasic media</a></li>
<li><a href="#homogenization-bounds"
id="toc-homogenization-bounds">Homogenization bounds</a></li>
<li><a href="#homogenization-of-general-microstructures"
id="toc-homogenization-of-general-microstructures">Homogenization of
general microstructures</a></li>
</ul></li>
</ul>
</div>
<h1 id="equivalent-stress">Equivalent stress</h1>
<h2 id="sec:hosford">Hosford equivalent stress</h2>
<p>The header <code>TFEL/Material/Hosford1972YieldCriterion.hxx</code>
introduces three functions which are meant to compute the Hosford
equivalent stress and its first and second derivatives. <em>This header
is automatically included by <code>MFront</code></em></p>
<p>The Hosford equivalent stress is defined by: <span
class="math display">\[
\sigma_{\mathrm{eq}}^{H}=\sqrt[a]{\displaystyle\frac{\displaystyle
1}{\displaystyle
2}\left({\left|\sigma_{1}-\sigma_{2}\right|}^{a}+{\left|\sigma_{1}-\sigma_{3}\right|}^{a}+{\left|\sigma_{2}-\sigma_{3}\right|}^{a}\right)}
\]</span> where <span class="math inline">\(s_{1}\)</span>, <span
class="math inline">\(s_{2}\)</span> and <span
class="math inline">\(s_{3}\)</span> are the eigenvalues of the
stress.</p>
<p>Therefore, when <span class="math inline">\(a\)</span> goes to
infinity, the Hosford stress reduces to the Tresca stress. When <span
class="math inline">\(n = 2\)</span> the Hosford stress reduces to the
von Mises stress.</p>
<p>The following functions has been implemented:</p>
<ul>
<li><code>computeHosfordStress</code>: return the Hosford equivalent
stress</li>
<li><code>computeHosfordStressNormal</code>: return a tuple containing
the Hosford equivalent stress and its first derivative (the normal)</li>
<li><code>computeHosfordStressSecondDerivative</code>: return a tuple
containing the Hosford equivalent stress, its first derivative (the
normal) and the second derivative.</li>
</ul>
<h4 id="example">Example</h4>
<p>The following example computes the Hosford equivalent stress, its
normal and second derivative:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>stress seq<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Stensor  n<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Stensor4 dn<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>tie<span class="op">(</span>seq<span class="op">,</span>n<span class="op">,</span>dn<span class="op">)</span> <span class="op">=</span> computeHosfordStressSecondDerivative<span class="op">(</span>s<span class="op">,</span>a<span class="op">,</span>seps<span class="op">);</span></span></code></pre></div>
<p>In this example, <code>s</code> is the stress tensor, <code>a</code>
is the Hosford exponent, <code>seps</code> is a numerical parameter used
to detect when two eigenvalues are equal.</p>
<p>If <code>C++-17</code> is available, the previous code can be made
much more readable:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>seq<span class="op">,</span>n<span class="op">,</span>dn<span class="op">]</span> <span class="op">=</span> computeHosfordStressSecondDerivative<span class="op">(</span>s<span class="op">,</span>a<span class="op">,</span>seps<span class="op">);</span></span></code></pre></div>
<h2 id="sec:barlat">Barlat equivalent stress</h2>
<p>The header <code>TFEL/Material/Barlat2004YieldCriterion.hxx</code>
introduces various functions which are meant to compute the Barlat
equivalent stress and its first and second derivatives. <em>This header
is automatically included by <code>MFront</code></em> for orthotropic
behaviours.</p>
<p>The Barlat equivalent stress is defined as follows (see <span
class="citation" data-cites="barlat_linear_2005">[1]</span>): <span
class="math display">\[
\sigma_{\mathrm{eq}}^{B}=
\sqrt[a]{
  \frac{1}{4}\left(
  \sum_{i=0}^{3}
  \sum_{j=0}^{3}
  {\left|s&#39;_{i}-s&#39;&#39;_{j}\right|}^{a}
  \right)
}
\]</span></p>
<p>where <span class="math inline">\(s&#39;_{i}\)</span> and <span
class="math inline">\(s&#39;&#39;_{i}\)</span> are the eigenvalues of
two transformed stresses <span
class="math inline">\(\underline{s}&#39;\)</span> and <span
class="math inline">\(\underline{s}&#39;&#39;\)</span> by two linear
transformation <span
class="math inline">\(\underline{\underline{\mathbf{L}}}&#39;\)</span>
and <span
class="math inline">\(\underline{\underline{\mathbf{L}}}&#39;&#39;\)</span>:
<span class="math display">\[
\left\{
\begin{aligned}
\underline{s}&#39;  &amp;= \underline{\underline{\mathbf{L&#39;}}}
\,\colon\,\underline{\sigma}\\
\underline{s}&#39;&#39; &amp;=
\underline{\underline{\mathbf{L&#39;&#39;}}}\,\colon\,\underline{\sigma}\\
\end{aligned}
\right.
\]</span></p>
<p>The linear transformations <span
class="math inline">\(\underline{\underline{\mathbf{L}}}&#39;\)</span>
and <span
class="math inline">\(\underline{\underline{\mathbf{L}}}&#39;&#39;\)</span>
are defined by <span class="math inline">\(9\)</span> coefficients
(each) which describe the material orthotropy. There are defined through
auxiliary linear transformations <span
class="math inline">\(\underline{\underline{\mathbf{C}}}&#39;\)</span>
and <span
class="math inline">\(\underline{\underline{\mathbf{C}}}&#39;&#39;\)</span>
as follows: <span class="math display">\[
\begin{aligned}
\underline{\underline{\mathbf{L}}}&#39;
&amp;=\underline{\underline{\mathbf{C}}}&#39;\,\colon\,\underline{\underline{\mathbf{M}}}
\\
\underline{\underline{\mathbf{L}}}&#39;&#39;&amp;=\underline{\underline{\mathbf{C}}}&#39;&#39;\,\colon\,\underline{\underline{\mathbf{M}}}
\end{aligned}
\]</span> where <span
class="math inline">\(\underline{\underline{\mathbf{M}}}\)</span> is the
transformation of the stress to its deviator: <span
class="math display">\[
\underline{\underline{\mathbf{M}}}=\underline{\underline{\mathbf{I}}}-\displaystyle\frac{\displaystyle
1}{\displaystyle 3}\underline{I}\,\otimes\,\underline{I}
\]</span></p>
<p>The linear transformations <span
class="math inline">\(\underline{\underline{\mathbf{C}}}&#39;\)</span>
and <span
class="math inline">\(\underline{\underline{\mathbf{C}}}&#39;&#39;\)</span>
of the deviator stress are defined as follows: <span
class="math display">\[
\underline{\underline{\mathbf{C}}}&#39;=
\begin{pmatrix}
0 &amp; -c&#39;_{12} &amp; -c&#39;_{13} &amp; 0 &amp; 0 &amp; 0 \\
-c&#39;_{21} &amp; 0 &amp; -c&#39;_{23} &amp; 0 &amp; 0 &amp; 0 \\
-c&#39;_{31} &amp; -c&#39;_{32} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; c&#39;_{44} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; c&#39;_{55} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; c&#39;_{66} \\
\end{pmatrix}
\quad
\text{and}
\quad
\underline{\underline{\mathbf{C}}}&#39;&#39;=
\begin{pmatrix}
0 &amp; -c&#39;&#39;_{12} &amp; -c&#39;&#39;_{13} &amp; 0 &amp; 0 &amp;
0 \\
-c&#39;&#39;_{21} &amp; 0 &amp; -c&#39;&#39;_{23} &amp; 0 &amp; 0 &amp;
0 \\
-c&#39;&#39;_{31} &amp; -c&#39;&#39;_{32} &amp; 0 &amp; 0 &amp; 0 &amp;
0 \\
0 &amp; 0 &amp; 0 &amp; c&#39;&#39;_{44} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; c&#39;&#39;_{55} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; c&#39;&#39;_{66} \\
\end{pmatrix}
\]</span></p>
<p>The following functions have been implemented:</p>
<ul>
<li><code>computeBarlatStress</code>: return the Barlat equivalent
stress</li>
<li><code>computeBarlatStressNormal</code>: return a tuple containing
the Barlat equivalent stress and its first derivative (the normal)</li>
<li><code>computeBarlatStressSecondDerivative</code>: return a tuple
containing the Barlat equivalent stress, its first derivative (the
normal) and the second derivative.</li>
</ul>
<h3 id="linear-transformations">Linear transformations</h3>
<p>To define the linear transformations, the
<code>makeBarlatLinearTransformation</code> function has been
introduced. This function takes two template parameter:</p>
<ul>
<li>the space dimension (<span class="math inline">\(1\)</span>, <span
class="math inline">\(2\)</span>, and <span
class="math inline">\(3\)</span>)</li>
<li>the numeric type used (automatically deduced)</li>
</ul>
<p>This functions takes the <span class="math inline">\(9\)</span>
coefficients as arguments, as follows:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> l1 <span class="op">=</span> makeBarlatLinearTransformation<span class="op">&lt;</span><span class="dv">3</span><span class="op">&gt;(</span>c_12<span class="op">,</span>c_21<span class="op">,</span>c_13<span class="op">,</span>c_31<span class="op">,</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>                                                  c_23<span class="op">,</span>c_32<span class="op">,</span>c_44<span class="op">,</span>c_55<span class="op">,</span>c_66<span class="op">);</span></span></code></pre></div>
<blockquote>
<p><strong>Note</strong> In his paper, Barlat and coworkers uses the
following convention for storing symmetric tensors:</p>
<p><span class="math display">\[
\begin{pmatrix}
xx &amp; yy &amp; zz &amp; yz &amp; zx &amp; xy
\end{pmatrix}
\]</span></p>
<p>which is not consistent with the
<code>TFEL</code>/<code>Cast3M</code>/<code>Abaqus</code>/<code>Ansys</code>
conventions:</p>
<p><span class="math display">\[
\begin{pmatrix}
xx &amp; yy &amp; zz &amp; xy &amp; xz &amp; yz
\end{pmatrix}
\]</span></p>
<p>Therefore, if one wants to use coefficients <span
class="math inline">\(c^{B}\)</span> given by Barlat, one shall call
this function as follows:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> l1 <span class="op">=</span> makeBarlatLinearTransformation<span class="op">&lt;</span><span class="dv">3</span><span class="op">&gt;(</span>cB_12<span class="op">,</span>cB_21<span class="op">,</span>cB_13<span class="op">,</span>cB_31<span class="op">,</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>                                                  cB_23<span class="op">,</span>cB_32<span class="op">,</span>cB_66<span class="op">,</span>cBB_55<span class="op">,</span>cBB_44<span class="op">);</span></span></code></pre></div>
</blockquote>
<p>The <code>TFEL/Material</code> library also provide an overload of
the <code>makeBarlatLinearTransformation</code> which template
parameters are the modelling hypothesis and the orthotropic axis
conventions. The purpose of this overload is to swap appropriate
coefficients to get a consistent definition of the linear
transformations for all the modelling hypotheses.</p>
<h1 id="general-functionalities">General functionalities</h1>
<h2 id="computation-of-the-inverse-of-the-langevin-function">Computation
of the inverse of the Langevin function</h2>
<p>The inverse Langevin function is used in many statistically based
network behaviours describing rubber-like materials.</p>
<p>The Langevin function <span
class="math inline">\(\mathcal{L}\)</span> is defined as follows: <span
class="math display">\[
\mathcal{L}\left(x\right)=\displaystyle\frac{\displaystyle
1}{\displaystyle \coth\left(x\right)}-\displaystyle\frac{\displaystyle
1}{\displaystyle x}
\]</span></p>
<p>The complexity of the inverse Langevin function <span
class="math inline">\(\mathcal{L}^{-1}\left(x\right)\)</span> motivated
the development of various approximations <span class="citation"
data-cites="cohen_pade_1991 bergstrom_constitutive_1998 jedynak_approximation_2015">[2–4]</span>.</p>
<figure id="fig:tfel_4.1:tfel_material:inverse_langevin_function">
<img src="img/InverseLangevinFunction.svg" style="width:95.0%"
alt="Comparison of various approximations of the inverse Langenvin function" />
<figcaption>Figure 1: Comparison of various approximations of the
inverse Langenvin function</figcaption>
</figure>
<p>Figure 1 compares those approximations. The approximations of
Bergström and Boyce <span class="citation"
data-cites="bergstrom_constitutive_1998">[3]</span> and Jedynak <span
class="citation" data-cites="jedynak_approximation_2015">[4]</span> are
undistinguishable. See Jedynak for a quantitative discussion of the
error generated by those approximations <span class="citation"
data-cites="jedynak_approximation_2015">[4]</span>. It is worth noting
that all those approximations mostly differs near the pole of inverse
Langevin function <span
class="math inline">\(\mathcal{L}^{-1}\left(x\right)\)</span>.</p>
<p>The <code>InverseLangevinFunctionApproximations</code> enumeration
lists the approximations that have been implemented and that can be
evaluated in a <code>constexpr</code> context:</p>
<ul>
<li>The value <code>COHEN_1991</code> is associated with the
approximation proposed by Cohen <span class="citation"
data-cites="cohen_pade_1991">[2]</span>: <span class="math display">\[
\mathcal{L}^{-1}\left(x\right) \approx
y\displaystyle\frac{\displaystyle 3-y^{2}}{\displaystyle 1-y^{2}}.
\]</span></li>
<li>The value <code>JEDYNAK_2015</code> is associated with the
approximation proposed by Jedynak <span class="citation"
data-cites="jedynak_approximation_2015">[4]</span>: <span
class="math display">\[
\mathcal{L}^{-1}\left(x\right) \approx
y \, \displaystyle\frac{\displaystyle c_{0} + c_{1}\,y +
c_{2}\,y^{2}}{\displaystyle 1 + d_{1}\,y + d_{2}\,y^{2}}
\]</span></li>
<li><code>KUHN_GRUN_1942</code> or <code>MORCH_2022</code> are
associated with a taylor expansion of <span
class="math inline">\(\mathcal{L}^{-1}\left(x\right)\)</span> at <span
class="math inline">\(0\)</span>: <span class="math display">\[
\mathcal{L}^{-1}\left(x\right) \approx
y\,P\left(y^{2}\right) \quad\text{with}\quad
P\left(y^{2}\right)=\sum_{i=0}^{9}c_{i}\,\left(y^{2}\right)^{i}
\]</span> where <span class="math inline">\(P\)</span> is a <span
class="math inline">\(9\)</span>th order polynomial. Hence, the Taylor
expression is of order <span class="math inline">\(19\)</span>.</li>
</ul>
<p>The <code>computeApproximateInverseLangevinFunction</code> computes
one approximation of the inverse Langevin function and the
<code>computeApproximateInverseLangevinFunctionAndDerivative</code>
function computes an approximation of the inverse Langevin function and
its derivative. These functions have two template parameters: the
approximation selected and the numeric type to be used. By default, the
<code>JEDYNAK_2015</code> approximation is used and the numeric type can
be deduced from the type of the argument.</p>
<p>The approximation proposed by Bergström and Boyce <span
class="citation" data-cites="bergstrom_constitutive_1998">[3]</span> is
given by the following function: <span class="math display">\[
\mathcal{L}^{-1}\left(x\right)
\approx
\left\{
\begin{aligned}
c_{1} \tan\left(c_{2} \, x\right) + c_{3} \, x &amp;\quad\text{if}\quad
\left|x\right| \leq c_{0}\\
\displaystyle\frac{\displaystyle 1}{\displaystyle
\mathop{sign}\left(x\right)-x}&amp;\quad\text{if}\quad \left|x\right|
&gt; c_{0}
\end{aligned}
\right.
\]</span></p>
<p>The
<code>computeBergstromBoyce1998ApproximateInverseLangevinFunction</code>
function computes this approximation and the
<code>computeBergstromBoyce1998ApproximateInverseLangevinFunctionAndDerivative</code>
function computes this function and its derivative. These functions
can’t be declared <code>constexpr</code> because of tangent function is
not <code>constexpr</code>. These functions have one template parameter,
the numeric type to be used. This template parameter can be
automatically deduced from the type of the argument.</p>
<h2 id="example-of-usage">Example of usage</h2>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> ApproximationFunctions <span class="op">=</span> InverseLangevinFunctionApproximations<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">// compute Cohen&#39;s approximation of the inverse Langevin function</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> v <span class="op">=</span> computeApproximateInverseLangevinFunction<span class="op">&lt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>            ApproximationFunctions<span class="op">::</span>COHEN_1991<span class="op">&gt;(</span>y<span class="op">)</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">// compute Jedynak&#39;s approximation of the inverse Langevin function and its derivative</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>f<span class="op">,</span> df<span class="op">]</span> <span class="op">=</span> computeApproximateInverseLangevinFunctionAndDerivative<span class="op">(</span>y<span class="op">)</span></span></code></pre></div>
<h2 id="pi-plane"><span class="math inline">\(\pi\)</span>-plane</h2>
<p>The <span class="math inline">\(\pi\)</span>-plane is defined in the
space defined by the three eigenvalues <span
class="math inline">\(S_{0}\)</span>, <span
class="math inline">\(S_{1}\)</span> and <span
class="math inline">\(S_{2}\)</span> of the stress by the following
equations: <span class="math display">\[
S_{0}+S_{1}+S_{2}=0
\]</span></p>
<p>This plane contains deviatoric stress states and is perpendicular to
the hydrostatic axis. A basis of this plane is given by the following
vectors: <span class="math display">\[
\vec{n}_{0}=
\frac{1}{\sqrt{2}}\,
\begin{pmatrix}
1  \\
-1 \\
0
\end{pmatrix}
\quad\text{and}\quad
\vec{n}_{1}=
\frac{1}{\sqrt{6}}\,
\begin{pmatrix}
-1 \\
-1 \\
2
\end{pmatrix}
\]</span></p>
<p>This plane is used to characterize the iso-values of equivalent
stresses which are not sensitive to the hydrostatic pressure.</p>
<p>Various functions are available:</p>
<ul>
<li><code>projectOnPiPlane</code>: this function projects a stress state
on the <span class="math inline">\(\pi\)</span>-plane.</li>
<li><code>buildFromPiPlane</code>: this function builds a stress state,
defined by its three eigenvalues, from its coordinate in the <span
class="math inline">\(\pi\)</span>-plane.</li>
</ul>
<h1 id="orthotropic-axes-convention">Orthotropic axes convention</h1>
<p>Most finite element solver can’t have a unique definition of the
orthotropic axes valid for all the modelling hypotheses.</p>
<p>For example, one can define a pipe using the following axes
definition:</p>
<ul>
<li><span class="math inline">\(\left(rr,zz,tt,...\right)\)</span> in
<span class="math inline">\(3D\)</span>, <span
class="math inline">\(2D\)</span> axysymmetric, <span
class="math inline">\(1D\)</span> axisymmetric generalised plane strain
or <span class="math inline">\(1D\)</span> axisymmetric generalised
plane stress.</li>
<li><span class="math inline">\(\left(rr,tt,zz,...\right)\)</span> in
<span class="math inline">\(2D\)</span> plane stress, <span
class="math inline">\(2D\)</span> plane strain and <span
class="math inline">\(2D\)</span> generalized plane strain.</li>
</ul>
<figure>
<img src="img/pipe.svg"
title="The `Pipe` orthotropic axes convention for (3D), (2D) axysymmetric, (1D) axisymmetric generalised plane strain or generalised plane stress (left) and (2D) plane stress, strain, generalized plane strain (right)"
style="width:50.0%"
alt="The Pipe orthotropic axes convention for 3D, 2D axysymmetric, 1D axisymmetric generalised plane strain or generalised plane stress (left) and 2D plane stress, strain, generalized plane strain (right)" />
<figcaption aria-hidden="true">The <code>Pipe</code> orthotropic axes
convention for <span class="math inline">\(3D\)</span>, <span
class="math inline">\(2D\)</span> axysymmetric, <span
class="math inline">\(1D\)</span> axisymmetric generalised plane strain
or generalised plane stress (left) and <span
class="math inline">\(2D\)</span> plane stress, strain, generalized
plane strain (right)</figcaption>
</figure>
<p>With those conventions, named <code>Pipe</code> in
<code>MFront</code>, the axial direction is either the second or the
third material axis, a fact that must be taken into account when
defining the stiffness tensor, the Hill tensor(s), the thermal
expansion, etc.</p>
<p>This convention is only valid for <span
class="math inline">\(3D\)</span>, <span
class="math inline">\(2D\)</span> axysymmetric, <span
class="math inline">\(1D\)</span> axisymmetric generalised plane strain
or generalised plane stress. - <span
class="math inline">\(\left(rr,tt,zz,...\right)\)</span> in <span
class="math inline">\(2D\)</span> plane stress, strain, generalized
plane strain.</p>
<figure>
<img src="img/plate.svg" title="The `Plate` orthotropic axes convention"
style="width:50.0%" alt="The Plate orthotropic axes convention" />
<figcaption aria-hidden="true">The <code>Plate</code> orthotropic axes
convention</figcaption>
</figure>
<p>If we were to model plates, an appropriate convention is the
following:</p>
<ul>
<li>The first material axis is the rolling direction</li>
<li>The second material axis is the in plane direction perpendicular to
the rolling direction (transverse direction).</li>
<li>The third material axis is the normal to the plate.</li>
</ul>
<p>By definition, this convention, named <code>Plate</code> in
<code>MFront</code> is only valid for <span
class="math inline">\(3D\)</span>, <span
class="math inline">\(2D\)</span> plane stress, <span
class="math inline">\(2D\)</span> plane strain and <span
class="math inline">\(2D\)</span> generalized plane strain modelling
hypotheses.</p>
<h1 id="isotropic-elastic-moduli">Isotropic elastic moduli</h1>
<p>Three data structures are defined to represent the isotropic moduli
of an isotropic material:</p>
<ul>
<li><code>KGModuli</code> (attributes:
<code>kappa</code>,<code>mu</code>)</li>
<li><code>YoungNuModuli</code> (attributes:
<code>young</code>,<code>nu</code>)</li>
<li><code>LambdaMuModuli</code> (attributes:
<code>lambda</code>,<code>mu</code>)</li>
</ul>
<p>It can be constructed as follows:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG <span class="op">=</span> KGModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>ka<span class="op">,</span>mu<span class="op">);</span></span></code></pre></div>
<p>And its attributes can be recovered as follows:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> K <span class="op">=</span> KG<span class="op">.</span>kappa<span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> G <span class="op">=</span> KG<span class="op">.</span>mu<span class="op">;</span></span></code></pre></div>
<p>It can be converted to the other describing isotropic moduli as
follows:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> Enu <span class="op">=</span> KG<span class="op">.</span>ToYoungNu<span class="op">();</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> LambdaMu <span class="op">=</span> KG<span class="op">.</span>ToLambdaMu<span class="op">();</span></span></code></pre></div>
<p>Moreover, some useful functions allow to go from one to another:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C <span class="op">=</span> computeIsotropicStiffnessTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>Enu<span class="op">);</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG <span class="op">=</span> computeKGModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C<span class="op">);</span></span></code></pre></div>
<p>Note that <code>computeKGModuli</code> makes a projection on the
fourth-order tensors <span
class="math inline">\(\underline{\underline{\mathbf{J}}}\)</span> and
<span class="math inline">\(\underline{\underline{\mathbf{K}}}\)</span>
if <span
class="math inline">\(\underline{\underline{\mathbf{C}}}\)</span> is not
isotropic. It can be check that <span
class="math inline">\(\underline{\underline{\mathbf{C}}}\)</span> is
isotropic by doing</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> eps <span class="op">=</span> <span class="fl">1e-6</span><span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">bool</span> <span class="op">=</span> isIsotropic<span class="op">(</span>C<span class="op">,</span>eps<span class="op">);</span></span></code></pre></div>
<p>Here, <code>isIsotropic</code> first projects <span
class="math inline">\(\underline{\underline{\mathbf{C}}}\)</span> on the
isotropic basis, and constructs the isotropized of <span
class="math inline">\(\underline{\underline{\mathbf{C}}}\)</span>. Then,
it computes the relative difference between <span
class="math inline">\(\underline{\underline{\mathbf{C}}}\)</span> and
its isotropized, by using the <span
class="math inline">\(L2\)</span>-norm. This difference is compared to
the tolerance <code>eps</code>.</p>
<h1 id="homogenization">Homogenization</h1>
<p>The homogenization functions are part of the namespace
<code>tfel::material::homogenization</code>. A specialization for
elasticity is defined:
<code>tfel::material::homogenization::elasticity</code>.</p>
<h2 id="eshelby-hill-and-localisation-tensors">Eshelby, Hill and
localisation tensors</h2>
<h3 id="definitions">Definitions</h3>
<p>If we consider a constant stress-free strain <span
class="math inline">\(\underline{\varepsilon}^\mathrm{T}\)</span>
filling an ellipsoidal volume embedded in an infinite homogeneous medium
whose elasticity is <span
class="math inline">\(\underline{\underline{\mathbf{C}}}_0\)</span>, the
strain tensor inside the ellipsoid is given by</p>
<p><span
class="math inline">\(\underline{\varepsilon}=\underline{\underline{\mathbf{S}}}_0:\underline{\varepsilon}^\mathrm{T}\)</span>.</p>
<p>where <span
class="math inline">\(\underline{\underline{\mathbf{S}}}_0\)</span> is
the Eshelby tensor. The Hill tensor <span
class="math inline">\(\underline{\underline{\mathbf{P}}}_0\)</span>
gives the strain tensor inside the ellipsoid as a function of the
polarization tensor <span class="math inline">\(\underline{\tau }=
-\underline{\underline{\mathbf{C}}}_0:\underline{\varepsilon}^\mathrm{T}\)</span>
:</p>
<p><span
class="math inline">\(\underline{\varepsilon}=-\underline{\underline{\mathbf{P}}}_0:\underline{\tau}\)</span>.</p>
<p>Note that <span
class="math inline">\(\quad\underline{\underline{\mathbf{P}}}_0=\underline{\underline{\mathbf{S}}}_0:\underline{\underline{\mathbf{C}}}_0^{-1}\)</span></p>
<p>The expressions of Eshelby tensor can be found in <span
class="citation" data-cites="torquato_2002">[5]</span> for the
spheroidal inclusions and in <span class="citation"
data-cites="eshelby_1957">[6]</span> for the general ellipsoid (three
different semi-axes).</p>
<p>Now if we consider an ellipsoid whose elasticity is <span
class="math inline">\(\underline{\underline{\mathbf{C}}}_i\)</span>,
embedded in an infinite homogeneous medium whose elasticity is <span
class="math inline">\(\underline{\underline{\mathbf{C}}}_0\)</span>,
submitted to a external uniform strain field at infinity <span
class="math inline">\(\underline{E}\)</span>, the strain field within
the ellipsoid is uniform and given by</p>
<p><span class="math inline">\(\underline{\varepsilon }=
\underline{\underline{\mathbf{A}}}:\underline{E}\)</span></p>
<p>where <span
class="math inline">\(\underline{\underline{\mathbf{A}}}\)</span> is the
strain localisation (or concentration) tensor.</p>
<h3 id="computation-in-isotropic-reference-medium">Computation in
isotropic reference medium</h3>
<h4 id="eshelby-and-hill-tensors">Eshelby and Hill tensors</h4>
<p>The header <code>IsotropicEshelbyTensor.hxx</code> introduces the
computation of the Eshelby tensors and Hill tensors of general
ellipsoids embedded in an isotropic medium.</p>
<p>We can compute the Hill tensors as follows:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0 <span class="op">=</span> computeSphereHillPolarisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">);</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_axi <span class="op">=</span> computeAxisymmetricalHillPolarisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>n_a<span class="op">,</span>e<span class="op">);</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_ellipsoid <span class="op">=</span> computeHillPolarisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span></code></pre></div>
<p>Here, the first line compute the Hill tensor for a sphere. The second
one computes the Hill tensor for an axisymmetrical ellipsoid (or
spheroidal inclusion). The user must provides the normal vector
<code>n_a</code> for the axis, and <code>e</code> for the aspect ratio.
The third line computes the Hill tensor of a more general ellipsoid
whose semi-axis lengths are
<code>a</code>,<code>b</code>,<code>c</code>. The axis <code>a</code> is
related to direction given by <code>n_a</code> and <code>b</code> is
related to the direction given by <code>n_b</code>, which must be normal
to <code>n_a</code>.</p>
<p>An <code>IsotropicModuli</code> can also be passed for the
elasticity, as follows:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> IM0<span class="op">=</span>YoungNuModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">);</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0 <span class="op">=</span> computeSphereHillPolarisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">);</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_axi <span class="op">=</span> computeAxisymmetricalHillPolarisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>n_a<span class="op">,</span>e<span class="op">);</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_ellipsoid <span class="op">=</span> computeHillPolarisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span></code></pre></div>
<p>The Eshelby tensors can be computed as follows:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0 <span class="op">=</span> computeSphereEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>nu0<span class="op">);</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0_axi <span class="op">=</span> computeAxisymmetricalEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>nu0<span class="op">,</span>e<span class="op">);</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0_ellipsoid <span class="op">=</span> computeEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>nu0<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span></code></pre></div>
<p>Note that the Eshelby tensors are not related to a basis, so that it
is recommended to use the Hill tensors instead. In 2 dimensional
framework, Eshelby tensors and Hill tensors are computed as follows:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0_D <span class="op">=</span> computeDiskPlaneStrainEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>nu0<span class="op">);</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0_C <span class="op">=</span> computePlaneStrainEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>nu0<span class="op">,</span>e<span class="op">);</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> IM0<span class="op">=</span>YoungNuModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">);</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_D <span class="op">=</span> computeDiskPlaneStrainHillTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">);</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_C <span class="op">=</span> computePlaneStrainHillTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">);</span></span></code></pre></div>
<p>The <code>computeDiskPlaneStrain</code> refers to a disk in plane
strain framework, whereas the <code>computePlaneStrain</code> refers to
an ellipse oriented by <code>n_a</code>, in a plane strain
framework.</p>
<h4 id="localisation-or-concentration-tensors">Localisation (or
concentration) tensors</h4>
<p>The header <code>LocalisationTensor.hxx</code> also introduces the
computation of the strain localisation tensors of an ellipsoid. These
localisation tensors can be computed as follows:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A <span class="op">=</span> computeSphereLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>Ei<span class="op">,</span>nui<span class="op">);</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_axi <span class="op">=</span> computeAxisymmetricalLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>Ei<span class="op">,</span>nui<span class="op">,</span>n_a<span class="op">,</span>e<span class="op">);</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_ellipsoid <span class="op">=</span> computeLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>Ei<span class="op">,</span>nui<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span></code></pre></div>
<p>Here, the subscript <code>i</code> refers to the inclusion. Here
again, an <code>IsotropicModuli</code> can be passed for the elasticity,
as follows:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> IM0<span class="op">=</span>YoungNuModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">);</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> IMi<span class="op">=</span>YoungNuModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>Ei<span class="op">,</span>nui<span class="op">);</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A <span class="op">=</span> computeSphereLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>IMi<span class="op">);</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_axi <span class="op">=</span> computeAxisymmetricalLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>e<span class="op">);</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_ellipsoid <span class="op">=</span> computeLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span></code></pre></div>
<p>Note that if the elasticity of the inclusion is not isotropic, an
anisotropic elasticity <code>C_i</code> can be provided, assuming that
this elasticiy is expressed in the same basis as the one defined by
<code>n_a,n_b</code> (the local basis of the inclusion):</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_aniso <span class="op">=</span> computeLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>C_i<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span></code></pre></div>
<p>In 2 dimensional framework, localisation tensors are computed as
follows:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_D <span class="op">=</span> computeDiskPlaneStrainLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>C_i<span class="op">);</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_C <span class="op">=</span> computePlaneStrainLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>C_i<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">);</span></span></code></pre></div>
<h2 id="computation-in-anisotropic-reference-medium">Computation in
anisotropic reference medium</h2>
<p>The header <code>AnisotropicEshelbyTensor.hxx</code> introduces the
computation of the Eshelby tensors and Hill tensors of general
ellipsoids embedded in an anisotropic medium.</p>
<p>These tensors can be computed as follows:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0 <span class="op">=</span> computeAnisotropicHillTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_2d <span class="op">=</span> computePlaneStrainAnisotropicHillTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">);</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0 <span class="op">=</span> computeAnisotropicEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0_2d <span class="op">=</span> computePlaneStrainAnisotropicEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">);</span></span></code></pre></div>
<p>The tensors are computed via an integration on a bi-dimensional
domain. The integration is iterative, and the user can provide the
number of iterations (basically, it corresponds to the number of
subdivisions in each domain direction). Hence, more iterations lead to a
more accurate results, but longer to compute. The default number of
iterations is <code>12</code>, but is is recommended to increase it for
sharp ellipsoids:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="bu">std::</span>size_t it <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> </span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0 <span class="op">=</span> computeAnisotropicHillTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">,</span><span class="dv">10</span><span class="op">);</span></span></code></pre></div>
<p>The localisation tensors are introduced in the same header
<code>AnisotropicEshelbyTensor.hxx</code>. We can do as follows:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A <span class="op">=</span> computeAnisotropicLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0_glob<span class="op">,</span>Ci_loc<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_2d <span class="op">=</span> computePlaneStrainAnisotropicLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0_glob<span class="op">,</span>Ci_loc<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">);</span></span></code></pre></div>
<p>The user must provide the elasticity of the inclusion as a
<code>st2tost2</code> <code>Ci_loc</code>, and if it is not isotropic,
it must be provided in the local basis defined by
<code>n_a,n_b</code>.</p>
<h2 id="homogenization-schemes-for-biphasic-media">Homogenization
schemes for biphasic media</h2>
<p>Different classical mean-field homogenization schemes are implemented
for biphasic media. These schemes are introduced by the header
<code>LinearHomogenizationSchemes.hxx</code>. They only deal with
isotropic matrices and locally isotropic inclusions (for anisotropic
matrices or inclusions, see the section “Homogenization of general
microstructures”).</p>
<p>The available schemes are:</p>
<ul>
<li>Mori-Tanaka scheme</li>
<li>dilute scheme</li>
<li>Ponte Castaneda and Willis scheme</li>
</ul>
<p>Each scheme is based on the average of the localisation tensor <span
class="math inline">\(\underline{A}\)</span> defined above. This average
is computed assuming different distributions of ellipsoids. Hence
different cases are considered:</p>
<ul>
<li>spheres (no orientations)</li>
<li>oriented ellipsoids (two vectors <span
class="math inline">\(\underline{n}_a,\underline{n}_b\)</span> define
the orientation)</li>
<li>uniform isotropic distribution of orientations (the ellipsoids have
no preferential orientation)</li>
<li>transverse isotropic distribution of orientations (one axis <span
class="math inline">\(\underline{n}_a\)</span> of the ellipsoid is
fixed, the others are uniformly distributed in the transverse
plane)</li>
</ul>
<p>Hence we can compute the homogenized stiffness returned by the
available schemes. For example, for the distribution of spheres:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> IM0<span class="op">=</span>YoungNuModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">);</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> IMi<span class="op">=</span>YoungNuModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>Ei<span class="op">,</span>nui<span class="op">);</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG_DS <span class="op">=</span> computeSphereDiluteScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">);</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG_MT <span class="op">=</span> computeSphereMoriTanakaScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">);</span></span></code></pre></div>
<p>Note that the two above schemes return a <code>KGModuli</code> object
(see <a href="tfel-material.html#isotropic-elastic-moduli">above</a>).
Also, <code>f</code> is the volume fraction, and the subscript
<code>0</code> refers to the matrix, and the subscript <code>i</code>
refers to the inclusion.</p>
<p>For the oriented inclusions, we can do:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_DS <span class="op">=</span> computeOrientedDiluteScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_MT <span class="op">=</span> computeOrientedMoriTanakaScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_PCW <span class="op">=</span> computeOrientedPCWScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">,</span>D<span class="op">);</span></span></code></pre></div>
<p>Here, the three above schemes return <code>st2tost2</code> objects.
Note that <code>PCW</code> refers to the Ponte-Castaneda and Willis
scheme. For this scheme, a <code>Distribution</code> object must be
created by the user. It is defined by two vectors <span
class="math inline">\(\underline{n}_a,\underline{n}_b\)</span> and three
lengths <span class="math inline">\(a,b,c\)</span> that define the
ellipsoid which defines the distribution:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>Distribution<span class="op">&lt;</span>stress<span class="op">&gt;</span> D <span class="op">=</span> <span class="op">{.</span>n_a <span class="op">=</span> n_a<span class="op">,</span> <span class="op">.</span>a <span class="op">=</span> a<span class="op">,</span> <span class="op">.</span>n_b <span class="op">=</span> n_b<span class="op">,</span> <span class="op">.</span>b <span class="op">=</span> b<span class="op">,</span> <span class="op">.</span>c <span class="op">=</span> c<span class="op">};</span></span></code></pre></div>
<p>For the isotropic distribution of ellipsoids, we can do:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG_DS <span class="op">=</span> computeIsotropicDiluteScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG_MT <span class="op">=</span> computeIsotropicMoriTanakaScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_PCW <span class="op">=</span> computeIsotropicPCWScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">,</span>D<span class="op">);</span></span></code></pre></div>
<p>Here, the two first schemes return <code>KGModuli</code> objects,
whereas <code>computeIsotropicPCWScheme</code> returns a
<code>st2tost2</code> object. For this latter case, the ellipsoids have
indeed a uniform isotropic distribution of orientations, but the user
might use a non-isotropic <code>Distribution D</code>. And finally, we
can consider a transverse isotropic distribution of inclusions:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_DS <span class="op">=</span> computeTransverseIsotropicDiluteScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_MT <span class="op">=</span> computeTransverseIsotropicMoriTanakaScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_PCW <span class="op">=</span> computeTransverseIsotropicPCWScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">,</span>D<span class="op">);</span></span></code></pre></div>
<p>Here, the three above schemes return <code>st2tost2</code> objects.
Because the functions are based on the average of the localisation
tensor <span class="math inline">\(\underline{A}\)</span> associated
with each distribution, a <code>Base</code> function is also defined for
each scheme, that only takes in argument the average of the localisation
tensor <code>A_av</code>. We then can compute a homogenized stiffness
with a very general averaged localisator:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_DS <span class="op">=</span> computeDiluteScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>f<span class="op">,</span>Ei<span class="op">,</span>nui<span class="op">,</span>A_av<span class="op">);</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_MT <span class="op">=</span> computeMoriTanakaScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>f<span class="op">,</span>Ei<span class="op">,</span>nui<span class="op">,</span>A_av<span class="op">);</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_PCW <span class="op">=</span> computePCWScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>f<span class="op">,</span>Ei<span class="op">,</span>nui<span class="op">,</span>A_av<span class="op">,</span>D<span class="op">);</span></span></code></pre></div>
<p>Here, the three above schemes return <code>st2tost2</code> objects. A
tutorial on the computation of homogenized schemes for biphasic
particulate microstructures is available <a
href="BiphasicLinearHomogenization.html">here</a>.</p>
<h2 id="homogenization-bounds">Homogenization bounds</h2>
<p>Different bounds are implemented and are introduced by the header
<code>LinearHomogenizationBounds.hxx</code>. The available bounds
are:</p>
<ul>
<li>Voigt bound</li>
<li>Reuss bound</li>
<li>Hashin-Shtrikman bounds</li>
</ul>
<h2 id="homogenization-of-general-microstructures">Homogenization of
general microstructures</h2>
<p>A <code>ParticulateMicrostructure</code> object can be created for
homogenization of general matrix-inclusion microstructures.</p>
<h3 id="the-particulatemicrostructure-class">The
<code>ParticulateMicrostructure class</code></h3>
<p>The <code>ParticulateMicrostructure class</code> is available in 3d
an 2d via 2 template parameters:
<code>ParticulateMicrostructure&lt;N,stress&gt;</code> with
<code>N</code> the dimension. For the details, see the file
‘MicrostructureDescription.hxx’ which introduces the
<code>class</code>.</p>
<p>A ParticulateMicrostructure consists on a matrix, in which are
embedded several distributions of inclusions. The class has three
(private) attributes:</p>
<ul>
<li><code>number_of_phases</code></li>
<li><code>matrixPhase</code></li>
<li><code>inclusionPhases</code></li>
</ul>
<p>The <code>matrixPhase</code> is of type <code>Phase</code>.</p>
<p>The <code>inclusionPhases</code> is a <code>std::vector</code> of
pointers on <code>InclusionDistribution</code> objects (which represent
the distributions of inclusions).</p>
<h4 id="the-phase-class">The <code>Phase</code> class</h4>
<p>The <code>Phase class</code> is very simple. It has two
attributes:</p>
<ul>
<li><code>fraction</code> (<code>real</code> type)</li>
<li><code>stiffness</code> (<code>st2tost2</code> type)</li>
</ul>
<p>and one method: <code>is_isotropic()</code> which returns a
<code>bool</code> stating if the phase is considered isotropic or not.
The value of this <code>bool</code> depends on the way the
<code>Phase</code> was constructed. By doing</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C0<span class="op">=</span>tfel<span class="op">::</span>math<span class="op">::</span>st2tost2<span class="op">&lt;</span>stress<span class="op">&gt;::</span>Id<span class="op">();</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>Phase<span class="op">&lt;</span>stress<span class="op">&gt;</span> ph<span class="op">(</span>f<span class="op">,</span>C0<span class="op">);</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> b <span class="op">=</span> ph<span class="op">.</span>is_isotropic<span class="op">();</span></span></code></pre></div>
<p><code>b</code> will have the value <code>false</code>, whereas by
doing</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG<span class="op">=</span>tfel<span class="op">::</span>material<span class="op">::</span>KGModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>k<span class="op">,</span>g<span class="op">);</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>Phase<span class="op">&lt;</span>stress<span class="op">&gt;</span> ph<span class="op">(</span>f<span class="op">,</span>KG<span class="op">);</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> b <span class="op">=</span> ph<span class="op">.</span>is_isotropic<span class="op">();</span></span></code></pre></div>
<p><code>b</code> will have the value <code>true</code>.</p>
<h4 id="the-inclusiondistribution-class">The
<code>InclusionDistribution class</code></h4>
<p>The <code>InclusionDistribution class</code> is an abstract class
which represents a distribution of inclusions. It is a child of the
<code>Phase class</code>. There are 4 child <code>class</code> of the
<code>InclusionDistribution class</code>:</p>
<ul>
<li><code>SphereDistribution</code> (distribution of spheres)</li>
<li><code>IsotropicDistribution</code> (isotropic distribution of
ellipsoids)</li>
<li><code>TransverseDistribution</code> (transverse isotropic
distribution of ellipsoids)</li>
<li><code>OrientedDistribution</code> (aligned distribution of
ellipsoids)</li>
</ul>
<p>Each <code>class</code> has a unique attribute <code>inclusion</code>
(which is of type <code>Inclusion</code>, see below), and a method,
<code>computeMeanLocalisator</code>, which computes the average of the
localisation tensor on the distribution. This function is mainly used in
the computation of the homogenization schemes (see below).</p>
<p>These <code>class</code> are currently available in 3d only.</p>
<h4 id="the-inclusion-class">The <code>Inclusion class</code></h4>
<p>The <code>Inclusion class</code> is characterized by its unique
attribute: <code>semiLengths</code>. It is a <code>std::array</code> of
<code>N</code> lengths, which are the semi-lengths of the
ellipsoid/ellipse, where <code>N</code> is the dimension considered (2
or 3). Hence, <code>Inclusion</code> has two template parameters:
<code>Inclusion&lt;N,LengthType&gt;</code>. Some particular
<code>Inclusion</code> objects are also defined:</p>
<ul>
<li><code>Ellipsoid</code> (child of <code>Inclusion</code> in 3d)</li>
<li><code>Spheroid</code> (child of <code>Ellipsoid</code> with the last
two semi-lengths identical)</li>
<li><code>Sphere</code> (child of <code>Spheroid</code> with 3
semi-lengths equal to unity)</li>
</ul>
<h4 id="methods-of-the-particulatemicrostructure-class">Methods of the
<code>ParticulateMicrostructure class</code></h4>
<p>The <code>ParticulateMicrostructure</code> has the following methods
(see ‘MicrostructureDescription.hxx’ for details):</p>
<ul>
<li><code>addInclusionPhase</code></li>
<li><code>removeInclusionPhase</code></li>
<li><code>replaceMatrixPhase</code></li>
<li><code>get_number_of_phases</code>, <code>get_matrix_fraction</code>,
<code>get_matrix_elasticity</code>, <code>is_isotropic_matrix</code>,
<code>get_inclusionPhase</code></li>
</ul>
<h3 id="homogenization-schemes">Homogenization schemes</h3>
<p>The file <code>MicrostructureLinearHomogenization.ixx</code>
introduces the <code>HomogenizationScheme class</code> which has three
attributes:</p>
<ul>
<li><code>homogenized_stiffness</code></li>
<li><code>effective_polarisation</code></li>
<li><code>mean_strain_localisation_tensors</code></li>
</ul>
<p>In the same file are introduced some functions which take a
<code>ParticulateMicrostructure</code> as an argument and returns a
<code>HomogenizationScheme</code> object. Three schemes are
available:</p>
<ul>
<li>dilute scheme</li>
<li>Mori-Tanaka scheme</li>
<li>Self-Consistent scheme</li>
</ul>
<!-- Local IspellDict: english -->
<div id="refs" class="references csl-bib-body" role="list">
<div id="ref-barlat_linear_2005" class="csl-entry" role="listitem">
<div class="csl-left-margin">1. </div><div
class="csl-right-inline"><span class="smallcaps">Barlat</span>, F.,
<span class="smallcaps">Aretz</span>, H., <span
class="smallcaps">Yoon</span>, J. W., <span
class="smallcaps">Karabin</span>, M. E., <span
class="smallcaps">Brem</span>, J. C. and <span
class="smallcaps">Dick</span>, R. E. Linear transfomation-based
anisotropic yield functions. <em>International Journal of
Plasticity</em>. 1 May 2005. Vol. 21, no. 5, p. 1009–1039. DOI <a
href="https://doi.org/10.1016/j.ijplas.2004.06.004">10.1016/j.ijplas.2004.06.004</a>.
Available from: <a
href="http://www.sciencedirect.com/science/article/pii/S0749641904001160">http://www.sciencedirect.com/science/article/pii/S0749641904001160</a></div>
</div>
<div id="ref-cohen_pade_1991" class="csl-entry" role="listitem">
<div class="csl-left-margin">2. </div><div
class="csl-right-inline"><span class="smallcaps">Cohen</span>, A. A padé
approximant to the inverse langevin function. <em>Rheologica Acta</em>.
1 May 1991. Vol. 30, no. 3, p. 270–273. DOI <a
href="https://doi.org/10.1007/BF00366640">10.1007/BF00366640</a>.
Available from: <a
href="https://doi.org/10.1007/BF00366640">https://doi.org/10.1007/BF00366640</a></div>
</div>
<div id="ref-bergstrom_constitutive_1998" class="csl-entry"
role="listitem">
<div class="csl-left-margin">3. </div><div
class="csl-right-inline"><span class="smallcaps">Bergström</span>, J. S.
and <span class="smallcaps">Boyce</span>, M. C. Constitutive modeling of
the large strain time-dependent behavior of elastomers. <em>Journal of
the Mechanics and Physics of Solids</em>. 1 May 1998. Vol. 46, no. 5,
p. 931–954. DOI <a
href="https://doi.org/10.1016/S0022-5096(97)00075-6">10.1016/S0022-5096(97)00075-6</a>.
Available from: <a
href="https://www.sciencedirect.com/science/article/pii/S0022509697000756">https://www.sciencedirect.com/science/article/pii/S0022509697000756</a></div>
</div>
<div id="ref-jedynak_approximation_2015" class="csl-entry"
role="listitem">
<div class="csl-left-margin">4. </div><div
class="csl-right-inline"><span class="smallcaps">Jedynak</span>,
Radosław. Approximation of the inverse langevin function revisited.
<em>Rheologica Acta</em>. 1 January 2015. Vol. 54, no. 1, p. 29–39.
DOI <a
href="https://doi.org/10.1007/s00397-014-0802-2">10.1007/s00397-014-0802-2</a>.
Available from: <a
href="https://doi.org/10.1007/s00397-014-0802-2">https://doi.org/10.1007/s00397-014-0802-2</a></div>
</div>
<div id="ref-torquato_2002" class="csl-entry" role="listitem">
<div class="csl-left-margin">5. </div><div
class="csl-right-inline"><span class="smallcaps">Torquato</span>,
Salvatore. <a href="https://doi.org/10.1007/978-1-4757-6355-3">Random
heterogeneous materials. Microstructure and macroscopic properties</a>.
Springer, 2002. </div>
</div>
<div id="ref-eshelby_1957" class="csl-entry" role="listitem">
<div class="csl-left-margin">6. </div><div
class="csl-right-inline"><span class="smallcaps">Eshelby</span>, John
Douglas. The determination of the elastic field of an ellipsoidal
inclusion, and related problems. <em>Proceedings of the Royal Society
A</em>. 1957. Vol. 241, no. 1226. DOI <a
href="https://doi.org/10.1098/rspa.1957.0133">10.1098/rspa.1957.0133</a>.
</div>
</div>
</div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-62273823-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
