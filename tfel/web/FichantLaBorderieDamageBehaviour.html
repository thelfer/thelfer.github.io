<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-EN" xml:lang="en-EN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>How to implement the Fichant-La Borderie damage behaviour</title>
        <meta name="author" content="Thomas Helfer, Alexandre Gagnant" />
            <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
    <style type="text/css">code{white-space: pre;}</style>
            <style type="text/css">
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f8f8f8; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ef2929; } /* Alert */
      code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #204a87; } /* Attribute */
      code span.bn { color: #0000cf; } /* BaseN */
      code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4e9a06; } /* Char */
      code span.cn { color: #8f5902; } /* Constant */
      code span.co { color: #8f5902; font-style: italic; } /* Comment */
      code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
      code span.dt { color: #204a87; } /* DataType */
      code span.dv { color: #0000cf; } /* DecVal */
      code span.er { color: #a40000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #0000cf; } /* Float */
      code span.fu { color: #204a87; font-weight: bold; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
      code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
      code span.ot { color: #8f5902; } /* Other */
      code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
      code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
      code span.ss { color: #4e9a06; } /* SpecialString */
      code span.st { color: #4e9a06; } /* String */
      code span.va { color: #000000; } /* Variable */
      code span.vs { color: #4e9a06; } /* VerbatimString */
      code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
    </style>
            <link rel="stylesheet" href="css/normalize.css"/>
    <link rel="stylesheet" href="css/main.css"/>
        <script
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
        type="text/javascript"></script>
          </head>
  <body>
    <!--[if lt IE 7]>
        <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]-->
        <header>
      <ul id="nav">
	<li><a href="news.html">News</a></li>
	<li><a href="index.html">Overview</a>
	  <ul>
	    <li><a>Domain specific languages</a>
	      <ul>
		<li><a href="material-properties.html">Material properties</a></li>
		<li><a href="behaviours.html">Mechanical behaviours</a></li>
		<li><a href="models.html">Models</a></li>
	      </ul>
            </li>
	    <li><a href="interfaces.html">Available interfaces</a></li>
	    <li><a href="associated-projects.html">Associated projects</a></li>
	  </ul>
	</li>
	<li><a>Getting started</a>
	  <ul>
	    <li><a href="https://github.com/thelfer/tfel/">Github repository</a></li>
	    <li><a href="https://github.com/thelfer/tfel/releases">Download</a></li>
	    <li><a href="release-notes.html">Release notes</a>
	      <ul>
		<li><a>Versions 2.0.x</a>
                  <ul>
                    <li><a href="release-notes.html">Versions prior to 2.0.5</a></li>
	 	    <li><a href="release-notes-2.0.5.html">Version 2.0.5</a></li>
                  </ul>
		</li>
		<li><a>Versions 3.0.x</a>
                  <ul>
		    <li><a href="release-notes-3.0.html">Version 3.0.0</a></li>
		    <li><a href="release-notes-3.0.1.html">Version 3.0.1</a></li>
		    <li><a href="release-notes-3.0.2.html">Version 3.0.2</a></li>
		    <li><a href="release-notes-3.0.3.html">Version 3.0.3</a></li>
		    <li><a href="release-notes-3.0.4.html">Version 3.0.4</a></li>
		    <li><a href="release-notes-3.0.5.html">Version 3.0.5</a></li>
		    <li><a href="release-notes-3.0.6.html">Version 3.0.6</a></li>
		    <li><a href="release-notes-3.0.7.html">Version 3.0.7</a></li>
		    <li><a href="release-notes-3.0.8.html">Version 3.0.8</a></li>
		    <li><a href="release-notes-3.0.9.html">Version 3.0.9</a></li>
		    <li><a href="release-notes-3.0.10.html">Version 3.0.10</a></li>
		    <li><a href="release-notes-3.0.11.html">Version 3.0.11</a></li>
		    <li><a href="release-notes-3.0.12.html">Version 3.0.12</a></li>
		    <li><a href="release-notes-3.0.13.html">Version 3.0.13</a></li>
		    <li><a href="release-notes-3.0.14.html">Version 3.0.14</a></li>
		    <li><a href="release-notes-3.0.15.html">Version 3.0.15</a></li>
		    <li><a href="release-notes-3.0.16.html">Version 3.0.16</a></li>
		    <li><a href="release-notes-3.0.17.html">Version 3.0.17</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.1.x</a>
		  <ul>
		    <li><a href="release-notes-3.1.html">Version 3.1.0</a></li>
		    <li><a href="release-notes-3.1.1.html">Version 3.1.1</a></li>
		    <li><a href="release-notes-3.1.2.html">Version 3.1.2</a></li>
		    <li><a href="release-notes-3.1.3.html">Version 3.1.3</a></li>
		    <li><a href="release-notes-3.1.4.html">Version 3.1.4</a></li>
		    <li><a href="release-notes-3.1.5.html">Version 3.1.5</a></li>
		    <li><a href="release-notes-3.1.6.html">Version 3.1.6</a></li>
		    <li><a href="release-notes-3.1.7.html">Version 3.1.7</a></li>
		    <li><a href="release-notes-3.1.8.html">Version 3.1.8</a></li>
		    <li><a href="release-notes-3.1.9.html">Version 3.1.9</a></li>
		    <li><a href="release-notes-3.1.10.html">Version 3.1.10</a></li>
		    <li><a href="release-notes-3.1.11.html">Version 3.1.11</a></li>
		    <li><a href="release-notes-3.1.12.html">Version 3.1.12</a></li>
		    <li><a href="release-notes-3.1.13.html">Version 3.1.13</a></li>
		    <li><a href="release-notes-3.1.14.html">Version 3.1.14</a></li>
		    <li><a href="release-notes-3.1.15.html">Version 3.1.15</a></li>
		    <li><a href="release-notes-3.1.16.html">Version 3.1.16</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.2.x</a>
		  <ul>
		    <li><a href="release-notes-3.2.html">Version 3.2.0</a></li>
		    <li><a href="release-notes-3.2.1.html">Version 3.2.1</a></li>
		    <li><a href="release-notes-3.2.2.html">Version 3.2.2</a></li>
		    <li><a href="release-notes-3.2.3.html">Version 3.2.3</a></li>
		    <li><a href="release-notes-3.2.4.html">Version 3.2.4</a></li>
		    <li><a href="release-notes-3.2.5.html">Version 3.2.5</a></li>
		    <li><a href="release-notes-3.2.6.html">Version 3.2.6</a></li>
		    <li><a href="release-notes-3.2.7.html">Version 3.2.7</a></li>
		    <li><a href="release-notes-3.2.8.html">Version 3.2.8</a></li>
		    <li><a href="release-notes-3.2.9.html">Version 3.2.9</a></li>
		    <li><a href="release-notes-3.2.10.html">Version 3.2.10</a></li>
		    <li><a href="release-notes-3.2.11.html">Version 3.2.11</a></li>
		    <li><a href="release-notes-3.2.12.html">Version 3.2.12</a></li>
		    <li><a href="release-notes-3.2.13.html">Version 3.2.13</a></li>
		    <li><a href="release-notes-3.2.14.html">Version 3.2.14</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.3.x</a>
		  <ul>
		    <li><a href="release-notes-3.3.html">Version 3.3.0</a></li>
		    <li><a href="release-notes-3.3.1.html">Version 3.3.1</a></li>
		    <li><a href="release-notes-3.3.1.html">Version 3.3.2</a></li>
		    <li><a href="release-notes-3.3.2.html">Version 3.3.2</a></li>
		    <li><a href="release-notes-3.3.3.html">Version 3.3.3</a></li>
		    <li><a href="release-notes-3.3.4.html">Version 3.3.4</a></li>
		    <li><a href="release-notes-3.3.5.html">Version 3.3.5</a></li>
		    <li><a href="release-notes-3.3.6.html">Version 3.3.6</a></li>
		    <li><a href="release-notes-3.3.7.html">Version 3.3.7</a></li>
		    <li><a href="release-notes-3.3.7.html">Version 3.3.8</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.4.x</a>
		  <ul>
		    <li><a href="release-notes-3.4.html">Version 3.4.0</a></li>
		    <li><a href="release-notes-3.4.1.html">Version 3.4.1</a></li>
		    <li><a href="release-notes-3.4.2.html">Version 3.4.2</a></li>
		    <li><a href="release-notes-3.4.3.html">Version 3.4.3</a></li>
		    <li><a href="release-notes-3.4.4.html">Version 3.4.4</a></li>
		    <li><a href="release-notes-3.4.5.html">Version 3.4.5</a></li>
		    <li><a href="release-notes-3.4.6.html">Version 3.4.6</a></li>
		    <li><a href="release-notes-3.4.7.html">Version 3.4.7</a></li>
		    <li><a href="release-notes-3.4.8.html">Version 3.4.8</a></li>
		    <li><a href="release-notes-3.4.9.html">Version 3.4.9</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.0.x</a>
		  <ul>
		    <li><a href="release-notes-4.0.html">Version 4.0.0</a></li>
		    <li><a href="release-notes-4.0.1.html">Version 4.0.1</a></li>
		    <li><a href="release-notes-4.0.2.html">Version 4.0.2</a></li>
		    <li><a href="release-notes-4.0.3.html">Version 4.0.3</a></li>
		    <li><a href="release-notes-4.0.4.html">Version 4.0.4</a></li>
		    <li><a href="release-notes-4.0.5.html">Version 4.0.5</a></li>
		    <li><a href="release-notes-4.0.6.html">Version 4.0.6</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.1.x</a>
		  <ul>
		    <li><a href="release-notes-4.1.html">Version 4.1.0</a></li>
		    <li><a href="release-notes-4.1.1.html">Version 4.1.1</a></li>
		    <li><a href="release-notes-4.1.2.html">Version 4.1.2</a></li>
		    <li><a href="release-notes-4.1.3.html">Version 4.1.3</a></li>
		    <li><a href="release-notes-4.1.4.html">Version 4.1.4</a></li>
		    <li><a href="release-notes-4.1.5.html">Version 4.1.5</a></li>
		    <li><a href="release-notes-4.1.6.html">Version 4.1.6</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.2.x</a>
		  <ul>
		    <li><a href="release-notes-4.2.html">Version 4.2.0</a></li>
		    <li><a href="release-notes-4.2.1.html">Version 4.2.1</a></li>
		    <li><a href="release-notes-4.2.2.html">Version 4.2.2</a></li>
		    <li><a href="release-notes-4.2.3.html">Version 4.2.3</a></li>
		    <li><a href="release-notes-4.2.4.html">Version 4.2.4</a></li>
		    <li><a href="release-notes-4.2.5.html">Version 4.2.5</a></li>
		    <li><a href="release-notes-4.2.6.html">Version 4.2.6</a></li>
		  </ul>
		</li>
		<li><a>Versions 5.0.x</a>
		  <ul>
		    <li><a href="release-notes-5.0.html">Version 5.0.0</a></li>
		    <li><a href="release-notes-5.0.1.html">Version 5.0.1</a></li>
		    <li><a href="release-notes-5.0.2.html">Version 5.0.2</a></li>
		    <li><a href="release-notes-5.0.3.html">Version 5.0.3</a></li>
		  </ul>
		</li>
		<li><a>Versions 5.1.x</a>
		  <ul>
		    <li><a href="release-notes-5.1.html">Version 5.1.0</a></li>
		  </ul>
		</li>
		<li><a>Versions 5.2.x</a>
		  <ul>
		    <li><a href="release-notes-5.1.html">Version 5.2.0</a></li>
		  </ul>
		</li>
	      </ul>
	    </li>
	    <li><a href="coverity-scan.html">Coverity scan</a></li>
	    <li><a href="install.html">Installation</a></li>
	  </ul>
	</li>
	<li><a>Documentation</a>
	  <ul>
	    <li><a href="documentations.html">General documentation</a></li>
	    <li><a href="gallery.html">Gallery</a></li>
<!--	    
	    <li><a href="http://tfel.sourceforge.net/doxygen/index.html">Doxygen documentation</a></li>
-->
	    <li><a>MFront</a>
	      <ul>
		<li><a href="tutorial.html">Tutorial</a></li>
		<li><a href="implicit-dsl.html">The Implicit DSL</a></li>
		<li><a href="benchmark.html">Benchmark</a></li>
		<li><a href="parameters.html">Parameters</a></li>
		<li><a href="BehaviourBricks.html">Behaviour bricks</a></li>
                 <li><a href="behaviour-variable.html">behaviour variables</a></li>
		<li><a href="interfaces.html">Solver interfaces</a>
		  <ul>
		    <li><a href="castem.html">Cast3M</a></li>
		    <li><a href="amitex.html">AMITEX_FFTP</a></li>
		    <li><a href="aster.html">Code-Aster</a></li>
    		    <li><a href="abaqus.html">Abaqus</a></li>
		    <li><a href="zmat.html">ZeBuLoN</a></li>
   		    <li><a href="calculix.html">CalculiX</a></li>
		    <!-- <li><a >TMFFT</a></li> -->
		    <li><a href="cyrano.html">Cyrano</a></li>
   		    <li><a href="generic-material-property-interface.html">Generic interface for material properties</a></li>
   		    <li><a href="generic-behaviours-interface.html">Generic interface for behaviours</a></li>
		  </ul>
		</li>
                 <li><a>MFront keywords</a>
    	              <ul>
    	        <li><a href="Default-keywords.html">Default</a></li>
    	        <li><a href="DefaultCZM-keywords.html">DefaultCZM</a></li>
    	        <li><a href="DefaultFiniteStrain-keywords.html">DefaultFiniteStrain</a></li>
    	        <li><a href="DefaultGenericBehaviour-keywords.html">DefaultGenericBehaviour</a></li>
    	        <li><a href="DefaultModel-keywords.html">DefaultModel</a></li>
    	        <li><a href="Implicit-keywords.html">Implicit</a></li>
    	        <li><a href="ImplicitCZM-keywords.html">ImplicitCZM</a></li>
    	        <li><a href="ImplicitFiniteStrain-keywords.html">ImplicitFiniteStrain</a></li>
    	        <li><a href="ImplicitGenericBehaviour-keywords.html">ImplicitGenericBehaviour</a></li>
    	        <li><a href="ImplicitModel-keywords.html">ImplicitModel</a></li>
    	        <li><a href="ImplicitII-keywords.html">ImplicitII</a></li>
    	        <li><a href="IsotropicMisesCreep-keywords.html">IsotropicMisesCreep</a></li>
    	        <li><a href="IsotropicMisesPlasticFlow-keywords.html">IsotropicMisesPlasticFlow</a></li>
    	        <li><a href="IsotropicPlasticMisesFlow-keywords.html">IsotropicPlasticMisesFlow</a></li>
    	        <li><a href="IsotropicStrainHardeningMisesCreep-keywords.html">IsotropicStrainHardeningMisesCreep</a></li>
    	        <li><a href="MaterialLaw-keywords.html">MaterialLaw</a></li>
    	        <li><a href="MaterialProperty-keywords.html">MaterialProperty</a></li>
    	        <li><a href="Model-keywords.html">Model</a></li>
    	        <li><a href="MultipleIsotropicMisesFlows-keywords.html">MultipleIsotropicMisesFlows</a></li>
    	        <li><a href="RungeKutta-keywords.html">RungeKutta</a></li>
    	        <li><a href="RungeKuttaFiniteStrain-keywords.html">RungeKuttaFiniteStrain</a></li>
    	        <li><a href="RungeKuttaGenericBehaviour-keywords.html">RungeKuttaGenericBehaviour</a></li>
    	        <li><a href="RungeKuttaModel-keywords.html">RungeKuttaModel</a></li>
    	      </ul>
                </li>
	      </ul>
	    </li>
	    <li><a href="mtest.html">MTest</a>
               <ul>
	      <li><a href="mtest-nonlinear-constraints.html">Nonlinear constraints</a></li>
              <li><a href="MTest-keywords.html">MTest keywords</a></li>
	      </ul>
            </li>
     	    <li><a>Tools</a>
	      <ul>
	        <li><a href="mfront-doc.html">mfront-doc</a></li>
	        <li><a href="mfm.html">mfm</a></li>
	        <li><a href="mfm-test-generator.html">mfm-test-generator</a></li>
	        <li><a href="tfel-check.html">tfel-check</a></li>
	      </ul>
	    </li>
	    <li><a>TFEL libraries</a>
	      <ul>
		<li><a href="libraries_usage.html">Usage of the TFEL libraries in C++</a></li>
		<li><a href="tfel-math.html">TFEL/Math</a></li>
                 <ul>
		  <li><a href="tfel-math-numerical-integration.html">Numerical integeration</a></li>
		  <li><a href="tfel-math-data-interpolation.html">Data interpolation</a></li>
	        </ul>
		<li><a href="tfel-material.html">TFEL/Material</a></li>
                 <li><a href="glossary.html">Glossary</a></li>
                 <li><a href="physical-constants.html">Physical constants</a></li>
		<li><a href="tfel-mfront-database.html">TFELMFrontDatabase</a></li>
	      </ul>
	    </li>
	    <li><a>Python modules</a>
	      <ul>
		<li><a href="tfel-python.html">TFEL modules</a></li>
		<li><a href="mfront-python.html">mfront module</a></li>
		<li><a href="mtest-python.html">mtest module</a></li>
	      </ul>
	    </li>
	    <li><a href="publications.html">Publications</a></li>
	    <li><a href="faq.html">FAQ</a></li>
	    <li><a href="about.html">About</a></li>
	  </ul>
	</li>
	<li><a>Contributing</a>
	  <ul>
	    <li><a href="https://github.com/thelfer/tfel">Access to sources</a></li>
	    <li><a href="contributing.html">Contributing guidelines</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Report bugs</a></li>
	  </ul>
	</li>
	<li><a>Getting Help</a>
	  <ul>
	    <li><a href="search.html">Search on this site</a></li>
	    <li><a href="https://github.com/thelfer/tfel/discussions">Forum</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Bug report</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Feature request</a></li>
	    <li><a href="mailto:tfel-contact@cea.fr">Contact</a></li>
	  </ul>
	</li>
      </ul>
    </header>
<div id="header">
<h1 class="title">How to implement the Fichant-La Borderie damage
behaviour</h1>
<h2 class="author">Thomas Helfer, Alexandre Gagnant</h2>
<h3 class="date">12/2019</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#description-of-the-fichant-la-borderie-damage-law"
id="toc-description-of-the-fichant-la-borderie-damage-law">Description
of the Fichant-La Borderie damage law</a>
<ul>
<li><a href="#equivalent-strain" id="toc-equivalent-strain">Equivalent
strain</a></li>
<li><a href="#damage-evolution" id="toc-damage-evolution">Damage
evolution</a></li>
<li><a href="#computation-of-the-stress"
id="toc-computation-of-the-stress">Computation of the stress</a></li>
</ul></li>
<li><a href="#implementation" id="toc-implementation">Implementation</a>
<ul>
<li><a href="#choice-of-the-domain-specific-language"
id="toc-choice-of-the-domain-specific-language">Choice of the domain
specific language</a></li>
<li><a href="#name-of-the-behaviour" id="toc-name-of-the-behaviour">Name
of the behaviour</a></li>
<li><a href="#metadata" id="toc-metadata">Metadata</a></li>
<li><a href="#material-properties" id="toc-material-properties">Material
properties</a></li>
<li><a href="#state-variable" id="toc-state-variable">State
variable</a></li>
<li><a href="#local-variables" id="toc-local-variables">Local
variables</a></li>
<li><a href="#initialization-of-the-local-variables"
id="toc-initialization-of-the-local-variables">Initialization of the
local variables</a></li>
<li><a href="#prediction-operator"
id="toc-prediction-operator">Prediction operator</a></li>
<li><a href="#behaviour-integration"
id="toc-behaviour-integration">Behaviour integration</a></li>
</ul></li>
<li><a href="#references" id="toc-references">References</a></li>
</ul>
</div>
<!--
pandoc -f markdown-markdown_in_html_blocks+tex_math_single_backslash+grid_tables --filter pandoc-crossref  --mathjax --email-obfuscation=javascript --default-image-extension=svg FLB.md -o FLB.pdf
-->
<p>This document describes how to implement the Fichant-La Borderie
damage behaviour. See <span class="citation"
data-cites="fichant_endommagement_1996 gangnant_etude_2016">[<a
href="#ref-fichant_endommagement_1996" role="doc-biblioref">1</a>, <a
href="#ref-gangnant_etude_2016" role="doc-biblioref">2</a>]</span> for a
detailed description.</p>
<p>The Fichant-La Borderie (FLB) model is an extension of the Mazars
model, which:</p>
<ul>
<li>simplifies the number of input parameters defining the tensile and
compressive asymmetry.</li>
<li>handles unilateral effects (i.e., crack closure).</li>
<li>features an energy based regularisation method, thus allowing a
fracture finite energy in a finite element implementation</li>
</ul>
<figure>
<img src="./img/FichantLaBorderieDamageBehaviourUniaxialTensileTest.png"
alt="The Fichant La Borderie damage behaviour under uniaxial tension and compression" />
<figcaption aria-hidden="true">The Fichant La Borderie damage behaviour
under uniaxial tension and compression</figcaption>
</figure>
<p>The implementation is available <a
href="gallery/damage/FichantLaBorderieDamageBehaviour.mfront">here</a></p>
<h1 id="description-of-the-fichant-la-borderie-damage-law">Description
of the Fichant-La Borderie damage law</h1>
<h2 id="equivalent-strain">Equivalent strain</h2>
<p>The equivalent strain <span
class="math inline">\(\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\)</span>
is defined as:</p>
<p><span class="math display">\[
\varepsilon^{\mathrm{to}}_{\mathrm{eq}}=\sqrt{{\left&lt;\underline{\varepsilon}^{\mathrm{to}}\right&gt;_{+}}\,\colon\,{\left&lt;\underline{\varepsilon}^{\mathrm{to}}\right&gt;_{+}}}=
\sqrt{\sum_{I=1}^{3}{\left&lt;\varepsilon^{\mathrm{to}}_{I}\right&gt;_{+}}^2}
\]</span></p>
<p>where <span
class="math inline">\({\left&lt;\underline{\varepsilon}^{\mathrm{to}}\right&gt;_{+}}\)</span>
is the positive part of the total strain and <span
class="math inline">\(\left(\varepsilon^{\mathrm{to}}_{I}\right)_{i \in
[1:3]}\)</span> are its eigenvalues.</p>
<blockquote>
<p><strong>Derivative of the equivalent strain</strong></p>
<p>The following expression of the derivative of the equivalent strain
with respect to the total strain will be useful:</p>
<p><span id="eq:deeq"><span class="math display">\[
{\displaystyle \frac{\displaystyle \mathrm{d}
\varepsilon^{\mathrm{to}}_{\mathrm{eq}}}{\displaystyle \mathrm{d}
\underline{\varepsilon}^{\mathrm{to}}}}={{\displaystyle
\frac{\displaystyle 1}{\displaystyle
\varepsilon^{\mathrm{to}}_{\mathrm{eq}}}}}\,{\left&lt;\underline{\varepsilon}^{\mathrm{to}}\right&gt;_{+}}\,\colon\,{\displaystyle
\frac{\displaystyle \mathrm{d}
{\left&lt;\underline{\varepsilon}^{\mathrm{to}}\right&gt;_{+}}}{\displaystyle
\mathrm{d} \underline{\varepsilon}^{\mathrm{to}}}}
\qquad{(1)}\]</span></span></p>
</blockquote>
<h2 id="damage-evolution">Damage evolution</h2>
<p>The damage evolution is a function of the equivalent strain <span
class="math inline">\(\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\)</span>:</p>
<ul>
<li>Under a given threshold <span
class="math inline">\(\epsilon_{0}\)</span>, no damage occurs.</li>
<li>Once this threshold is reached, the damage <span
class="math inline">\(d\)</span> is defined as follows: <span
id="eq:d"><span class="math display">\[
d=1-{{\displaystyle \frac{\displaystyle \epsilon_{0}}{\displaystyle
\varepsilon^{\mathrm{to}}_{\mathrm{eq}}}}}\,\exp{\left(B_{t}\,{\left(\epsilon_{0}-\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right)}\right)}
\qquad{(2)}\]</span></span></li>
</ul>
<p>However, the latter expression must be modified to take into account
the irreversibility of the damage evolution. Let <span
class="math inline">\({\left.d\right|_{t}}\)</span> be the value of the
damage at the beginning of the time step and <span
class="math inline">\({\left.d\right|_{t+\Delta\,t}}\)</span> its value
at the end of the time step, <span
class="math inline">\({\left.d\right|_{t+\Delta\,t}}\)</span> is
determined as follows:</p>
<p><span class="math display">\[
{\left.d\right|_{t+\Delta\,t}}=\max{\left({\left.d\right|_{t}},1-{{\displaystyle
\frac{\displaystyle \epsilon_{0}}{\displaystyle
{\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}}}}\,\exp{\left(B_{t}\,{\left(\epsilon_{0}-{\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}\right)}\right)}\right)}
\]</span></p>
<p>where <span
class="math inline">\({\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}\)</span>
is the value of the equivalent strain at the end of the time step.</p>
<blockquote>
<p><strong>Hillerborg regularisation (see <span class="citation"
data-cites="hillerborg_analysis_1976">[<a
href="#ref-hillerborg_analysis_1976"
role="doc-biblioref">3</a>]</span>)</strong></p>
<p>Local damage models suffers from spurious mesh dependency. In
particular, the dissipated energy tends to <span
class="math inline">\(0\)</span> as the mesh size decreases.</p>
<p>The Hillerborg regularisation consists in introducing the mesh size
in the material parameter to get a constant dissipated energy.</p>
<p>In the FLB case, <span class="math inline">\(B_{t}\)</span> can be
deduced from the fracture energy <span
class="math inline">\(G_{f}\)</span> and the mesh size <span
class="math inline">\(h\)</span> as follows:</p>
<p><span class="math display">\[
B_{t} ={{\displaystyle \frac{\displaystyle
h\,E\,\epsilon_{0}}{\displaystyle G_{f} −{{\displaystyle
\frac{\displaystyle 1}{\displaystyle 2}}}\,E\,\epsilon_{0}^{2}\,h}}}
\]</span></p>
<p>where <span class="math inline">\(E\)</span> is the Young modulus</p>
<p>Note that <span class="math inline">\(B_{t}\)</span> must be
positive, which, for a given fracture energy <span
class="math inline">\(G_{f}\)</span>, imposes a maximal value for the
mesh size <span class="math inline">\(h\)</span>.</p>
<p><span class="math display">\[
h &lt; {{\displaystyle \frac{\displaystyle 2\,G_{f}}{\displaystyle
E\,\epsilon_{0}^{2}}}}
\]</span></p>
<p>A condition which states that the elastic energy stored inside an
element at the onset of damage must be less than dissipated energy by
damage.</p>
</blockquote>
<blockquote>
<p><strong>Derivatives of the damage</strong></p>
<p>In case of a growing damage, the derivative of the damage with
respect to the equivalent plastic strain is:</p>
<p><span id="eq:dd"><span class="math display">\[
{\displaystyle \frac{\displaystyle \mathrm{d}
{\left.d\right|_{t+\Delta\,t}}}{\displaystyle \mathrm{d}
{\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}}}={{\displaystyle
\frac{\displaystyle \epsilon_{0}}{\displaystyle
{\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}}}}\exp{\left(B_{t}\,{\left(\epsilon_{0}-{\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}\right)}\right)}\left(B_{t}+{{\displaystyle
\frac{\displaystyle 1}{\displaystyle
{\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}}}}\right)
\qquad{(3)}\]</span></span></p>
<p>Combined with Equation (1), Equation (3) allows computing the
derivative of the damage with respect to the total strain.</p>
</blockquote>
<h2 id="computation-of-the-stress">Computation of the stress</h2>
<p>The effective stress tensor <span
class="math inline">\(\underline{\sigma}^{\mathrm{eff}}\)</span> is
computed using the standard Hooke law: <span class="math display">\[
{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}={\left.\underline{\underline{\mathbf{D}}}\right|_{t+\Delta\,t}}\,\colon\,{\left.\underline{\varepsilon}^{\mathrm{to}}\right|_{t+\Delta\,t}}
\]</span></p>
<p>The behaviour is assumed isotropic, so that the stiffness tensor
<span
class="math inline">\({\left.\underline{\underline{\mathbf{D}}}\right|_{t+\Delta\,t}}\)</span>
can be related to the first and second Lamé coefficients, denoted
respectively <span class="math inline">\(\lambda\)</span> and <span
class="math inline">\(\mu\)</span>, as follows:</p>
<p><span class="math display">\[
{\left.\underline{\underline{\mathbf{D}}}\right|_{t+\Delta\,t}}={\left.\lambda\right|_{t+\Delta\,t}}\,\underline{I}\,\otimes\,\underline{I}+2\,{\left.\mu\right|_{t+\Delta\,t}}\,\underline{\underline{\mathbf{I}}}
\]</span></p>
<blockquote>
<p><strong>Note</strong></p>
<p>The restriction to isotropy has an important pratical consequence:
<span class="math inline">\(\underline{\sigma}^{\mathrm{eff}}\)</span>
and <span
class="math inline">\(\underline{\varepsilon}^{\mathrm{to}}\)</span>
have the same egein basis.</p>
</blockquote>
<p>The stress tensor <span
class="math inline">\(\underline{\sigma}\)</span> is then computed as
follows: <span class="math display">\[
{\left.\underline{\sigma}\right|_{t+\Delta\,t}}={\left(1-{\left.d\right|_{t+\Delta\,t}}\right)}\,{\left&lt;{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}\right&gt;_{+}}+{\left(1-{\left.d\right|_{t+\Delta\,t}}^{a}\right)}\,{\left&lt;{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}\right&gt;_{-}}
\]</span></p>
<blockquote>
<p><strong>Derivative of the stress with respect to the total
strain</strong></p>
<p>In case of damage growth, the derivative of the stress with respect
to the total strain is given by: <span id="eq:Dt"><span
class="math display">\[
\begin{aligned}
{\displaystyle \frac{\displaystyle \mathrm{d}
{\left.\underline{\sigma}\right|_{t+\Delta\,t}}}{\displaystyle
\mathrm{d}
{\left.\underline{\varepsilon}^{\mathrm{to}}\right|_{t+\Delta\,t}}}}&amp;=
\left[{\left(1-{\left.d\right|_{t+\Delta\,t}}\right)}\,    {\displaystyle
\frac{\displaystyle \mathrm{d}
{\left&lt;{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}\right&gt;_{+}}}{\displaystyle
\mathrm{d}
{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}}}+
      {\left(1-{\left.d\right|_{t+\Delta\,t}}^{a}\right)}\,{\displaystyle
\frac{\displaystyle \mathrm{d}
{\left&lt;{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}\right&gt;_{-}}}{\displaystyle
\mathrm{d}
{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}}}\right]\,\colon\,{\left.\underline{\underline{\mathbf{D}}}\right|_{t+\Delta\,t}}\\
&amp;-
{\left&lt;{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}\right&gt;_{+}}\,\otimes\,{\displaystyle
\frac{\displaystyle \mathrm{d}
{\left.d\right|_{t+\Delta\,t}}}{\displaystyle \mathrm{d}
{\left.\underline{\varepsilon}^{\mathrm{to}}\right|_{t+\Delta\,t}}}}
-
a\,{\left.d\right|_{t+\Delta\,t}}^{a-1}\,{\left&lt;{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}\right&gt;_{-}}\,\otimes\,{\displaystyle
\frac{\displaystyle \mathrm{d}
{\left.d\right|_{t+\Delta\,t}}}{\displaystyle \mathrm{d}
{\left.\underline{\varepsilon}^{\mathrm{to}}\right|_{t+\Delta\,t}}}}
\end{aligned}
\qquad{(4)}\]</span></span></p>
<p>This expression gives the so-called consistent tangent operator.</p>
</blockquote>
<h1 id="implementation">Implementation</h1>
<h2 id="choice-of-the-domain-specific-language">Choice of the domain
specific language</h2>
<p>The Fichant-La Borderie damage behaviour does not require any
specific integration scheme as the damage evolution is an explicit
function of the total strain. The <code>Default</code> domain specific
language is suitable for treating that kind of behaviours.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>DSL Default<span class="op">;</span></span></code></pre></div>
<h2 id="name-of-the-behaviour">Name of the behaviour</h2>
<p>The <code>@Behaviour</code> keyword defines the name of the
behaviour:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Behaviour FichantLaBorderieDamageBehaviour<span class="op">;</span></span></code></pre></div>
<h2 id="metadata">Metadata</h2>
<p>The implementation starts by defining somme metadata associated with
the behaviour:</p>
<ul>
<li>the date.</li>
<li>the names of the authors.</li>
<li>a short description.</li>
</ul>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Date <span class="dv">7</span><span class="op">/</span><span class="dv">12</span><span class="op">/</span><span class="dv">2019</span><span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Author A<span class="op">.</span> Gangnant<span class="op">,</span> T<span class="op">.</span> Helfer<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Description<span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Implementation of the Fichant-La Borderie damage behaviour&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="material-properties">Material properties</h2>
<h3 id="elastic-material-properties">Elastic material properties</h3>
<p>Most solvers uses the Young modulus and the Poisson ratio to
characterize the elasticity of an isotropic material. Here we adopt this
convention by defining them as two material properties named
<code>young</code> and <code>nu</code> and associate those variables
with the appropriate glossary names:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>MaterialProperty stress young<span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>young<span class="op">.</span>setGlossaryName<span class="op">(</span><span class="st">&quot;YoungModulus&quot;</span><span class="op">);</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>MaterialProperty real nu<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>nu<span class="op">.</span>setGlossaryName<span class="op">(</span><span class="st">&quot;PoissonRatio&quot;</span><span class="op">);</span></span></code></pre></div>
<blockquote>
<p><strong>About glossary names</strong></p>
<p>Associating a glossary name is a way to define the so-called external
name of this variable, i.e. the name that will appear on the calling
solver side. It also allows <code>MFront</code> to make assumptions
about the real meaning of those variables.</p>
<p>The case of the <code>Cast3M</code> solver is a noteworthy example.
This solver requires <span class="math inline">\(4\)</span> elastic
properties to be defined for its own use in the case of an isotropic
material properties: the Young modulus, the Poisson ratio, the density
and the thermal expansion coefficient. Normally, the <code>MFront</code>
material properties are appended to those four properties. However, by
associating the <code>YoungModulus</code> and the
<code>PoissonRatio</code> glossary names to the <code>young</code> and
<code>nu</code> material properties respectively, <code>MFront</code>
will identify them with the ones required by <code>Cast3M</code>.</p>
<p>For details about the glossary names, the reader may refer to the <a
href="glossary.html">following page</a>.</p>
</blockquote>
<h3 id="material-properties-associated-with-damage">Material properties
associated with damage</h3>
<p>The damage evolution given by Equation (2) requires three material
properties <span class="math inline">\(Bt\)</span>, <span
class="math inline">\(e_{0}\)</span> and <span
class="math inline">\(a\)</span>.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>MaterialProperty real Bt<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>MaterialProperty strain e0<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>MaterialProperty real a<span class="op">;</span></span></code></pre></div>
<h2 id="state-variable">State variable</h2>
<p>The only state variable of this behaviour is the damage variable
<span class="math inline">\(d\)</span> which we declare as follows:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>StateVariable real d<span class="op">;</span></span></code></pre></div>
<p>For post-processing purposes, we associate this variable with the
<code>Damage</code> glossary name.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>d<span class="op">.</span>setGlossaryName<span class="op">(</span><span class="st">&quot;Damage&quot;</span><span class="op">);</span></span></code></pre></div>
<h2 id="local-variables">Local variables</h2>
<p>In <code>MFront</code>, a local variable are variables in each code
blocks. They are usually evaluated once for all in the
<code>@InitLocalVariables</code> code block which is called before the
behaviour integration (as defined by the <code>@Integrator</code> code
block) or before the computation of the prediction operator (as defined
in the <code>@PredictionOperator</code> code block).</p>
<p>In the following, we will use two local variables <code>lambda</code>
and <code>mu</code> associated respectively with the first and second
Lamé coefficients.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>LocalVariable stress lambda<span class="op">,</span> mu<span class="op">;</span></span></code></pre></div>
<h2 id="initialization-of-the-local-variables">Initialization of the
local variables</h2>
<p>The initialization of the local variables is performed in the
<code>@InitLocalVariables</code> code block, as follows:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>InitLocalVariables <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  lambda <span class="op">=</span> computeLambda<span class="op">(</span>young<span class="op">,</span> nu<span class="op">);</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  mu <span class="op">=</span> computeMu<span class="op">(</span>young<span class="op">,</span> nu<span class="op">);</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Here, we use two functions provided by the <code>TFEL/Material</code>
library: <code>computeLambda</code> and <code>computeMu</code>.</p>
<h2 id="prediction-operator">Prediction operator</h2>
<p>The prediction operator is used by the <code>Code_Aster</code> finite
element solver at the beginning of each new time step. It is also used
by the <code>Abaqus/Explicit</code> solver to retrieve the elastic
properties at the packaging step.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>PredictionOperator <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;(</span>smt<span class="op">);</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  Dt <span class="op">=</span> lambda <span class="op">*</span> Stensor4<span class="op">::</span>IxI<span class="op">()</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> mu <span class="op">*</span> Stensor4<span class="op">::</span>Id<span class="op">();</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Here, we only provide the elastic prediction operator. Thus, we
discarded the <code>smt</code> variable by casting it to
<code>void</code> to avoid a compiler warning.</p>
<h2 id="behaviour-integration">Behaviour integration</h2>
<p>The behaviour integration is performed in the
<code>@Integrator</code> code block which is meant to:</p>
<ul>
<li>update the damage state variable.</li>
<li>compute the stress at the end of the time step.</li>
<li>compute the consistent tangent operator if required.</li>
</ul>
<blockquote>
<p><strong>Note</strong></p>
<p>The computation of the consistent tangent operator is usually
performed in the <code>@TangentOperator</code> code block. However, in
the case of the Fichant-La Borderie behaviour, this would lead to an
unneccessary complexity as a lot of local variables would have been
required to store the results of complex computations required in both
the <code>@Integrator</code> and the <code>@TangentOperator</code> code
blocks.</p>
<p>To state that the consistent tangent operator is indeed computed in
the <code>@Integrator</code> code block, one shall use the
<code>@ProvidesTangentOperator</code> keyword. Note that this keyword
explicitly states that the consistent tangent operator is <em>not</em>
symmetric. See the <code>@ProvidesSymmetricTangentOperator</code>
keyword to state that the consistent tangent operator is symmetric.</p>
</blockquote>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>ProvidesTangentOperator<span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Integrator<span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// a simple alias for the identity</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="at">const</span> <span class="kw">auto</span> id <span class="op">=</span> Stensor<span class="op">::</span>Id<span class="op">();</span></span></code></pre></div>
<p>At the beginning of this block, we define two constant used in the
following to decide if two eigenvalues are equal:</p>
<ul>
<li>The first constant <code>eeps</code> is used when dealing a tensor
of the strain type.</li>
<li>The second constant <code>seps</code> is used when dealing a tensor
of the stress type.</li>
</ul>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="at">const</span> strain eeps <span class="op">=</span> <span class="fl">1.e-12</span><span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> seps <span class="op">=</span> eeps <span class="op">*</span> young<span class="op">;</span></span></code></pre></div>
<p>Then we define two local functions called <code>pp</code> and
<code>square_pp</code>:</p>
<ul>
<li><code>pp</code> computes the positive part of a scalar.</li>
<li><code>square_pp</code> computes the square of the positive part of a
scalar.</li>
</ul>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// positive part</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> pp <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> real x<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> x <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> x <span class="op">:</span> <span class="dv">0</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// square of the posititve part</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> square_pp <span class="op">=</span> <span class="op">[](</span><span class="at">const</span> strain v<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> v <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> v <span class="op">*</span> v <span class="op">:</span> <span class="dv">0</span><span class="op">;</span> <span class="op">};</span></span></code></pre></div>
<blockquote>
<p><strong>Note</strong></p>
<p>In <code>C++</code>, those local functions are called
<code>lambda</code> functions.</p>
</blockquote>
<p>We now compute the total strain and stores it in a variable called
<code>e</code>:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// total strain</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> e <span class="op">=</span> eval<span class="op">(</span>eto <span class="op">+</span> deto<span class="op">);</span></span></code></pre></div>
<p>where <code>eto</code> and <code>deto</code> are respectively the
total strain at the beginning of the time step and its increment over
the time step.</p>
<p>Tensorial operations in the <code>TFEL/Math</code> library are lazy,
which means that their evaluation is delayed until it is really needed.
This technique is called <code>expression template</code> in
<code>C++</code> and is based on the definition of intermediate objects
which hold the operation to be performed.</p>
<p>The <code>eval</code> function is used to force the evaluation of
this operation. This is required for the computation of the eigenvalues
and the eigenvectors which is done by calling the
<code>computeEigenVectors</code> tensor of the <code>stensor</code>
class.</p>
<p>In <code>C++-17</code>, this can be called as follows:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// eigen values and eigen tensors of the total strain</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>e_vp<span class="op">,</span> m<span class="op">]</span> <span class="op">=</span> </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    e<span class="op">.</span><span class="kw">template</span> computeEigenVectors<span class="op">&lt;</span>Stensor<span class="op">::</span>FSESJACOBIEIGENSOLVER<span class="op">&gt;();</span></span></code></pre></div>
<p>In previous <code>C++</code> version, one must use a more verbose
code:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// eigen values and eigen tensors of the total strain</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> e_vp <span class="op">=</span> tvector<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span> strain<span class="op">&gt;{};</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> m <span class="op">=</span> tmatrix<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span> <span class="dv">3</span><span class="bu">u</span><span class="op">,</span> strain<span class="op">&gt;{};</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  e<span class="op">.</span><span class="kw">template</span> computeEigenVectors<span class="op">&lt;</span>Stensor<span class="op">::</span>FSESJACOBIEIGENSOLVER<span class="op">&gt;(</span>e_vp<span class="op">,</span> m<span class="op">);</span></span></code></pre></div>
<p>Here, we must make some important comments:</p>
<ul>
<li>We use the Jacobi eigen solver which is very accurate but is more
expensive than the default eigen solver.</li>
<li>The computation of the equivalent strain only requires the
eigenvalues of the total strain. We also compute its eigen vectors
because they also are the eigen vectors of the effective stress and its
positive part.</li>
</ul>
<p>The computation of the equivalent strain is then straightforward:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> e_eq <span class="op">=</span> sqrt<span class="op">(</span>square_pp<span class="op">(</span>e_vp<span class="op">[</span><span class="dv">0</span><span class="op">])</span> <span class="op">+</span> <span class="co">//</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>                         square_pp<span class="op">(</span>e_vp<span class="op">[</span><span class="dv">1</span><span class="op">])</span> <span class="op">+</span> <span class="co">//</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>                         square_pp<span class="op">(</span>e_vp<span class="op">[</span><span class="dv">2</span><span class="op">]));</span></span></code></pre></div>
<p>We are now able to compute the damage at the end of the time step as
follows:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// update the damage, taking irreversibility into account</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> Cd <span class="op">=</span> <span class="op">(</span>e0 <span class="op">/</span> e_eq<span class="op">)</span> <span class="op">*</span> exp<span class="op">(</span>Bt <span class="op">*</span> <span class="op">(</span>e0 <span class="op">-</span> e_eq<span class="op">));</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> d_p <span class="op">=</span> <span class="op">(</span>e_eq <span class="op">&gt;</span> e0<span class="op">)</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">-</span> Cd <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> bp <span class="op">=</span> d_p <span class="op">&gt;</span> d<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span>bp<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    d <span class="op">=</span> d_p<span class="op">;</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span></code></pre></div>
<p>The previous lines also defines two additional variables:</p>
<ul>
<li><code>Cd</code> which is used to compute the expression <span
class="math inline">\({{\displaystyle \frac{\displaystyle
\epsilon_{0}}{\displaystyle
{\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}}}}\exp{\left(B_{t}\,{\left(\epsilon_{0}-{\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}\right)}\right)}\)</span>
only once.</li>
<li><code>bp</code> which is a boolean stating if the damage increases
over the time step. This boolean will be used in the computation of the
consistent tangent operator.</li>
</ul>
<p>The next two lines computes the effective stress:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// effective stress at the end of the time step</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> l_tr_e <span class="op">=</span> lambda <span class="op">*</span> trace<span class="op">(</span>e<span class="op">);</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> s <span class="op">=</span> eval<span class="op">(</span>l_tr_e <span class="op">*</span> id <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> mu <span class="op">*</span> e<span class="op">);</span></span></code></pre></div>
<p>The next lines computes the positive part of the effective
stress:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// positive part of the effective stress</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> <span class="va">s_vp</span> <span class="op">=</span> tvector<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span> real<span class="op">&gt;{</span>l_tr_e <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> mu <span class="op">*</span> e_vp<span class="op">[</span><span class="dv">0</span><span class="op">],</span>  <span class="co">//</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>                                      l_tr_e <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> mu <span class="op">*</span> e_vp<span class="op">[</span><span class="dv">1</span><span class="op">],</span>  <span class="co">//</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>                                      l_tr_e <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> mu <span class="op">*</span> e_vp<span class="op">[</span><span class="dv">2</span><span class="op">]};</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> sp <span class="op">=</span> StressStensor<span class="op">::</span>computeIsotropicFunction<span class="op">(</span>pp<span class="op">,</span> <span class="va">s_vp</span><span class="op">,</span> m<span class="op">);</span></span></code></pre></div>
<p>Those lines uses the <code>computeIsotropicFunction</code> which
takes the function computing the positive part, the eigenvalues of the
effective stress and its eigen vectors.</p>
<p>Finally, the final stress is computed:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// function of the damage to simplify expressions</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> d_a <span class="op">=</span> pow<span class="op">(</span>d<span class="op">,</span> a<span class="op">);</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> fpd <span class="op">=</span> <span class="op">(</span><span class="dv">1</span> <span class="op">-</span> d<span class="op">);</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> fpn <span class="op">=</span> <span class="op">(</span><span class="dv">1</span> <span class="op">-</span> d_a<span class="op">);</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// final stress</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  sig <span class="op">=</span> <span class="op">(</span>fpd <span class="op">-</span> fpn<span class="op">)</span> <span class="op">*</span> sp <span class="op">+</span> fpn <span class="op">*</span> s<span class="op">;</span></span></code></pre></div>
<h4 id="computation-of-the-tangent-operator">Computation of the tangent
operator</h4>
<p>If one computes the tangent operator in the <code>@Integrator</code>
code block, one shall check if this operator was requested using the
<code>computeTangentOperator_</code> boolean value.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="op">(</span><span class="va">computeTangentOperator_</span><span class="op">)</span> <span class="op">{</span></span></code></pre></div>
<p>Next, we define a local function called <code>dpp</code> which
computes the derivative of the positive part:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// derivative of the positive part</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> dpp <span class="op">=</span> <span class="op">[&amp;</span>seps<span class="op">](</span><span class="at">const</span> stress x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="bu">std::</span>abs<span class="op">(</span>x<span class="op">)</span> <span class="op">&lt;</span> seps <span class="op">?</span> <span class="fl">0.5</span> <span class="op">:</span> <span class="op">((</span>x <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>Various kind of tangent operator can be computed. To see which one
was requested by the calling solver, one must check the value of the
<code>smt</code> variable (<code>smt</code> stands “stiffness matrix
type”):</p>
<p>The first case corresponds to the <code>ELASTIC</code> value:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>smt <span class="op">==</span> ELASTIC<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>      Dt <span class="op">=</span> lambda <span class="op">*</span> Stensor4<span class="op">::</span>IxI<span class="op">()</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> mu <span class="op">*</span> Stensor4<span class="op">::</span>Id<span class="op">();</span></span></code></pre></div>
<p>The second case corresponds to the <code>SECANTOPERATOR</code> value.
This case also corresponds to the consistent tangent operator was no
damage increase occurs (i.e. the <code>bp</code> variable’ value is
<code>false</code>):</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">((</span>smt <span class="op">==</span> SECANTOPERATOR<span class="op">)</span> <span class="op">||</span> <span class="op">(!</span>bp<span class="op">))</span> <span class="op">{</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>      <span class="co">// elastic stiffness</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> De <span class="op">=</span> lambda <span class="op">*</span> Stensor4<span class="op">::</span>IxI<span class="op">()</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> mu <span class="op">*</span> Stensor4<span class="op">::</span>Id<span class="op">();</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">// derivative of the positive part of the stress</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dsp <span class="op">=</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>          StressStensor<span class="op">::</span>computeIsotropicFunctionDerivative<span class="op">(</span>pp<span class="op">,</span> dpp<span class="op">,</span> <span class="va">s_vp</span><span class="op">,</span> m<span class="op">,</span> seps <span class="op">*</span> <span class="fl">0.1</span><span class="op">);</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>      Dt <span class="op">=</span> <span class="op">((</span>fpd <span class="op">*</span> dsp <span class="op">+</span> fpn <span class="op">*</span> <span class="op">(</span>Stensor4<span class="op">::</span>Id<span class="op">()</span> <span class="op">-</span> dsp<span class="op">))</span> <span class="op">+</span> eeps <span class="op">*</span> Stensor4<span class="op">::</span>Id<span class="op">())</span> <span class="op">*</span> De<span class="op">;</span></span></code></pre></div>
<p>This code uses the <code>computeIsotropicFunctionDerivative</code>
which computes <span class="math inline">\({\displaystyle
\frac{\displaystyle \partial
{\left&lt;\underline{\sigma}\right&gt;_{+}}}{\displaystyle \partial
\underline{\sigma}}}\)</span>. We also added the
<code>eeps * Stensor4::Id()</code> to avoid singular stiffness matrices
and add some coercivity to the global problem.</p>
<p>The last case corresponds to the
<code>CONSISTENTANGENTOPERATOR</code> value in case of damage
increase</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>      <span class="co">// elastic stiffness</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> De <span class="op">=</span> lambda <span class="op">*</span> Stensor4<span class="op">::</span>IxI<span class="op">()</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> mu <span class="op">*</span> Stensor4<span class="op">::</span>Id<span class="op">();</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">// derivative of the positive part of the stress</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dsp <span class="op">=</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>          StressStensor<span class="op">::</span>computeIsotropicFunctionDerivative<span class="op">(</span>pp<span class="op">,</span> dpp<span class="op">,</span> <span class="va">s_vp</span><span class="op">,</span> m<span class="op">,</span> seps <span class="op">*</span> <span class="fl">0.1</span><span class="op">);</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>      <span class="co">// derivative with respect to the damage</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dfpd_dd <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> id <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> max<span class="op">(</span>eeps<span class="op">,</span> d<span class="op">);</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dfpn_dd <span class="op">=</span> <span class="op">-</span>a <span class="op">*</span> d_a <span class="op">*</span> id<span class="op">;</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">// positive part of the total strain</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> ep <span class="op">=</span> StrainStensor<span class="op">::</span>computeIsotropicFunction<span class="op">(</span>pp<span class="op">,</span> e_vp<span class="op">,</span> m<span class="op">);</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>      <span class="co">// derivative of the damage</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dd_deq <span class="op">=</span> Cd <span class="op">*</span> <span class="op">(</span>Bt <span class="op">+</span> <span class="dv">1</span> <span class="op">/</span> e_eq<span class="op">);</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dep_de <span class="op">=</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>          StrainStensor<span class="op">::</span>computeIsotropicFunctionDerivative<span class="op">(</span>pp<span class="op">,</span> dpp<span class="op">,</span> e_vp<span class="op">,</span> m<span class="op">,</span> eeps <span class="op">*</span> <span class="fl">0.1</span><span class="op">);</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> deq_dep <span class="op">=</span> ep <span class="op">/</span> e_eq<span class="op">;</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dd_de <span class="op">=</span> dd_deq <span class="op">*</span> deq_dep <span class="op">*</span> dep_de<span class="op">;</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>      Dt <span class="op">=</span> <span class="op">((</span>fpd <span class="op">*</span> dsp <span class="op">+</span> fpn <span class="op">*</span> <span class="op">(</span>Stensor4<span class="op">::</span>Id<span class="op">()</span> <span class="op">-</span> dsp<span class="op">))</span> <span class="op">+</span> eeps <span class="op">*</span> Stensor4<span class="op">::</span>Id<span class="op">())</span> <span class="op">*</span> De  <span class="co">//</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>           <span class="op">+</span> <span class="op">(((</span>dfpd_dd <span class="op">-</span> dfpn_dd<span class="op">)</span> <span class="op">*</span> sp <span class="op">+</span> dfpn_dd <span class="op">*</span> s<span class="op">)</span> <span class="op">^</span> dd_de<span class="op">);</span></span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<!--
\[
\
\]
  const auto e_vp = e.computeEigenValues();
  const auto e_eq = sqrt(square_pp(e_vp[0]) + square_pp(e_vp[1]) + square_pp(e_vp[2]));
  // effective stress at t+theta*dt
  const auto de = (e_eq > e0) ? max(d, 1 - (e0 / e_eq) * exp(Bt * (e0 - e_eq))) : d;
  // function of the damage to simplify expressions
  const auto fpd = (1 - de);
  const auto fpn = (1 - pow(de, a));
  // effective stress at the end of the time step
  const auto s = eval(lambda * trace(e) * id + 2 * mu * e);
  // positive part
  const auto pp = [](const real x) { return x > 0 ? x : 0; };
  // derivative of the positive part
  const auto dpp = [&seps](const real x) { return std::abs(x) < seps ? 0.5 : ((x < 0) ? 0 : 1); };
  const auto sp_dsp =
      s.template computeIsotropicFunctionAndDerivative<stensor_common::FSESANALYTICALEIGENSOLVER>(
          pp, dpp, seps * 0.1);
  const auto& sp = sp_dsp.first;
  const auto& dsp = sp_dsp.second;  // derivative of sp with respect to s
  const auto sn = s - sp;
  // final stress
  sig = fpd * sp + fpn * sn;
-->
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references csl-bib-body" role="list">
<div id="ref-fichant_endommagement_1996" class="csl-entry"
role="listitem">
<div class="csl-left-margin">1. </div><div
class="csl-right-inline"><span class="smallcaps">Fichant</span>,
Stéphanie. Endommagement et anisotropie induite du béton de structures :
Modélisations approchées. thesis. Cachan, Ecole normale supérieure,
1996. Available from: <a
href="http://www.theses.fr/1996DENS0015">http://www.theses.fr/1996DENS0015</a></div>
</div>
<div id="ref-gangnant_etude_2016" class="csl-entry" role="listitem">
<div class="csl-left-margin">2. </div><div
class="csl-right-inline"><span class="smallcaps">Gangnant</span>,
Alexandre. Étude de la rupture quasi-fragile d’un béton à l’échelle
mésoscopique : Aspects expérimentaux et modélisation. thesis. Bordeaux,
2016. Available from: <a
href="http://www.theses.fr/2016BORD0401">http://www.theses.fr/2016BORD0401</a></div>
</div>
<div id="ref-hillerborg_analysis_1976" class="csl-entry"
role="listitem">
<div class="csl-left-margin">3. </div><div
class="csl-right-inline"><span class="smallcaps">Hillerborg</span>, A.,
<span class="smallcaps">Modéer</span>, M. and <span
class="smallcaps">Perterson</span>, P.-E. Analysis of crack formation
and crack growth in concrete by means of fracture mechanics and finite
elements. <em>Cement and Concrete Research</em>. 1976. Vol. 6,
p. 779–782. </div>
</div>
</div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-62273823-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
