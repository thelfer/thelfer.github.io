<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.9.1"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script>
        <title>tfel: tfel::math Namespace Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
        <link href="doxygen.css" rel="stylesheet" type="text/css" />
        <link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
        <script type="text/javascript" src="doxy-boot.js"></script>
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand">The TFEL project </a>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacetfel.html">tfel</a></li><li class="navelem"><a class="el" href="namespacetfel_1_1math.html">math</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tfel::math Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This namespace contains various classes and functions défining mathematical objects and numerical algorithms.  
<a href="namespacetfel_1_1math.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetfel_1_1math_1_1ieee754"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math_1_1ieee754.html">ieee754</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetfel_1_1math_1_1internals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math_1_1internals.html">internals</a></td></tr>
<tr class="memdesc:namespacetfel_1_1math_1_1internals"><td class="mdescLeft">&#160;</td><td class="mdescRight">This namespace contains classes, functions, metafunctions and data structures that are used internally in the <code><a class="el" href="namespacetfel_1_1math.html" title="This namespace contains various classes and functions défining mathematical objects and numerical alg...">tfel::math</a></code> namespace and that are meant to be used by the end user. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_aitken_acceleration_algorithm.html">AitkenAccelerationAlgorithm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an implementation of the Aitken \(\Delta^{2}\) algorithm  <a href="structtfel_1_1math_1_1_aitken_acceleration_algorithm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_anderson_base.html">AndersonBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights for the Anderson accelation algorithm.  <a href="structtfel_1_1math_1_1_anderson_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_f_anderson.html">FAnderson</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_u_anderson.html">UAnderson</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_array_common_methods.html">ConstArrayCommonMethods</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure gathering access methods for const arrays.  <a href="structtfel_1_1math_1_1_const_array_common_methods.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_mutable_array_common_methods.html">MutableArrayCommonMethods</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure gathering access methods and helper function for arrays.  <a href="structtfel_1_1math_1_1_mutable_array_common_methods.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_array_tag.html">ArrayTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise arrays.  <a href="structtfel_1_1math_1_1_array_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_array_concept_base.html">ArrayConceptBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used to model the concept of arrays.  <a href="structtfel_1_1math_1_1_array_concept_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_array_tag_00_01_array_type_01_4.html">ConceptRebind&lt; ArrayTag, ArrayType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for arrays  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_array_tag_00_01_array_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result___3_01_array_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; ArrayTag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_unary_result__.html">ComputeUnaryResult_</a> for arrays  <a href="classtfel_1_1math_1_1_compute_unary_result___3_01_array_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_standard_array_policy_aliases.html">StandardArrayPolicyAliases</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class defining some aliases for standard array policies  <a href="structtfel_1_1math_1_1_standard_array_policy_aliases.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_standard_array_policy.html">StandardArrayPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a standard array policy.  <a href="structtfel_1_1math_1_1_standard_array_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_from_array_policy.html">MathObjectTraitsFromArrayPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper structure to define a math object traits from an array policy.  <a href="structtfel_1_1math_1_1_math_object_traits_from_array_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_fixed_size_array_base.html">ConstFixedSizeArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class for fixed sized const arrays.  <a href="structtfel_1_1math_1_1_const_fixed_size_array_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_runtime_array_base.html">ConstRuntimeArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class for fixed sized const arrays.  <a href="structtfel_1_1math_1_1_const_runtime_array_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative_policy.html">FixedSizeArrayDerivativePolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an array policy resulting from the derivation of an math object with another math object.  <a href="structtfel_1_1math_1_1_fixed_size_array_derivative_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative_tag.html">FixedSizeArrayDerivativeTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a tag associated with the <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative_concept.html" title="a tag associated with the FixedSizeArrayDerivativeConcept">FixedSizeArrayDerivativeConcept</a>  <a href="structtfel_1_1math_1_1_fixed_size_array_derivative_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative_traits.html">FixedSizeArrayDerivativeTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a traits class associated to characterize the result of the derivation of an array with respect to another array.  <a href="structtfel_1_1math_1_1_fixed_size_array_derivative_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative_concept.html">FixedSizeArrayDerivativeConcept</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a tag associated with the <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative_concept.html" title="a tag associated with the FixedSizeArrayDerivativeConcept">FixedSizeArrayDerivativeConcept</a>  <a href="structtfel_1_1math_1_1_fixed_size_array_derivative_concept.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_fixed_size_array_derivative_tag_3_01_array1_tag_00_01a5b53c89873b0ffc392c878572da2b68.html">ConceptRebind&lt; FixedSizeArrayDerivativeTag&lt; Array1Tag, Array2Tag &gt;, ArrayDerivativeType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_concept_rebind.html" title="the ConceptRebind metafunction use the given tag to define a base class for the Type class.">ConceptRebind</a></code> class for array derivative.  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_fixed_size_array_derivative_tag_3_01_array1_tag_00_01a5b53c89873b0ffc392c878572da2b68.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class representing the derivative of an array with respect to another array.  <a href="structtfel_1_1math_1_1_fixed_size_array_derivative.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative_traits_3_01_fixed_size_array_derivative_3_01_array1_00_01_array2_01_4_01_4.html">FixedSizeArrayDerivativeTraits&lt; FixedSizeArrayDerivative&lt; Array1, Array2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative_traits.html" title="a traits class associated to characterize the result of the derivation of an array with respect to an...">FixedSizeArrayDerivativeTraits</a></code> class  <a href="structtfel_1_1math_1_1_fixed_size_array_derivative_traits_3_01_fixed_size_array_derivative_3_01_array1_00_01_array2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative_traits_3_01_expr_3_01_fixed_size_array_deriva9ab5d984cbca4cf5ea52255a3c227fc7.html">FixedSizeArrayDerivativeTraits&lt; Expr&lt; FixedSizeArrayDerivative&lt; Array1, Array2 &gt;, Operation &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative_traits.html" title="a traits class associated to characterize the result of the derivation of an array with respect to an...">FixedSizeArrayDerivativeTraits</a></code> class for expression  <a href="structtfel_1_1math_1_1_fixed_size_array_derivative_traits_3_01_expr_3_01_fixed_size_array_deriva9ab5d984cbca4cf5ea52255a3c227fc7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative_traits_3_01_view_3_01_fixed_size_array_deriva4db8ecf16f9a4b74faa2a4378274b870.html">FixedSizeArrayDerivativeTraits&lt; View&lt; FixedSizeArrayDerivative&lt; Array1, Array2 &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative_traits.html" title="a traits class associated to characterize the result of the derivation of an array with respect to an...">FixedSizeArrayDerivativeTraits</a></code> class for a view  <a href="structtfel_1_1math_1_1_fixed_size_array_derivative_traits_3_01_view_3_01_fixed_size_array_deriva4db8ecf16f9a4b74faa2a4378274b870.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01_fixed_size_array_derivative_3_01_array1_00_01_array2_01_4_01_4.html">MathObjectTraits&lt; FixedSizeArrayDerivative&lt; Array1, Array2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html" title="a traits class describing a mathematical object">MathObjectTraits</a></code> class.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01_fixed_size_array_derivative_3_01_array1_00_01_array2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01_fixed_size_array_derivative_3_01_array1_00_01_array2_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; FixedSizeArrayDerivative&lt; Array1, Array2 &gt;, OpNeg &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for unary operations  <a href="classtfel_1_1math_1_1_unary_result_type_3_01_fixed_size_array_derivative_3_01_array1_00_01_array2_01_4_00_01_op_neg_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_fixed_size_array_derivative_tag_3_01tbf06afb66908e808b431d53dcc59e8c9.html">ComputeBinaryOperationResult&lt; FixedSizeArrayDerivativeTag&lt; typename ComputeObjectTag&lt; Array11 &gt;::type, typename ComputeObjectTag&lt; Array12 &gt;::type &gt;, FixedSizeArrayDerivativeTag&lt; typename ComputeObjectTag&lt; Array21 &gt;::type, typename ComputeObjectTag&lt; Array22 &gt;::type &gt;, FixedSizeArrayDerivative&lt; Array11, Array12 &gt;, FixedSizeArrayDerivative&lt; Array21, Array22 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for the addition of two array derivatives.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_fixed_size_array_derivative_tag_3_01tbf06afb66908e808b431d53dcc59e8c9.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_fixed_size_array_derivative_tag_3_01t10044100cd14acb9bc802281bcf3ae2a.html">ComputeBinaryOperationResult&lt; FixedSizeArrayDerivativeTag&lt; typename ComputeObjectTag&lt; Array11 &gt;::type, typename ComputeObjectTag&lt; Array12 &gt;::type &gt;, FixedSizeArrayDerivativeTag&lt; typename ComputeObjectTag&lt; Array21 &gt;::type, typename ComputeObjectTag&lt; Array22 &gt;::type &gt;, FixedSizeArrayDerivative&lt; Array11, Array12 &gt;, FixedSizeArrayDerivative&lt; Array21, Array22 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for the addition of two array derivatives.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_fixed_size_array_derivative_tag_3_01t10044100cd14acb9bc802281bcf3ae2a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_fixed_size_array_derea1962afe36bc4ba5faeaae4670663dc.html">ComputeBinaryOperationResult&lt; ScalarTag, FixedSizeArrayDerivativeTag&lt; typename ComputeObjectTag&lt; Array1 &gt;::type, typename ComputeObjectTag&lt; Array2 &gt;::type &gt;, ScalarType, FixedSizeArrayDerivative&lt; Array1, Array2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the two derivatives are compatible static constexpr auto areCompatible = std::is_same_v&lt;typename <a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_result.html#a0bc243f3f3d546f0afa997d3b517d3ce" title="result of the binary operation.">ComputeObjectTag&lt;Array12&gt;::type</a>, typename <a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_result.html#a0bc243f3f3d546f0afa997d3b517d3ce" title="result of the binary operation.">ComputeObjectTag&lt;Array21&gt;::type</a>&gt;; /*!  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_fixed_size_array_derea1962afe36bc4ba5faeaae4670663dc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_fixed_size_array_derivative_tag_3_01tbf1ae1e3b95820a5dd3c27859c733c90.html">ComputeBinaryOperationResult&lt; FixedSizeArrayDerivativeTag&lt; typename ComputeObjectTag&lt; Array1 &gt;::type, typename ComputeObjectTag&lt; Array2 &gt;::type &gt;, ScalarTag, FixedSizeArrayDerivative&lt; Array1, Array2 &gt;, ScalarType, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for the multiplication an array derivative by a scalar.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_fixed_size_array_derivative_tag_3_01tbf1ae1e3b95820a5dd3c27859c733c90.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_fixed_size_array_derivative_tag_3_01t0b923ed0d8cd5df4b79e08a253fa3c8f.html">ComputeBinaryOperationResult&lt; FixedSizeArrayDerivativeTag&lt; typename ComputeObjectTag&lt; Array1 &gt;::type, typename ComputeObjectTag&lt; Array2 &gt;::type &gt;, ScalarTag, FixedSizeArrayDerivative&lt; Array1, Array2 &gt;, ScalarType, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for the multiplication an array derivative by a scalar.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_fixed_size_array_derivative_tag_3_01t0b923ed0d8cd5df4b79e08a253fa3c8f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_loop_over_inner_indices.html">LoopOverInnerIndices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_loop_over_second_indices.html">LoopOverSecondIndices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_loop_over_first_indices.html">LoopOverFirstIndices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_multiply_fixed_size_array_derivatives.html">MultiplyFixedSizeArrayDerivatives</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_vector_policy.html">FixedSizeVectorPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an array policy based on the fixed size vector indexing policy  <a href="structtfel_1_1math_1_1_fixed_size_vector_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_row_major_matrix_policy.html">FixedSizeRowMajorMatrixPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an array policy describing a fixed size matrix stored in row major format based on the fixed size matrix indexing policy.  <a href="structtfel_1_1math_1_1_fixed_size_row_major_matrix_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_scalar_indexing_policy.html">ScalarIndexingPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an indexing policy suitable for scalar  <a href="structtfel_1_1math_1_1_scalar_indexing_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_vector_indexing_policy.html">FixedSizeVectorIndexingPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an indexing policy suitable for fixed sized vectors  <a href="structtfel_1_1math_1_1_fixed_size_vector_indexing_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_3_01_fixed_size_vector_indexing_poli3a4ac835d60942037e87a59b99ba4733.html">IndexingPoliciesCompatiblityCheck&lt; FixedSizeVectorIndexingPolicy&lt; SizeType, N, Stride1 &gt;, FixedSizeVectorIndexingPolicy&lt; SizeType, N, Stride2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the `<code><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check.html" title="a structure used to compare two indexing policies">IndexingPoliciesCompatiblityCheck</a></code> class for <code><a class="el" href="structtfel_1_1math_1_1_fixed_size_vector_indexing_policy.html" title="an indexing policy suitable for fixed sized vectors">FixedSizeVectorIndexingPolicy</a></code> of the same size.  <a href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_3_01_fixed_size_vector_indexing_poli3a4ac835d60942037e87a59b99ba4733.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_row_major_matrix_indexing_policy.html">FixedSizeRowMajorMatrixIndexingPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an indexing policy suitable for fixed sized matrices  <a href="structtfel_1_1math_1_1_fixed_size_row_major_matrix_indexing_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_3_01_fixed_size_row_major_matrix_indc87d843b3c2b4577b6e93ba1b052d26e.html">IndexingPoliciesCompatiblityCheck&lt; FixedSizeRowMajorMatrixIndexingPolicy&lt; SizeType, N, M, Stride1 &gt;, FixedSizeRowMajorMatrixIndexingPolicy&lt; SizeType, N, M, Stride2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check.html" title="a structure used to compare two indexing policies">IndexingPoliciesCompatiblityCheck</a></code> class for <code><a class="el" href="structtfel_1_1math_1_1_fixed_size_row_major_matrix_indexing_policy.html" title="an indexing policy suitable for fixed sized matrices">FixedSizeRowMajorMatrixIndexingPolicy</a></code> of the same sizes.  <a href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_3_01_fixed_size_row_major_matrix_indc87d843b3c2b4577b6e93ba1b052d26e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_fixed_size_indexing_policies_cartesian_product.html">FixedSizeIndexingPoliciesCartesianProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an indexing policy build as the cartesian product of the two fixed size indexing policies.  <a href="structtfel_1_1math_1_1_fixed_size_indexing_policies_cartesian_product.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_generic_fixed_size_array.html">GenericFixedSizeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a fixed size array class with storage on the stack.  <a href="structtfel_1_1math_1_1_generic_fixed_size_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_generic_fixed_size_const_array_view.html">GenericFixedSizeConstArrayView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_generic_runtime_array.html">GenericRuntimeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a fixed size array class with storage on the stack.  <a href="structtfel_1_1math_1_1_generic_runtime_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_base.html">IndexingPoliciesCompatiblityCheckBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class to compare indexing policies which provide default implementations.  <a href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check.html">IndexingPoliciesCompatiblityCheck</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure used to compare two indexing policies  <a href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_loop_un_roller.html">LoopUnRoller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_iterate_over_multiple_indices.html">IterateOverMultipleIndices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_multi_indices_unary_operator_functor.html">MultiIndicesUnaryOperatorFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_multi_indices_binary_operator_functor.html">MultiIndicesBinaryOperatorFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_multi_indices_random_access_interator_wrapper.html">MultiIndicesRandomAccessInteratorWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_mutable_fixed_size_array_base.html">MutableFixedSizeArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class for mutable fixed size arrays.  <a href="structtfel_1_1math_1_1_mutable_fixed_size_array_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_mutable_runtime_array_base.html">MutableRuntimeArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class for mutable arrays with runtime sizes.  <a href="structtfel_1_1math_1_1_mutable_runtime_array_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runtime_vector_array_policy.html">RuntimeVectorArrayPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an array policy based on the runtime vector indexing policy  <a href="structtfel_1_1math_1_1_runtime_vector_array_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runtime_row_major_matrix_array_policy.html">RuntimeRowMajorMatrixArrayPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an array policy based on the runtime row-major matrix indexing policy  <a href="structtfel_1_1math_1_1_runtime_row_major_matrix_array_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runtime_vector_indexing_policy.html">RuntimeVectorIndexingPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an indexing policy suitable for vectors whose size is given at runtime.  <a href="structtfel_1_1math_1_1_runtime_vector_indexing_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_3_01_runtime_vector_indexing_policy_9f841585a390d8fe5e4dec250903fa52.html">IndexingPoliciesCompatiblityCheck&lt; RuntimeVectorIndexingPolicy, RuntimeVectorIndexingPolicy &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the `<code><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check.html" title="a structure used to compare two indexing policies">IndexingPoliciesCompatiblityCheck</a></code> class for <code><a class="el" href="structtfel_1_1math_1_1_runtime_vector_indexing_policy.html" title="an indexing policy suitable for vectors whose size is given at runtime.">RuntimeVectorIndexingPolicy</a></code> of the same size.  <a href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_3_01_runtime_vector_indexing_policy_9f841585a390d8fe5e4dec250903fa52.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runtime_row_major_matrix_indexing_policy.html">RuntimeRowMajorMatrixIndexingPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an indexing policy suitable for runtime matrices  <a href="structtfel_1_1math_1_1_runtime_row_major_matrix_indexing_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_array_with_contiguous_data_s_t_l_compatibility_layer.html">ConstArrayWithContiguousDataSTLCompatibilityLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code>ArraySTLCompatibilityLayer</code> class when the memoy layout is contiguous.  <a href="structtfel_1_1math_1_1_const_array_with_contiguous_data_s_t_l_compatibility_layer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_array_without_contiguous_data_s_t_l_compatibility_layer.html">ConstArrayWithoutContiguousDataSTLCompatibilityLayer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_const_array_s_t_l_compatibility_layer.html">ConstArraySTLCompatibilityLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class providing standard methods and aliases for compatibility with the standard template library (STL) based on the curiously recurring template pattern (CRTP).  <a href="structtfel_1_1math_1_1_const_array_s_t_l_compatibility_layer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_mutable_array_with_contiguous_data_s_t_l_compatibility_layer.html">MutableArrayWithContiguousDataSTLCompatibilityLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code>ArraySTLCompatibilityLayer</code> class when the memoy layout is contiguous.  <a href="structtfel_1_1math_1_1_mutable_array_with_contiguous_data_s_t_l_compatibility_layer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_mutable_array_without_contiguous_data_s_t_l_compatibility_layer.html">MutableArrayWithoutContiguousDataSTLCompatibilityLayer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_mutable_array_s_t_l_compatibility_layer.html">MutableArraySTLCompatibilityLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class providing standard methods and aliases for compatibility with the standard template library (STL) based on the curiously recurring template pattern (CRTP).  <a href="structtfel_1_1math_1_1_mutable_array_s_t_l_compatibility_layer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_view.html">View</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">view of an object from a continuous memory area  <a href="structtfel_1_1math_1_1_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_view_array_policy.html">ViewArrayPolicy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a standard array policy.  <a href="structtfel_1_1math_1_1_view_array_policy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01_view_3_01_mapped_type_00_01_array_policy_01_4_01_4.html">MathObjectTraits&lt; View&lt; MappedType, ArrayPolicy &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html" title="a traits class describing a mathematical object">MathObjectTraits</a></code> for const views  <a href="structtfel_1_1math_1_1_math_object_traits_3_01_view_3_01_mapped_type_00_01_array_policy_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_of_evaluation_3_01_view_3_01_mapped_type_00_01_array_policy_01_4_01_4.html">ResultOfEvaluation&lt; View&lt; MappedType, ArrayPolicy &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_result_of_evaluation.html" title="a metafunction giving the result of a the evaluation of an object.">ResultOfEvaluation</a></code> class for views.  <a href="structtfel_1_1math_1_1_result_of_evaluation_3_01_view_3_01_mapped_type_00_01_array_policy_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_views_array.html">ViewsArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a structure used to represent an array of views.  <a href="structtfel_1_1math_1_1_views_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_views_fixed_size_vector_indexing_policy.html">ViewsFixedSizeVectorIndexingPolicy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01cadna_1_1numeric__type_3_01_t1_01_4_00_01cadna_1_1numeric4647a7dbf40f75c8d11b614983725a44.html">ResultType&lt; cadna::numeric_type&lt; T1 &gt;, cadna::numeric_type&lt; T2 &gt;, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01cadna_1_1numeric__type_3_01_t1_01_4_00_01_t2_00_01_op_01_4.html">ResultType&lt; cadna::numeric_type&lt; T1 &gt;, T2, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01_t1_00_01cadna_1_1numeric__type_3_01_t2_01_4_00_01_op_01_4.html">ResultType&lt; T1, cadna::numeric_type&lt; T2 &gt;, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01cadna_1_1numeric__type_3_01_t_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; cadna::numeric_type&lt; T &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_uninitialised.html">CubicSplineUninitialised</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_invalid_abscissa_vector_size.html">CubicSplineInvalidAbscissaVectorSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_null_pivot.html">CubicSplineNullPivot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_invalid_ordinate_vector_size.html">CubicSplineInvalidOrdinateVectorSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_invalid_inputs.html">CubicSplineInvalidInputs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_unordered_abscissa_vector.html">CubicSplineUnorderedAbscissaVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline_collocation_point.html">CubicSplineCollocationPoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure which represents a collocation point  <a href="structtfel_1_1math_1_1_cubic_spline_collocation_point.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_spline.html">CubicSpline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure in charge of computing the cubic spline of a series of collocation points  <a href="structtfel_1_1math_1_1_cubic_spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_geometric_discretization_invalid_density.html">GeometricDiscretizationInvalidDensity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_geometric_discretization_invalid_length.html">GeometricDiscretizationInvalidLength</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_geometric_discretization_invalid_number_of_elements.html">GeometricDiscretizationInvalidNumberOfElements</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_evaluator.html">Evaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class in charge of handling a function defined by a string.  <a href="structtfel_1_1math_1_1_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_base.html">ExprBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper class  <a href="structtfel_1_1math_1_1_expr_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation.">Expr</a> object allows the lazy evaluation of a mathematical operation.  <a href="structtfel_1_1math_1_1_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_unary_operation_3_01_t1_00_01_op_01_4_01_4.html">Expr&lt; ResultType, UnaryOperation&lt; T1, Op &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation.">Expr</a> object allowing the lazy evaluation of an unary operation.  <a href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_unary_operation_3_01_t1_00_01_op_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_binary_operation_3_01_t1_00_01_t2_00_01_op_01_4_01_4.html">Expr&lt; ResultType, BinaryOperation&lt; T1, T2, Op &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation.">Expr</a> object allowing the lazy evaluation of a binary operation.  <a href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_binary_operation_3_01_t1_00_01_t2_00_01_op_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_scalar_object_operation_3_01_t1_00_01_t2_00_01_op_01_4_01_4.html">Expr&lt; ResultType, ScalarObjectOperation&lt; T1, T2, Op &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_object_scalar_operation_3_01_t1_00_01_t2_00_01_op_01_4_01_4.html">Expr&lt; ResultType, ObjectScalarOperation&lt; T1, T2, Op &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_result_type_00_01_diadic_product_operation_3_01_t1_00_01_t2_01_4_01_4.html">Expr&lt; ResultType, DiadicProductOperation&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01_expr_3_01_result_type_00_01_operation_01_4_01_4.html">MathObjectTraits&lt; Expr&lt; ResultType, Operation &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html" title="a traits class describing a mathematical object">MathObjectTraits</a></code>. We assume that the expression has the same properties that the result of its evaluation.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01_expr_3_01_result_type_00_01_operation_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_model_adaptator.html">KrigingModelAdaptator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_factorized_kriging.html">FactorizedKriging</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_factorized_kriging1_d1_d.html">FactorizedKriging1D1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_factorized_kriging1_d2_d.html">FactorizedKriging1D2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_factorized_kriging1_d3_d.html">FactorizedKriging1D3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_operation.html">UnaryOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_binary_operation.html">BinaryOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_scalar_object_operation.html">ScalarObjectOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_object_scalar_operation.html">ObjectScalarOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_diadic_product_operation.html">DiadicProductOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_of_evaluation.html">ResultOfEvaluation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a metafunction giving the result of a the evaluation of an object.  <a href="structtfel_1_1math_1_1_result_of_evaluation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_of_evaluation_3_01_expr_3_01_result_type_00_01_operation_01_4_01_4.html">ResultOfEvaluation&lt; Expr&lt; ResultType, Operation &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_result_of_evaluation.html" title="a metafunction giving the result of a the evaluation of an object.">ResultOfEvaluation</a></code> class for objects representing a lazy expression.  <a href="structtfel_1_1math_1_1_result_of_evaluation_3_01_expr_3_01_result_type_00_01_operation_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1fsarray.html">fsarray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class representing tiny vectors of fixed size.  <a href="structtfel_1_1math_1_1fsarray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01fsarray_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; fsarray&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for fsarrays.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01fsarray_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1matrix.html">matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">runtime row-major matrices  <a href="structtfel_1_1math_1_1matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01matrix_3_01_t_01_4_01_4.html">MathObjectTraits&lt; matrix&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for <code>matrix</code>. This is a MatrixConcept requirement.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01matrix_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure describing an unit  <a href="structtfel_1_1math_1_1_unit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_quantity_traits.html">QuantityTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper structure to retrieve the underlying numeric type and unit from a type when this is meaningful.  <a href="structtfel_1_1math_1_1_quantity_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_quantity_traits_3_01_quantity_3_01_quantity_unit_type_00_01_quantity_valu3f151d28c90bf326177b314b31786f75.html">QuantityTraits&lt; Quantity&lt; QuantityUnitType, QuantityValueType, QuantityOwnershipPolicy &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for quantities.  <a href="structtfel_1_1math_1_1_quantity_traits_3_01_quantity_3_01_quantity_unit_type_00_01_quantity_valu3f151d28c90bf326177b314b31786f75.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_make_quantity_reference_type.html">MakeQuantityReferenceType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper metafunction which transforms a quantity type into the a reference  <a href="structtfel_1_1math_1_1_make_quantity_reference_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_make_quantity_reference_type_3_01qt_3_01_unit_type_00_01_value_type_01_4_01_4.html">MakeQuantityReferenceType&lt; qt&lt; UnitType, ValueType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for quantities  <a href="structtfel_1_1math_1_1_make_quantity_reference_type_3_01qt_3_01_unit_type_00_01_value_type_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1runtime__array.html">runtime_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class representing array of dynamic size.  <a href="structtfel_1_1math_1_1runtime__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01runtime__array_3_01_value_type_01_4_01_4.html">MathObjectTraits&lt; runtime_array&lt; ValueType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <code><a class="el" href="structtfel_1_1math_1_1runtime__array.html" title="a class representing array of dynamic size.">runtime_array</a></code>.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01runtime__array_3_01_value_type_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear operator on symmetric tensors.  <a href="structtfel_1_1math_1_1st2tost2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01st2tost2_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; st2tost2&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html" title="a traits class describing a mathematical object">MathObjectTraits</a></code> class for <code><a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a></code>.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01st2tost2_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01st2tot2_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; st2tot2&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">symmetric tensor.  <a href="structtfel_1_1math_1_1stensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01stensor_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; stensor&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html" title="a traits class describing a mathematical object">MathObjectTraits</a></code> class.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01stensor_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">linear operator which turns an unsymmetric tensor to symmetric tensor.  <a href="structtfel_1_1math_1_1t2tost2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01t2tost2_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; t2tost2&lt; N, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01t2tot2_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; t2tot2&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html" title="a traits class describing a mathematical object">MathObjectTraits</a></code> class for <code><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a></code>.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01t2tot2_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01tensor_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; tensor&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html" title="a traits class describing a mathematical object">MathObjectTraits</a></code> class.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01tensor_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_tiny_newton_raphson.html">TinyNewtonRaphson</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_01_4.html">MathObjectTraits&lt; tmatrix&lt; N, M, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for tmatrix This is a MatrixConcept requirement.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a class representing tiny vectors of fixed size.  <a href="structtfel_1_1math_1_1tvector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01tvector_3_01_n_00_01_t_01_4_01_4.html">MathObjectTraits&lt; tvector&lt; N, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for tvectors.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01tvector_3_01_n_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing dynamically allocated vector.  <a href="structtfel_1_1math_1_1vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_3_01vector_3_01_t_01_4_01_4.html">MathObjectTraits&lt; vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for the vector class.  <a href="structtfel_1_1math_1_1_math_object_traits_3_01vector_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1array__holder.html">array_holder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01fsarray_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; fsarray&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_array_tag_00_01_scalar_tag_00_01fsarrfe938f9d0bdc04951f1ca1a9e2dd96f3.html">ComputeBinaryOperationResult&lt; ArrayTag, ScalarTag, fsarray&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for fsarray and scalars operations  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_array_tag_00_01_scalar_tag_00_01fsarrfe938f9d0bdc04951f1ca1a9e2dd96f3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_array_tag_00_01_scalar_tag_00_01fsarre9a384e4ba304873b87dd94c04169cae.html">ComputeBinaryOperationResult&lt; ArrayTag, ScalarTag, fsarray&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for fsarray and scalars operations  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_array_tag_00_01_scalar_tag_00_01fsarre9a384e4ba304873b87dd94c04169cae.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_array_tag_00_01_scal6aaff5738ae1937696f26792f7830b4b.html">ComputeBinaryOperationResult&lt; ScalarTag, ArrayTag, Scal, fsarray&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for fsarray and scalars operations  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_array_tag_00_01_scal6aaff5738ae1937696f26792f7830b4b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01fsarray_3_01_n_00_01_t_01_4_00_01fsarray_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; fsarray&lt; N, T &gt;, fsarray&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for fsarray  <a href="classtfel_1_1math_1_1_result_type_3_01fsarray_3_01_n_00_01_t_01_4_00_01fsarray_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01fsarray_3_01_n_00_01_t_01_4_00_01fsarray_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; fsarray&lt; N, T &gt;, fsarray&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for fsarray  <a href="classtfel_1_1math_1_1_result_type_3_01fsarray_3_01_n_00_01_t_01_4_00_01fsarray_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_f_s_levenberg_marquardt_variable.html">FSLevenbergMarquardtVariable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_f_s_levenberg_marquardt_variable_3_011u_00_01_t_01_4.html">FSLevenbergMarquardtVariable&lt; 1u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_f_s_levenberg_marquardt.html">FSLevenbergMarquardt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_abs_sum.html">AbsSum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a basic functor accumulating the absolute value of a container  <a href="structtfel_1_1math_1_1_abs_sum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1abs_compare.html">absCompare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_power.html">Power</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an help structure used to specialize the <a class="el" href="classtfel_1_1math_1_1_unary_result_type.html">UnaryResultType</a> class  <a href="structtfel_1_1math_1_1_power.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01_complex_3_01float_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; Complex&lt; float &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01_complex_3_01double_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; Complex&lt; double &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01_complex_3_01long_01double_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; Complex&lt; long double &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler.html">ComputeBinaryOperationHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>. This default version returns InvalidType both for Result and Handle.  <a href="structtfel_1_1math_1_1_compute_binary_operation_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler_3_01_scalar_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_plus_01_4.html">ComputeBinaryOperationHandler&lt; ScalarTag, ScalarTag, A, B, OpPlus &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler_3_01_scalar_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_minus_01_4.html">ComputeBinaryOperationHandler&lt; ScalarTag, ScalarTag, A, B, OpMinus &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler_3_01_scalar_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; ScalarTag, ScalarTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler_3_01_scalar_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_div_01_4.html">ComputeBinaryOperationHandler&lt; ScalarTag, ScalarTag, A, B, OpDiv &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler_3_01_scalar_tag_00_01_math_object_tag_00b703abb03566e06b31c98c29770e7d11.html">ComputeBinaryOperationHandler&lt; ScalarTag, MathObjectTag, A, B, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryOperationHandler</a> for scalar-vector operations.  <a href="structtfel_1_1math_1_1_compute_binary_operation_handler_3_01_scalar_tag_00_01_math_object_tag_00b703abb03566e06b31c98c29770e7d11.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_math_object_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; MathObjectTag, ScalarTag, A, B, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryOperationHandler</a> for vector-scalar operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_math_object_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_math_object_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_div_01_4.html">ComputeBinaryOperationHandler&lt; MathObjectTag, ScalarTag, A, B, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryOperationHandler</a> for vector-scalar operations  <a href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_math_object_tag_00_01_scalar_tag_00_01_a_00_01_b_00_01_op_div_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_math_object_tag_00_01_math_object_ta678525739d11dd285f3440a6fca43370.html">ComputeBinaryOperationHandler&lt; MathObjectTag, MathObjectTag, A, B, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryOperationHandler</a> for vector's operation  <a href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_math_object_tag_00_01_math_object_ta678525739d11dd285f3440a6fca43370.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_math_object_tag_00_01_math_object_taf9bbfcbb57592fbcbb2344ac06801146.html">ComputeBinaryOperationHandler&lt; MathObjectTag, MathObjectTag, A, B, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryOperationHandler</a> for vector's operation  <a href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_math_object_tag_00_01_math_object_taf9bbfcbb57592fbcbb2344ac06801146.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag.html">ComputeObjectTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a metafunction which compute the tag. associated with a given type.  <a href="structtfel_1_1math_1_1_compute_object_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_scalar_tag.html">ScalarTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise scalars.  <a href="structtfel_1_1math_1_1_scalar_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_operator_tag.html">UnaryOperatorTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise operators.  <a href="structtfel_1_1math_1_1_unary_operator_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag__.html">ComputeObjectTag_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An helper metafunction for tag computing.  <a href="structtfel_1_1math_1_1_compute_object_tag__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01true_01_4.html">ComputeObjectTag_&lt; Type, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for scalars.  <a href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01false_00_01true_01_4.html">ComputeObjectTag_&lt; Type, false, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for unary operators.  <a href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01false_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01false_00_01false_00_01true_01_4.html">ComputeObjectTag_&lt; Type, false, false, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for functions.  <a href="structtfel_1_1math_1_1_compute_object_tag___3_01_type_00_01false_00_01false_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result__.html">ComputeUnaryResult_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_scalar_tag_00_01_tag_op_00_01_a_00_01_op_01_4.html">ComputeUnaryResult_&lt; ScalarTag, TagOp, A, Op &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_unary_result__.html">ComputeUnaryResult_</a> for scalars  <a href="structtfel_1_1math_1_1_compute_unary_result___3_01_scalar_tag_00_01_tag_op_00_01_a_00_01_op_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind.html">ConceptRebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code><a class="el" href="structtfel_1_1math_1_1_concept_rebind.html" title="the ConceptRebind metafunction use the given tag to define a base class for the Type class.">ConceptRebind</a></code> metafunction use the given tag to define a base class for the <code>Type</code> class.  <a href="structtfel_1_1math_1_1_concept_rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01tfel_1_1meta_1_1_invalid_type_00_01_type_01_4.html">ConceptRebind&lt; tfel::meta::InvalidType, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">the <code><a class="el" href="structtfel_1_1math_1_1_concept_rebind.html" title="the ConceptRebind metafunction use the given tag to define a base class for the Type class.">ConceptRebind</a></code> metafunction use the given tag to define a base class for the <code>Type</code> class.  <a href="structtfel_1_1math_1_1_concept_rebind_3_01tfel_1_1meta_1_1_invalid_type_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cubic_roots.html">CubicRoots</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html">DerivativeTypeDispatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper metafunction used to determine the type representing the derivative of an object of type <code>FunctionType</code> with respect to an object of type <code>VariableType</code>.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01tfel_1_1meta_1_1_invalid_type_00_01_variab35c051a88e68001c455c37a5f5218d91.html">DerivativeTypeDispatcher&lt; tfel::meta::InvalidType, VariableTag, FunctionType, VariableType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation if the first object does not have a tag.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01tfel_1_1meta_1_1_invalid_type_00_01_variab35c051a88e68001c455c37a5f5218d91.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_function_tag_00_01tfel_1_1meta_1_1_invali8ba97eb2bd565cd1a7d547197fe83d95.html">DerivativeTypeDispatcher&lt; FunctionTag, tfel::meta::InvalidType, FunctionType, VariableType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation if the second object does not have a tag.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_function_tag_00_01tfel_1_1meta_1_1_invali8ba97eb2bd565cd1a7d547197fe83d95.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01tfel_1_1meta_1_1_invalid_type_00_01tfel_1_99d53ec2283dea482c40726ff9e6e9ee.html">DerivativeTypeDispatcher&lt; tfel::meta::InvalidType, tfel::meta::InvalidType, FunctionType, VariableType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation if none o the two objects have a tag.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01tfel_1_1meta_1_1_invalid_type_00_01tfel_1_99d53ec2283dea482c40726ff9e6e9ee.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_implementation.html">DerivativeTypeImplementation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a meta function returning the type of the derivative of a variable of type <code>FunctionType</code> with respect to a variable of type <code>VariableType</code>.  <a href="structtfel_1_1math_1_1_derivative_type_implementation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_implementation_3_01true_00_01true_00_01_function_type_00_01_variable_type_01_4.html">DerivativeTypeImplementation&lt; true, true, FunctionType, VariableType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of both types are scalar  <a href="structtfel_1_1math_1_1_derivative_type_implementation_3_01true_00_01true_00_01_function_type_00_01_variable_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_implementation_3_01false_00_01true_00_01_function_type_00_01_variable_type_01_4.html">DerivativeTypeImplementation&lt; false, true, FunctionType, VariableType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of both types are scalar  <a href="structtfel_1_1math_1_1_derivative_type_implementation_3_01false_00_01true_00_01_function_type_00_01_variable_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type.html">DerivativeType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a meta function returning the type of the derivative of a variable of type <code>FunctionType</code> with respect to variables of type <code>VariablesType</code>.  <a href="structtfel_1_1math_1_1_derivative_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_3_01_function_type_00_01_variable_type_00_01_other_variables_types_8_8_8_01_4.html">DerivativeType&lt; FunctionType, VariableType, OtherVariablesTypes... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_3_01_function_type_00_01_variable_type_01_4.html">DerivativeType&lt; FunctionType, VariableType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_meta_function.html">DerivativeTypeMetaFunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper metafunction to define the derivative of a function with respect to several variables.  <a href="structtfel_1_1math_1_1_derivative_type_meta_function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_meta_function_3_01_function_type_00_01_variable_type_01_4.html">DerivativeTypeMetaFunction&lt; FunctionType, VariableType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the helper metafunction to end the recursion.  <a href="structtfel_1_1math_1_1_derivative_type_meta_function_3_01_function_type_00_01_variable_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator_base.html">DifferenceRandomAccessIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class of the <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html" title="an adaptator to random access iterator">DifferenceRandomAccessIterator</a> containing some static common utility methods.  <a href="structtfel_1_1math_1_1_difference_random_access_iterator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an adaptator to random access iterator  <a href="structtfel_1_1math_1_1_difference_random_access_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1dot_product.html">dotProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structtfel_1_1math_1_1dot_product.html" title="dotProduct calculates a generalized inner product of the ranges [first1,first1+N) and [first2,...">dotProduct</a> calculates a generalized inner product of the ranges [first1,first1+N) and [first2,first2+N)  <a href="structtfel_1_1math_1_1dot_product.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1dot_product_3_010u_01_4.html">dotProduct&lt; 0u &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation used to end recursion when using the <a class="el" href="structtfel_1_1math_1_1dot_product.html" title="dotProduct calculates a generalized inner product of the ranges [first1,first1+N) and [first2,...">dotProduct</a> algorithm.  <a href="structtfel_1_1math_1_1dot_product_3_010u_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_dot_product.html">DotProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_dot_product_3_010u_00_01_m_01_4.html">DotProduct&lt; 0u, M &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is aimed to used for mathematical objects whose size are known at compile-tme.  <a href="structtfel_1_1math_1_1_empty_run_time_properties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_or.html">OpOr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_op_and.html">OpAnd</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cste_base.html">CsteBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_cste.html">Cste</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits_base.html">MathObjectTraitsBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a helper structure to define the <code><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html" title="a traits class describing a mathematical object">MathObjectTraits</a></code> more compactly  <a href="structtfel_1_1math_1_1_math_object_traits_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a traits class describing a mathematical object  <a href="structtfel_1_1math_1_1_math_object_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_result.html">ComputeBinaryOperationResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_inverse_type_implementation.html">InverseTypeImplementation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">metafunction returning the inverse of a type.  <a href="structtfel_1_1math_1_1_inverse_type_implementation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_inverse_type_implementation_3_01true_00_01_scalar_type_01_4.html">InverseTypeImplementation&lt; true, ScalarType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_inverse_type_implementation.html" title="metafunction returning the inverse of a type.">InverseTypeImplementation</a></code> for scalars.  <a href="structtfel_1_1math_1_1_inverse_type_implementation_3_01true_00_01_scalar_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_inverse_type_dispatcher.html">InverseTypeDispatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an help structure to compute the inverse of a MathObject. This structure is meant to be specialized when meaningful.  <a href="structtfel_1_1math_1_1_inverse_type_dispatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_inverse_type_implementation_3_01false_00_01_math_object_type_01_4.html">InverseTypeImplementation&lt; false, MathObjectType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_inverse_type_implementation.html" title="metafunction returning the inverse of a type.">InverseTypeImplementation</a></code> for non scalar types.  <a href="structtfel_1_1math_1_1_inverse_type_implementation_3_01false_00_01_math_object_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runtime_check_failure.html">RuntimeCheckFailure</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_run_time_check.html">RunTimeCheck</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_run_time_check_3_01_empty_run_time_properties_01_4.html">RunTimeCheck&lt; EmptyRunTimeProperties &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator_base.html">StridedRandomAccessIteratorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class of the <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html" title="an adaptator to random access iterator">StridedRandomAccessIterator</a> containing some static common utility methods.  <a href="structtfel_1_1math_1_1_strided_random_access_iterator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an adaptator to random access iterator  <a href="structtfel_1_1math_1_1_strided_random_access_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_operation_result.html">ComputeUnaryOperationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class for <a class="el" href="classtfel_1_1math_1_1_unary_result_type.html">UnaryResultType</a>. This default version returns InvalidType both for Result and Handle.  <a href="structtfel_1_1math_1_1_compute_unary_operation_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type.html">UnaryResultType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_integer_evaluator.html">IntegerEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class in charge of handling a function defined by a string.  <a href="structtfel_1_1math_1_1_integer_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_model_3_011u_00_01_t_00_01_n_m_01_4.html">KrigingDefaultModel&lt; 1u, T, NM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_model_3_012u_00_01_t_00_01_n_m_01_4.html">KrigingDefaultModel&lt; 2u, T, NM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_model_3_013u_00_01_t_00_01_n_m_01_4.html">KrigingDefaultModel&lt; 3u, T, NM &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_model.html">KrigingDefaultModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_default_nugget_model.html">KrigingDefaultNuggetModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_error_invalid_length.html">KrigingErrorInvalidLength</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_error_no_data_specified.html">KrigingErrorNoDataSpecified</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_error_insufficient_data.html">KrigingErrorInsufficientData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_piece_wise_linear_model1_d.html">KrigingPieceWiseLinearModel1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_utilities.html">KrigingUtilities</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_variable.html">KrigingVariable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging_variable_3_011u_00_01_t_01_4.html">KrigingVariable&lt; 1u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging.html">Kriging</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging1_d.html">Kriging1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging2_d.html">Kriging2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_kriging3_d.html">Kriging3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_levenberg_marquardt.html">LevenbergMarquardt</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_decomp.html">LUDecomp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_exception.html">LUException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_unmatched_size.html">LUUnmatchedSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_matrix_not_square.html">LUMatrixNotSquare</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_invalid_matrix_size.html">LUInvalidMatrixSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_null_pivot.html">LUNullPivot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_null_determinant.html">LUNullDeterminant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_permutation.html">Permutation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_permutation.html">TinyPermutation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_l_u_solve.html">LUSolve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_exception.html">MathException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_run_time_exception.html">MathRunTimeException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_invalid_time_step_exception.html">InvalidTimeStepException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_math_divergence_exception.html">MathDivergenceException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_maximum_number_of_iterations_reached_exception.html">MaximumNumberOfIterationsReachedException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_singular_jacobian_exception.html">SingularJacobianException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_tag.html">MatrixTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise matrices.  <a href="structtfel_1_1math_1_1_matrix_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_concept_base.html">MatrixConceptBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used to model the concept of matrices.  <a href="structtfel_1_1math_1_1_matrix_concept_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_matrix_tag_00_01_matrix_type_01_4.html">ConceptRebind&lt; MatrixTag, MatrixType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for matrices  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_matrix_tag_00_01_matrix_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_matrix_vector_handle.html">MatrixVectorHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_vector_matrix_handle.html">VectorMatrixHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_matrix_matrix_handle.html">MatrixMatrixHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler_3_01_matrix_tag_00_01_vector_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; MatrixTag, VectorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryOperationHandler</a> for matrix-vector multiplication  <a href="structtfel_1_1math_1_1_compute_binary_operation_handler_3_01_matrix_tag_00_01_vector_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler_3_01_vector_tag_00_01_matrix_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; VectorTag, MatrixTag, A, B, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryOperationHandler</a> for vector-matrix multiplication  <a href="structtfel_1_1math_1_1_compute_binary_operation_handler_3_01_vector_tag_00_01_matrix_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler_3_01_matrix_tag_00_01_matrix_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; MatrixTag, MatrixTag, A, B, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryOperationHandler</a> for matrix-matrix multiplication  <a href="structtfel_1_1math_1_1_compute_binary_operation_handler_3_01_matrix_tag_00_01_matrix_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result___3_01_matrix_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; MatrixTag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_unary_result__.html">ComputeUnaryResult_</a> for matrices  <a href="classtfel_1_1math_1_1_compute_unary_result___3_01_matrix_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; tmatrix&lt; N, M, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_matrix_tag_00_01_scalar_tag_00_01tmatf3f12531f4ed3673e765e2df2218dcdf.html">ComputeBinaryOperationResult&lt; MatrixTag, ScalarTag, tmatrix&lt; N, M, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_matrix_tag_00_01_scalar_tag_00_01tmatf3f12531f4ed3673e765e2df2218dcdf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_matrix_tag_00_01_scalar_tag_00_01tmatcb5739c87051c9db3928bba8ca3f3bcd.html">ComputeBinaryOperationResult&lt; MatrixTag, ScalarTag, tmatrix&lt; N, M, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_matrix_tag_00_01_scalar_tag_00_01tmatcb5739c87051c9db3928bba8ca3f3bcd.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_matrix_tag_00_01_scab13b831068df906a2554b207801fa6c1.html">ComputeBinaryOperationResult&lt; ScalarTag, MatrixTag, Scal, tmatrix&lt; N, M, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_matrix_tag_00_01_scab13b831068df906a2554b207801fa6c1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tmatrix_3_01_n_00fb04be3c3710f39eeffa976edd33cc6b.html">ResultType&lt; tmatrix&lt; N, M, T &gt;, tmatrix&lt; N, M, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix.  <a href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tmatrix_3_01_n_00fb04be3c3710f39eeffa976edd33cc6b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tmatrix_3_01_n_00d23288766b859f04393212189880780a.html">ResultType&lt; tmatrix&lt; N, M, T &gt;, tmatrix&lt; N, M, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tmatrix.  <a href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tmatrix_3_01_n_00d23288766b859f04393212189880780a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tvector_3_01_m_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tmatrix&lt; N, M, T &gt;, tvector&lt; M, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tmatrix_3_01_n_00_01_m_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tmatrix&lt; N, M, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tmatrix_3_01_n_00_01_k_00_01_t_01_4_00_01tmatrix_3_01_k_0051dcf6422322f46994e55dfd73121c3d.html">ResultType&lt; tmatrix&lt; N, K, T &gt;, tmatrix&lt; K, M, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_matrix_vector_handle_3_01tmatrix_3_01_n_00_01_m_00_01_t_01_4_00_01tvector_7459a53bfb61de9ef0633aa0de6b8077.html">MatrixVectorHandle&lt; tmatrix&lt; N, M, T &gt;, tvector&lt; M, T2 &gt;, A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_matrix_vector_handle_3_01tvector_3_01_n_00_01_t_01_4_00_01tmatrix_3_01_n_0a6d426fa0cba568d50d019d6432066a6.html">MatrixVectorHandle&lt; tvector&lt; N, T &gt;, tmatrix&lt; N, M, T2 &gt;, A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_matrix_matrix_handle_3_01tmatrix_3_01_n_00_01_k_00_01_t_01_4_00_01tmatrix_04d58ba599e0dbfe628022b1134e9331.html">MatrixMatrixHandle&lt; tmatrix&lt; N, K, T &gt;, tmatrix&lt; K, M, T2 &gt;, A, B &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_matrix_t_matrix_expr.html">TMatrixTMatrixExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an expression representing the product of a (N, K) tiny matrix by a (K, M) tiny matrix.  <a href="structtfel_1_1math_1_1_t_matrix_t_matrix_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_matrix_t_vector_expr.html">TMatrixTVectorExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A placeholder for the computation of product of a tiny matrix and a tiny vector.  <a href="structtfel_1_1math_1_1_t_matrix_t_vector_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t_vector_t_matrix_expr.html">TVectorTMatrixExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_levenberg_marquardt_function_wrapper.html">LevenbergMarquardtFunctionWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_bissection_algorithm_data.html">BissectionAlgorithmData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a data structure holoding the current state of the bissection algorithm.  <a href="structtfel_1_1math_1_1_bissection_algorithm_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_bissection_algorithm_base.html">BissectionAlgorithmBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class to algorithms that extends a scalar root finding algorithm, such as a fixed-point iteration, Newton-Raphson, Stephensen, etc.. with the bissection algorithm.  <a href="structtfel_1_1math_1_1_bissection_algorithm_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stack_allocated_tiny_non_linear_solver_workspace.html">StackAllocatedTinyNonLinearSolverWorkspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class for allocating on the stack a workspace usable by the solvers derived from <code><a class="el" href="structtfel_1_1math_1_1_tiny_non_linear_solver_base.html" title="A base class for algorithms dedicated to solve finite sized system of non linear equations.">TinyNonLinearSolverBase</a></code> class.  <a href="structtfel_1_1math_1_1_stack_allocated_tiny_non_linear_solver_workspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_non_linear_solver_base.html">TinyNonLinearSolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for algorithms dedicated to solve finite sized system of non linear equations.  <a href="structtfel_1_1math_1_1_tiny_non_linear_solver_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_decomp.html">QRDecomp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_exception.html">QRException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_unmatched_size.html">QRUnmatchedSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_invalid_matrix_size.html">QRInvalidMatrixSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_q_r_null_pivot.html">QRNullPivot</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01_quantity_3_01_unit_00_01_value_type_00_01_ownershipb69fc3de39c43c03d2898f76bfe45909.html">UnaryResultType&lt; Quantity&lt; Unit, ValueType, OwnershipPolicy &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01float_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; qt&lt; Unit, float &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01double_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; qt&lt; Unit, double &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01long_01double_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; qt&lt; Unit, long double &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01_complex_3_01float_01_4_01_4_00_01_power_3_01_n_00_01_d_01_4_01_4.html">UnaryResultType&lt; qt&lt; Unit, Complex&lt; float &gt; &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01_complex_3_01double_01_4_01_4_00_061d6b5a193fd75b770af8793d45c486d.html">UnaryResultType&lt; qt&lt; Unit, Complex&lt; double &gt; &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01qt_3_01_unit_00_01_complex_3_01long_01double_01_4_015cb1689c54c69868d2635b7dded33ef6.html">UnaryResultType&lt; qt&lt; Unit, Complex&lt; long double &gt; &gt;, Power&lt; N, D &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_operation_result_3_01_scalar_tag_00_01_unary_operator_tag_0fa876882e5124a3c55170380c0c41e1d.html">ComputeUnaryOperationResult&lt; ScalarTag, UnaryOperatorTag, Quantity&lt; UnitType, ValueType, OwnershipPolicy &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01_quantity_3_01_unit_type_00_01_value_type_00_01_ownershipa72b6dced6862bfdb76c80f28cc56335.html">ResultType&lt; Quantity&lt; UnitType, ValueType, OwnershipPolicy &gt;, Quantity&lt; UnitType, ValueType2, OwnershipPolicy2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for addition of two qt having the same unit.  <a href="structtfel_1_1math_1_1_result_type_3_01_quantity_3_01_unit_type_00_01_value_type_00_01_ownershipa72b6dced6862bfdb76c80f28cc56335.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01_quantity_3_01_unit_type_00_01_value_type_00_01_ownership5351a0fa7c5e44e9399482d760dfd419.html">ResultType&lt; Quantity&lt; UnitType, ValueType, OwnershipPolicy &gt;, Quantity&lt; UnitType, ValueType2, OwnershipPolicy2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for substraction of two qt having the same unit.  <a href="structtfel_1_1math_1_1_result_type_3_01_quantity_3_01_unit_type_00_01_value_type_00_01_ownership5351a0fa7c5e44e9399482d760dfd419.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01_quantity_3_01_unit_type_00_01_value_type_00_01_ownership05c8ae73377b5d6ab444cda441ff7b47.html">ResultType&lt; Quantity&lt; UnitType, ValueType, OwnershipPolicy &gt;, Quantity&lt; UnitType2, ValueType2, OwnershipPolicy2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for multiplication of two qt.  <a href="structtfel_1_1math_1_1_result_type_3_01_quantity_3_01_unit_type_00_01_value_type_00_01_ownership05c8ae73377b5d6ab444cda441ff7b47.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01_quantity_3_01_unit_type_00_01_value_type_00_01_ownership73d45feb931368ef50f5532812f46f8d.html">ResultType&lt; Quantity&lt; UnitType, ValueType, OwnershipPolicy &gt;, Quantity&lt; UnitType2, ValueType2, OwnershipPolicy2 &gt;, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for division of two qt.  <a href="structtfel_1_1math_1_1_result_type_3_01_quantity_3_01_unit_type_00_01_value_type_00_01_ownership73d45feb931368ef50f5532812f46f8d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unit_3_01std_1_1integral__constant_3_01int_00_01_n1_01_4_00_01std_1_1inte22245c37637fc2ae3e1f4d95f396757e.html">Unit&lt; std::integral_constant&lt; int, N1 &gt;, std::integral_constant&lt; int, N2 &gt;, std::integral_constant&lt; int, N3 &gt;, std::integral_constant&lt; int, N4 &gt;, std::integral_constant&lt; int, N5 &gt;, std::integral_constant&lt; int, N6 &gt;, std::integral_constant&lt; int, N7 &gt;, std::integral_constant&lt; unsigned int, D1 &gt;, std::integral_constant&lt; unsigned int, D2 &gt;, std::integral_constant&lt; unsigned int, D3 &gt;, std::integral_constant&lt; unsigned int, D4 &gt;, std::integral_constant&lt; unsigned int, D5 &gt;, std::integral_constant&lt; unsigned int, D6 &gt;, std::integral_constant&lt; unsigned int, D7 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runge_kutta2.html">RungeKutta2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_runge_kutta4.html">RungeKutta4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_runge_kutta_solver_base.html">TinyRungeKuttaSolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a base class for a system of ordinary differential equations based on explicit methods of the Runge-Kutta family where the size of the solution is known at compile-time.  <a href="structtfel_1_1math_1_1_tiny_runge_kutta_solver_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runge_kutta42.html">RungeKutta42</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple solver for ordinary differential equations  <a href="structtfel_1_1math_1_1_runge_kutta42.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_runge_kutta54.html">RungeKutta54</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple solver for ordinary differential equations  <a href="structtfel_1_1math_1_1_runge_kutta54.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01runtime__array_3_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; runtime_array&lt; T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_array_tag_00_01_scalar_tag_00_01runti27dae2867f49d231d24f261d2d7e6a6f.html">ComputeBinaryOperationResult&lt; ArrayTag, ScalarTag, runtime_array&lt; T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for <a class="el" href="structtfel_1_1math_1_1runtime__array.html" title="a class representing array of dynamic size.">runtime_array</a> and scalars operations  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_array_tag_00_01_scalar_tag_00_01runti27dae2867f49d231d24f261d2d7e6a6f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_array_tag_00_01_scalar_tag_00_01runtif2eb54209bdc0ccaf8f42fcc5d3ef52d.html">ComputeBinaryOperationResult&lt; ArrayTag, ScalarTag, runtime_array&lt; T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for <a class="el" href="structtfel_1_1math_1_1runtime__array.html" title="a class representing array of dynamic size.">runtime_array</a> and scalars operations  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_array_tag_00_01_scalar_tag_00_01runtif2eb54209bdc0ccaf8f42fcc5d3ef52d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_array_tag_00_01_scal412e58b5774875239a173c03abb28dba.html">ComputeBinaryOperationResult&lt; ScalarTag, ArrayTag, Scal, runtime_array&lt; T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for <a class="el" href="structtfel_1_1math_1_1runtime__array.html" title="a class representing array of dynamic size.">runtime_array</a> and scalars operations  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_array_tag_00_01_scal412e58b5774875239a173c03abb28dba.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01runtime__array_3_01_t_01_4_00_01runtime__array_3_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; runtime_array&lt; T &gt;, runtime_array&lt; T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for <a class="el" href="structtfel_1_1math_1_1runtime__array.html" title="a class representing array of dynamic size.">runtime_array</a>  <a href="classtfel_1_1math_1_1_result_type_3_01runtime__array_3_01_t_01_4_00_01runtime__array_3_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01runtime__array_3_01_t_01_4_00_01runtime__array_3_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; runtime_array&lt; T &gt;, runtime_array&lt; T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for <a class="el" href="structtfel_1_1math_1_1runtime__array.html" title="a class representing array of dynamic size.">runtime_array</a>  <a href="classtfel_1_1math_1_1_result_type_3_01runtime__array_3_01_t_01_4_00_01runtime__array_3_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_scalar_newton_raphson_parameters.html">ScalarNewtonRaphsonParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">structure holding parameters of the <code>scalarNewtonRaphson</code> function.  <a href="structtfel_1_1math_1_1_scalar_newton_raphson_parameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator.html">ConvertLogarithmicStrainTangentOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class used to convert the tangent operator in the logarithmic strain framework into the CSE tangent moduli.  <a href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator_3_011u_00_01stress_01_4.html">ConvertLogarithmicStrainTangentOperator&lt; 1u, stress &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation of the <a class="el" href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator.html" title="A class used to convert the tangent operator in the logarithmic strain framework into the CSE tangent...">ConvertLogarithmicStrainTangentOperator</a> in 1D.  <a href="structtfel_1_1math_1_1_convert_logarithmic_strain_tangent_operator_3_011u_00_01stress_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_t2to_s_t2_to_s_t2to_s_t2_expr.html">ConvertT2toST2ToST2toST2Expr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_convert_t2to_s_t2_to_s_t2to_s_t2_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ConvertT2toST2ToST2toST2Expr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_convert_t2to_s_t2_to_s_t2to_s_t2_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_convert_t2to_s_t2_to_s_t2to_s_t2_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ConvertT2toST2ToST2toST2Expr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_convert_t2to_s_t2_to_s_t2to_s_t2_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_convert_t2to_s_t2_to_s_t2to_s_t2_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ConvertT2toST2ToST2toST2Expr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_convert_t2to_s_t2_to_s_t2to_s_t2_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_tag.html">ST2toST2Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a>.  <a href="structtfel_1_1math_1_1_s_t2to_s_t2_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_concept_base.html">ST2toST2ConceptBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper class that simply exposes publically a member named ConceptTag as an alias to <a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_tag.html" title="Helper class to characterise st2tost2.">ST2toST2Tag</a>.  <a href="structtfel_1_1math_1_1_s_t2to_s_t2_concept_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_s_t2to_s_t2_tag_00_01_t_01_4.html">ConceptRebind&lt; ST2toST2Tag, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for fourth order tensor transforming a symmetric tensor in another symmetric tensor  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_s_t2to_s_t2_tag_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html">ST2toST2TransposeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an expression for the transpose of an object matching the <code>ST2toST2Concept</code> concept.  <a href="structtfel_1_1math_1_1_s_t2to_s_t2_transpose_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_s_t2to_s_t2_tag_00_01_s_t2to_s_t2_tac2f3f962457598ea60a5b9ece9a53b33.html">ComputeBinaryOperationHandler&lt; ST2toST2Tag, ST2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_s_t2to_s_t2_tag_00_01_stensor_tag_009bfd7f59a425528a0fec70e1e51b8432.html">ComputeBinaryOperationHandler&lt; ST2toST2Tag, StensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_stensor_tag_00_01_s_t2to_s_t2_tag_00e488cc06f7fb5b2c28470b40e6a6d2bb.html">ComputeBinaryOperationHandler&lt; StensorTag, ST2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_s_t2to_s_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; ST2toST2Tag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; st2tost2&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_07be38026e325093a472ea73b4daa4b1a.html">ComputeBinaryOperationResult&lt; ST2toST2Tag, ScalarTag, st2tost2&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_07be38026e325093a472ea73b4daa4b1a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_0f97ec9c7530fa4062c07213c05aad90e.html">ComputeBinaryOperationResult&lt; ST2toST2Tag, ScalarTag, st2tost2&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_0f97ec9c7530fa4062c07213c05aad90e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_s_t2to_s_t2_tag_00_03213c007e851119f312b9bce33ceb307.html">ComputeBinaryOperationResult&lt; ScalarTag, ST2toST2Tag, Scal, st2tost2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_s_t2to_s_t2_tag_00_03213c007e851119f312b9bce33ceb307.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, st2tost2&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, st2tost2&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a> and stensor multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01st2tost2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html">ResultType&lt; stensor&lt; N, T2 &gt;, st2tost2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor and <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01st2tost2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, st2tost2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a> and <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_s_t2to_s_t2_product_expr.html">ST2toST2ST2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_s_t2to_s_t2_s_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ST2toST2ST2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_s_t2to_s_t2_s_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ST2toST2ST2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_s_t2to_s_t2_s_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, ST2toST2ST2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_stensor_product_expr.html">ST2toST2StensorProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_s_t2to_s_t2_stensor_product_expr_3_011u_01_4_01_4.html">Expr&lt; StensorResultType, ST2toST2StensorProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_s_t2to_s_t2_stensor_product_expr_3_012u_01_4_01_4.html">Expr&lt; StensorResultType, ST2toST2StensorProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_s_t2to_s_t2_stensor_product_expr_3_013u_01_4_01_4.html">Expr&lt; StensorResultType, ST2toST2StensorProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_square_derivative_expr.html">StensorSquareDerivativeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty structure allowing partial specialisation  <a href="structtfel_1_1math_1_1_stensor_square_derivative_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_stensor_square_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, StensorSquareDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for 1D tensor  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_stensor_square_derivative_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_stensor_square_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, StensorSquareDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for 2D tensor  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_stensor_square_derivative_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_stensor_square_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, StensorSquareDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for 3D tensor  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_stensor_square_derivative_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_s_t2to_s_t2_product_expr.html">StensorST2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_stensor_s_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; StensorResultType, StensorST2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_stensor_s_t2to_s_t2_product_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_stensor_s_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; StensorResultType, StensorST2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_stensor_s_t2to_s_t2_product_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_stensor_s_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; StensorResultType, StensorST2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_stensor_s_t2to_s_t2_product_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_symmetric_product_derivative.html">StensorSymmetricProductDerivative</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_symmetric_product_derivative_3_011u_00_01_t_01_4.html">StensorSymmetricProductDerivative&lt; 1u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_symmetric_product_derivative_3_012u_00_01_t_01_4.html">StensorSymmetricProductDerivative&lt; 2u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_symmetric_product_derivative_3_013u_00_01_t_01_4.html">StensorSymmetricProductDerivative&lt; 3u, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html">UmatNormaliseTangentOperatorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalise the tangent operator returned by:  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_011u_00_01stress_01_4.html">UmatNormaliseTangentOperatorBase&lt; 1u, stress &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html" title="normalise the tangent operator returned by:">UmatNormaliseTangentOperatorBase</a></code> class in 1D.  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_011u_00_01stress_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_012u_00_01stress_01_4.html">UmatNormaliseTangentOperatorBase&lt; 2u, stress &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html" title="normalise the tangent operator returned by:">UmatNormaliseTangentOperatorBase</a></code> class in 1D  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_012u_00_01stress_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_013u_00_01stress_01_4.html">UmatNormaliseTangentOperatorBase&lt; 3u, stress &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base.html" title="normalise the tangent operator returned by:">UmatNormaliseTangentOperatorBase</a></code> class in 1D  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator_base_3_013u_00_01stress_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_umat_normalise_tangent_operator.html">UmatNormaliseTangentOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalise the tangent operator returned by:  <a href="structtfel_1_1math_1_1_umat_normalise_tangent_operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_left_derivative_expr.html">StensorProductLeftDerivativeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty structure allowing partial specialisation  <a href="structtfel_1_1math_1_1_stensor_product_left_derivative_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_right_derivative_expr.html">StensorProductRightDerivativeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty structure allowing partial specialisation of the <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation.">Expr</a> class  <a href="structtfel_1_1math_1_1_stensor_product_right_derivative_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_01_s_6f1e10b8bec3f38241e926e629d9873c.html">DerivativeTypeDispatcher&lt; ST2toST2Tag, ScalarTag, ST2toST2Type, ScalarType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_s_t2to_s_t2_tag_00_01_scalar_tag_00_01_s_6f1e10b8bec3f38241e926e629d9873c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_s_t2to_s_t2_tag_00_01_sc46506b47b278b886b4424c3100012372.html">DerivativeTypeDispatcher&lt; ScalarTag, ST2toST2Tag, ScalarType, ST2toST2Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_s_t2to_s_t2_tag_00_01_sc46506b47b278b886b4424c3100012372.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_stensor_tag_00_01_stensor_tag_00_01_stense15cf9bcc0b986936608266484ef659e.html">DerivativeTypeDispatcher&lt; StensorTag, StensorTag, StensorType1, StensorType2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_stensor_tag_00_01_stensor_tag_00_01_stense15cf9bcc0b986936608266484ef659e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_tag.html">ST2toT2Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>.  <a href="structtfel_1_1math_1_1_s_t2to_t2_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_concept_base.html">ST2toT2ConceptBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper class that simply exposes publically a member named ConceptTag as an alias to <a class="el" href="structtfel_1_1math_1_1_t2to_t2_tag.html" title="Helper class to characterise t2tot2.">T2toT2Tag</a>.  <a href="structtfel_1_1math_1_1_s_t2to_t2_concept_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_s_t2to_t2_tag_00_01_type_01_4.html">ConceptRebind&lt; ST2toT2Tag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for fourth order tensor  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_s_t2to_t2_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_tensor_tag_00_01_stensor_tag_00_01_aa0c82e0d4b57baf61505588f23085f04.html">ComputeBinaryOperationHandler&lt; TensorTag, StensorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_t2to_t2_tag_00_01_s_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; T2toT2Tag, ST2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_s_t2to_t2_tag_00_01_t2to_s_t2_tag_0089d52c17348aea6b145943af82c8307c.html">ComputeBinaryOperationHandler&lt; ST2toT2Tag, T2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_s_t2to_t2_tag_00_01_s_t2to_s_t2_tag_b074d4dc545bfc3bb1206770c33788cd.html">ComputeBinaryOperationHandler&lt; ST2toT2Tag, ST2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_t2to_s_t2_tag_00_01_s_t2to_t2_tag_0065665ac7f76665df85e12e4096d995ea.html">ComputeBinaryOperationHandler&lt; T2toST2Tag, ST2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_s_t2to_t2_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; ST2toT2Tag, StensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_tensor_tag_00_01_s_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; TensorTag, ST2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_s_t2to_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; ST2toT2Tag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; st2tot2&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01s3e2b1fe7668766ff60d37cc49d1e28d4.html">ComputeBinaryOperationResult&lt; ST2toT2Tag, ScalarTag, st2tot2&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01s3e2b1fe7668766ff60d37cc49d1e28d4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01s86e34c9e67f9ee8bf5162c1a1264cd96.html">ComputeBinaryOperationResult&lt; ST2toT2Tag, ScalarTag, st2tot2&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01s86e34c9e67f9ee8bf5162c1a1264cd96.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_s_t2to_t2_tag_00_01_7949a941f71eaa64430bc43462903681.html">ComputeBinaryOperationResult&lt; ScalarTag, ST2toT2Tag, Scal, st2tot2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_s_t2to_t2_tag_00_01_7949a941f71eaa64430bc43462903681.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, st2tot2&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, st2tot2&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, st2tot2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, t2tost2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01st2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, st2tost2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01st2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, st2tot2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tot2&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> and stensor multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tot2_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t2_01_4_00_01st2tot2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html">ResultType&lt; tensor&lt; N, T2 &gt;, st2tot2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t2_01_4_00_01st2tot2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_s_t2to_s_t2_product_expr.html">ST2toT2ST2toST2ProductExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty structure used for partial specialisation of the <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation.">Expr</a> class  <a href="structtfel_1_1math_1_1_s_t2to_t2_s_t2to_s_t2_product_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_s_t2to_t2_s_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, ST2toT2ST2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_s_t2to_t2_s_t2to_s_t2_product_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_s_t2to_t2_s_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, ST2toT2ST2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_s_t2to_t2_s_t2to_s_t2_product_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_s_t2to_t2_s_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, ST2toT2ST2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_s_t2to_t2_s_t2to_s_t2_product_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_stensor_product_expr.html">ST2toT2StensorProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_s_t2to_t2_stensor_product_expr_3_011u_01_4_01_4.html">Expr&lt; TensorResultType, ST2toT2StensorProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_s_t2to_t2_stensor_product_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_s_t2to_t2_stensor_product_expr_3_012u_01_4_01_4.html">Expr&lt; TensorResultType, ST2toT2StensorProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_s_t2to_t2_stensor_product_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_s_t2to_t2_stensor_product_expr_3_013u_01_4_01_4.html">Expr&lt; TensorResultType, ST2toT2StensorProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_s_t2to_t2_stensor_product_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_t2to_s_t2_product_expr.html">ST2toT2T2toST2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_s_t2to_t2_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; T2toT2ResultType, ST2toT2T2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_s_t2to_t2_t2to_s_t2_product_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_s_t2to_t2_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; T2toT2ResultType, ST2toT2T2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_s_t2to_t2_t2to_s_t2_product_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_s_t2to_t2_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; T2toT2ResultType, ST2toT2T2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_s_t2to_t2_t2to_s_t2_product_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_left_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductLeftDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_left_derivative_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_left_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductLeftDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_left_derivative_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_left_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductLeftDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_left_derivative_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_right_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductRightDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_right_derivative_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_right_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductRightDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_right_derivative_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_right_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, StensorProductRightDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_stensor_product_right_derivative_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_s_t2to_t2_product_expr.html">T2toST2ST2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_t2to_s_t2_s_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, T2toST2ST2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_t2to_s_t2_s_t2to_t2_product_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_t2to_s_t2_s_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, T2toST2ST2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_t2to_s_t2_s_t2to_t2_product_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_t2to_s_t2_s_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toST2ResultType, T2toST2ST2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_s_t2_result_type_00_01_t2to_s_t2_s_t2to_t2_product_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_s_t2to_t2_product_expr.html">T2toT2ST2toT2ProductExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty structure used for partial specialisation of the <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation.">Expr</a> class  <a href="structtfel_1_1math_1_1_t2to_t2_s_t2to_t2_product_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_t2to_t2_s_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, T2toT2ST2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_t2to_t2_s_t2to_t2_product_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_t2to_t2_s_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, T2toT2ST2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_t2to_t2_s_t2to_t2_product_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_t2to_t2_s_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; ST2toT2ResultType, T2toT2ST2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_expr_3_01_s_t2to_t2_result_type_00_01_t2to_t2_s_t2to_t2_product_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_s_t2to_t2_product_expr.html">TensorST2toT2ProductExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty structure used for partial specialisation of the <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation.">Expr</a> class  <a href="structtfel_1_1math_1_1_tensor_s_t2to_t2_product_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_tensor_s_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; StensorResultType, TensorST2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_tensor_s_t2to_t2_product_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_tensor_s_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; StensorResultType, TensorST2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_tensor_s_t2to_t2_product_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_tensor_s_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; StensorResultType, TensorST2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_tensor_s_t2to_t2_product_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01_s_t26b1adfc3d7be39b73bf7090f41b3f787.html">DerivativeTypeDispatcher&lt; ST2toT2Tag, ScalarTag, ST2toT2Type, ScalarType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_s_t2to_t2_tag_00_01_scalar_tag_00_01_s_t26b1adfc3d7be39b73bf7090f41b3f787.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_s_t2to_t2_tag_00_01_scalfd44843b1dcd7856fccbe3c1f5f48d65.html">DerivativeTypeDispatcher&lt; ScalarTag, ST2toT2Tag, ScalarType, ST2toT2Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_s_t2to_t2_tag_00_01_scalfd44843b1dcd7856fccbe3c1f5f48d65.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_tensor_tag_00_01_stensor_tag_00_01_tensor_type1_00_01_stensor_type2_01_4.html">DerivativeTypeDispatcher&lt; TensorTag, StensorTag, TensorType1, StensorType2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_tensor_tag_00_01_stensor_tag_00_01_tensor_type1_00_01_stensor_type2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_tag.html">StensorTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise stensors.  <a href="structtfel_1_1math_1_1_stensor_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_concept_base.html">StensorConceptBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper class that simply exposes publically a member named ConceptTag as an alias to <a class="el" href="structtfel_1_1math_1_1_stensor_tag.html" title="Helper class to characterise stensors.">StensorTag</a>.  <a href="structtfel_1_1math_1_1_stensor_concept_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_stensor_tag_00_01_type_01_4.html">ConceptRebind&lt; StensorTag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for symmetric tensors  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_stensor_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_stensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; StensorTag, StensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_stensor_tag_00_01_stensor_tag_00_01_1c1804db710226c7d276c7c797161fee.html">ComputeBinaryOperationHandler&lt; StensorTag, StensorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_stensor_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; StensorTag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_stensor_tag_00_01_stensor_tag_00_01_69d7b204739205d1ae55c94e52025d3c.html">ComputeBinaryOperationHandler&lt; StensorTag, StensorTag, A, B, OpDotProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_stensor_product_expr_base.html">StensorProductExprBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_expr1_d.html">StensorProductExpr1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_expr2_d.html">StensorProductExpr2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_product_expr3_d.html">StensorProductExpr3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; stensor&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_stensor_tag_00_01_scalar_tag_00_01stef69c3cbb1bbd39397af38164d667bf7d.html">ComputeBinaryOperationResult&lt; StensorTag, ScalarTag, stensor&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_stensor_tag_00_01_scalar_tag_00_01stef69c3cbb1bbd39397af38164d667bf7d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_stensor_tag_00_01_scalar_tag_00_01ste061f9df886458ba890963cd318d3f26e.html">ComputeBinaryOperationResult&lt; StensorTag, ScalarTag, stensor&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_stensor_tag_00_01_scalar_tag_00_01ste061f9df886458ba890963cd318d3f26e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_stensor_tag_00_01_sc42251c117974b83bfa4e0496930ed535.html">ComputeBinaryOperationResult&lt; ScalarTag, StensorTag, Scal, stensor&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_stensor_tag_00_01_sc42251c117974b83bfa4e0496930ed535.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_0b335bb17f35cb9beb6dc8e4321e2e831.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_0b335bb17f35cb9beb6dc8e4321e2e831.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpDotProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_stensor_tag_00_01_scalar_tag_00_01_stensor_type_00_01_scalar_type_01_4.html">DerivativeTypeDispatcher&lt; StensorTag, ScalarTag, StensorType, ScalarType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_stensor_tag_00_01_scalar_tag_00_01_stensor_type_00_01_scalar_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_stensor_tag_00_01_scalar_type_00_01_stensor_type_01_4.html">DerivativeTypeDispatcher&lt; ScalarTag, StensorTag, ScalarType, StensorType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_stensor_tag_00_01_scalar_type_00_01_stensor_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1stensor__common.html">stensor_common</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper structure inherited by the <code>stensor</code> class  <a href="structtfel_1_1math_1_1stensor__common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative.html">ConvertKirchhoffStressJaumanRateModuliToKirchhoffStressDerivative</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_011u_00_01_t_01_4.html">ConvertKirchhoffStressJaumanRateModuliToKirchhoffStressDerivative&lt; 1u, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_011u_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_012u_00_01_t_01_4.html">ConvertKirchhoffStressJaumanRateModuliToKirchhoffStressDerivative&lt; 2u, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_012u_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_013u_00_01_t_01_4.html">ConvertKirchhoffStressJaumanRateModuliToKirchhoffStressDerivative&lt; 3u, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_convert_kirchhoff_stress_jauman_rate_moduli_to_kirchhoff_stress_derivative_3_013u_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_left_cauchy_green_tensor_derivative_expr.html">LeftCauchyGreenTensorDerivativeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declaration  <a href="structtfel_1_1math_1_1_left_cauchy_green_tensor_derivative_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_left_cauchy_green_tensor_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; T2toST2Type, LeftCauchyGreenTensorDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_left_cauchy_green_tensor_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; T2toST2Type, LeftCauchyGreenTensorDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_left_cauchy_green_tensor_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; T2toST2Type, LeftCauchyGreenTensorDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_right_cauchy_green_tensor_derivative_expr.html">RightCauchyGreenTensorDerivativeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declaration  <a href="structtfel_1_1math_1_1_right_cauchy_green_tensor_derivative_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_right_cauchy_green_tensor_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; T2toST2Type, RightCauchyGreenTensorDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_right_cauchy_green_tensor_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; T2toST2Type, RightCauchyGreenTensorDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_type_00_01_right_cauchy_green_tensor_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; T2toST2Type, RightCauchyGreenTensorDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_t2to_s_t2_product_expr.html">ST2toST2T2toST2ProductExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty structure used for partial specialisation of the <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation.">Expr</a> class  <a href="structtfel_1_1math_1_1_s_t2to_s_t2_t2to_s_t2_product_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_s_t2to_s_t2_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; T2toST2ResultType, ST2toST2T2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_s_t2to_s_t2_t2to_s_t2_product_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_s_t2to_s_t2_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; T2toST2ResultType, ST2toST2T2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_s_t2to_s_t2_t2to_s_t2_product_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_s_t2to_s_t2_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; T2toST2ResultType, ST2toST2T2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_s_t2to_s_t2_t2to_s_t2_product_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stensor_t2to_s_t2_product_expr.html">StensorT2toST2ProductExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty structure used for partial specialisation of the <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation.">Expr</a> class  <a href="structtfel_1_1math_1_1_stensor_t2to_s_t2_product_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_stensor_t2to_s_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; TensorResultType, StensorT2toST2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_stensor_t2to_s_t2_product_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_stensor_t2to_s_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; TensorResultType, StensorT2toST2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_stensor_t2to_s_t2_product_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_stensor_t2to_s_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; TensorResultType, StensorT2toST2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_stensor_t2to_s_t2_product_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_tag.html">T2toST2Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a>.  <a href="structtfel_1_1math_1_1_t2to_s_t2_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_concept_base.html">T2toST2ConceptBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper class that simply exposes publically a member named ConceptTag as an alias to <a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_tag.html" title="Helper class to characterise t2tost2.">T2toST2Tag</a>.  <a href="structtfel_1_1math_1_1_t2to_s_t2_concept_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_t2to_s_t2_tag_00_01_type_01_4.html">ConceptRebind&lt; T2toST2Tag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for T2toST2  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_t2to_s_t2_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_s_t2to_s_t2_tag_00_01_t2to_s_t2_tag_7c957d95ca76c0b3c4cbe39723618daa.html">ComputeBinaryOperationHandler&lt; ST2toST2Tag, T2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_t2to_s_t2_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; T2toST2Tag, T2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_stensor_tag_00_01_tensor_tag_00_01_af3aaf2e4245c28f4921ce28e8c90e16e.html">ComputeBinaryOperationHandler&lt; StensorTag, TensorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_t2to_s_t2_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; T2toST2Tag, TensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_stensor_tag_00_01_t2to_s_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; StensorTag, T2toST2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_t2to_s_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; T2toST2Tag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; t2tost2&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01t2fb2ba94879f19c5d5d0aba431d14140.html">ComputeBinaryOperationResult&lt; T2toST2Tag, ScalarTag, t2tost2&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01t2fb2ba94879f19c5d5d0aba431d14140.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01teb59fcc98ac285a434e059bf4c78ba04.html">ComputeBinaryOperationResult&lt; T2toST2Tag, ScalarTag, t2tost2&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01teb59fcc98ac285a434e059bf4c78ba04.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_t2to_s_t2_tag_00_01_960f43b0c483e494c91bdc6dcf18f294.html">ComputeBinaryOperationResult&lt; ScalarTag, T2toST2Tag, Scal, t2tost2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_t2to_s_t2_tag_00_01_960f43b0c483e494c91bdc6dcf18f294.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, t2tost2&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, t2tost2&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for stensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; st2tost2&lt; N, T &gt;, t2tost2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a> and <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01st2tost2_3_01_n_00_01_t_01_4_00_01t2tost2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, t2tot2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a> and <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tost2&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a> and tensor multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tost2_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01t2tost2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html">ResultType&lt; stensor&lt; N, T2 &gt;, t2tost2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01t2tost2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_t2to_t2_product_expr.html">T2toST2T2toT2ProductExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty structure used for partial specialisation of the <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation.">Expr</a> class  <a href="structtfel_1_1math_1_1_t2to_s_t2_t2to_t2_product_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_t2to_s_t2_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; T2toST2ResultType, T2toST2T2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_t2to_s_t2_t2to_t2_product_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_t2to_s_t2_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; T2toST2ResultType, T2toST2T2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_t2to_s_t2_t2to_t2_product_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_t2to_s_t2_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; T2toST2ResultType, T2toST2T2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 3D  <a href="structtfel_1_1math_1_1_expr_3_01_t2to_s_t2_result_type_00_01_t2to_s_t2_t2to_t2_product_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_tensor_product_expr.html">T2toST2TensorProductExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">empty structure used for partial specialisation of the <a class="el" href="structtfel_1_1math_1_1_expr.html" title="an Expr object allows the lazy evaluation of a mathematical operation.">Expr</a> class  <a href="structtfel_1_1math_1_1_t2to_s_t2_tensor_product_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_t2to_s_t2_tensor_product_expr_3_011u_01_4_01_4.html">Expr&lt; StensorResultType, T2toST2TensorProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 1D  <a href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_t2to_s_t2_tensor_product_expr_3_011u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_t2to_s_t2_tensor_product_expr_3_012u_01_4_01_4.html">Expr&lt; StensorResultType, T2toST2TensorProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_t2to_s_t2_tensor_product_expr_3_012u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_t2to_s_t2_tensor_product_expr_3_013u_01_4_01_4.html">Expr&lt; StensorResultType, T2toST2TensorProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation in 2D  <a href="structtfel_1_1math_1_1_expr_3_01_stensor_result_type_00_01_t2to_s_t2_tensor_product_expr_3_013u_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01_t2toe74a9e36bbc8281581b1eafb90335560.html">DerivativeTypeDispatcher&lt; T2toST2Tag, ScalarTag, T2toST2Type, ScalarType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_t2to_s_t2_tag_00_01_scalar_tag_00_01_t2toe74a9e36bbc8281581b1eafb90335560.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_t2to_s_t2_tag_00_01_scal8074e4972ba4336023ea82c6aa077c6d.html">DerivativeTypeDispatcher&lt; ScalarTag, T2toST2Tag, ScalarType, T2toST2Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_t2to_s_t2_tag_00_01_scal8074e4972ba4336023ea82c6aa077c6d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_stensor_tag_00_01_tensor_tag_00_01_stensor_type1_00_01_tensor_type2_01_4.html">DerivativeTypeDispatcher&lt; StensorTag, TensorTag, StensorType1, TensorType2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_stensor_tag_00_01_tensor_tag_00_01_stensor_type1_00_01_tensor_type2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_tag.html">T2toT2Tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>.  <a href="structtfel_1_1math_1_1_t2to_t2_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_concept_base.html">T2toT2ConceptBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper class that simply exposes publically a member named ConceptTag as an alias to <a class="el" href="structtfel_1_1math_1_1_t2to_t2_tag.html" title="Helper class to characterise t2tot2.">T2toT2Tag</a>.  <a href="structtfel_1_1math_1_1_t2to_t2_concept_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_t2to_t2_tag_00_01_type_01_4.html">ConceptRebind&lt; T2toT2Tag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for fourth order tensor  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_t2to_t2_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_t2to_t2_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; T2toT2Tag, T2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryOperationHandler</a> for T2toT2-T2toT2 operations  <a href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_t2to_t2_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_t2to_t2_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; T2toT2Tag, TensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <a class="el" href="structtfel_1_1math_1_1_compute_binary_operation_handler.html" title="A helper class for ComputeBinaryResult. This default version returns InvalidType both for Result and ...">ComputeBinaryOperationHandler</a> for T2toT2-Tensor operations  <a href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_t2to_t2_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_tensor_tag_00_01_t2to_t2_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; TensorTag, T2toT2Tag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_t2to_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; T2toT2Tag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <code><a class="el" href="structtfel_1_1math_1_1_compute_unary_result__.html">ComputeUnaryResult_</a></code> for <code>T2toT2</code>'s object  <a href="structtfel_1_1math_1_1_compute_unary_result___3_01_t2to_t2_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; t2tot2&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_t2to_t2_tag_00_01_scalar_tag_00_01t2te3a4759f3ddf31589b00c3c24187e041.html">ComputeBinaryOperationResult&lt; T2toT2Tag, ScalarTag, t2tot2&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_t2to_t2_tag_00_01_scalar_tag_00_01t2te3a4759f3ddf31589b00c3c24187e041.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_t2to_t2_tag_00_01_scalar_tag_00_01t2t578521f520c220f2dfe93c0451dd1364.html">ComputeBinaryOperationResult&lt; T2toT2Tag, ScalarTag, t2tot2&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_t2to_t2_tag_00_01_scalar_tag_00_01t2t578521f520c220f2dfe93c0451dd1364.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_t2to_t2_tag_00_01_sc89e98f5a3bec8ba9d9e71135b9e4d3ce.html">ComputeBinaryOperationResult&lt; ScalarTag, T2toT2Tag, Scal, t2tot2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_t2to_t2_tag_00_01_sc89e98f5a3bec8ba9d9e71135b9e4d3ce.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, t2tot2&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, t2tot2&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and tensor multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t2_01_4_00_01t2tot2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html">ResultType&lt; tensor&lt; N, T2 &gt;, t2tot2&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t2_01_4_00_01t2tot2_3_01_n_00_01_t_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; t2tot2&lt; N, T &gt;, t2tot2&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> and <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> multiplication.  <a href="classtfel_1_1math_1_1_result_type_3_01t2tot2_3_01_n_00_01_t_01_4_00_01t2tot2_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_t2to_t2_product_expr.html">T2toT2T2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_t2to_t2_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; T2toT2ResultType, T2toT2T2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_t2to_t2_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; T2toT2ResultType, T2toT2T2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_t2to_t2_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; T2toT2ResultType, T2toT2T2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_t2to_t2_tensor_product_expr.html">T2toT2TensorProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_t2to_t2_tensor_product_expr_3_011u_01_4_01_4.html">Expr&lt; TensorResultType, T2toT2TensorProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_t2to_t2_tensor_product_expr_3_012u_01_4_01_4.html">Expr&lt; TensorResultType, T2toT2TensorProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_t2to_t2_tensor_product_expr_3_013u_01_4_01_4.html">Expr&lt; TensorResultType, T2toT2TensorProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_left_derivative_expr.html">TensorProductLeftDerivativeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_left_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductLeftDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_left_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductLeftDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_left_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductLeftDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_right_derivative_expr.html">TensorProductRightDerivativeExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_right_derivative_expr_3_011u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductRightDerivativeExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_right_derivative_expr_3_012u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductRightDerivativeExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_t2to_t2_result_type_00_01_tensor_product_right_derivative_expr_3_013u_01_4_01_4.html">Expr&lt; T2toT2ResultType, TensorProductRightDerivativeExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_t2to_t2_product_expr.html">TensorT2toT2ProductExpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_tensor_t2to_t2_product_expr_3_011u_01_4_01_4.html">Expr&lt; TensorResultType, TensorT2toT2ProductExpr&lt; 1u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_tensor_t2to_t2_product_expr_3_012u_01_4_01_4.html">Expr&lt; TensorResultType, TensorT2toT2ProductExpr&lt; 2u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01_tensor_result_type_00_01_tensor_t2to_t2_product_expr_3_013u_01_4_01_4.html">Expr&lt; TensorResultType, TensorT2toT2ProductExpr&lt; 3u &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_t2to_t2_tag_00_01_scalar_tag_00_01_t2to_t2_type_00_01_scalar_type_01_4.html">DerivativeTypeDispatcher&lt; T2toT2Tag, ScalarTag, T2toT2Type, ScalarType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_t2to_t2_tag_00_01_scalar_tag_00_01_t2to_t2_type_00_01_scalar_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_t2to_t2_tag_00_01_scalar_type_00_01_t2to_t2_type_01_4.html">DerivativeTypeDispatcher&lt; ScalarTag, T2toT2Tag, ScalarType, T2toT2Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_t2to_t2_tag_00_01_scalar_type_00_01_t2to_t2_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_tensor_tag_00_01_tensor_tag_00_01_tensor_type1_00_01_tensor_type2_01_4.html">DerivativeTypeDispatcher&lt; TensorTag, TensorTag, TensorType1, TensorType2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_tensor_tag_00_01_tensor_tag_00_01_tensor_type1_00_01_tensor_type2_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_matrix_view_from_tensor_expr.html">MatrixViewFromTensorExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">forward declaration  <a href="structtfel_1_1math_1_1_matrix_view_from_tensor_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tmatrix_3_013u_00_013u_00_01numeric__type_3_01_tensor_type_01_4_0dbb3e0acd2a635f8343ce465cee3a2d.html">Expr&lt; tmatrix&lt; 3u, 3u, numeric_type&lt; TensorType &gt; &gt;, MatrixViewFromTensorExpr&lt; TensorType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_tag.html">TensorTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper class to characterize tensors.  <a href="structtfel_1_1math_1_1_tensor_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_invalid_index_exception.html">TensorInvalidIndexException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception thrown if invalid index is given  <a href="structtfel_1_1math_1_1_tensor_invalid_index_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_invalid_indexes_exception.html">TensorInvalidIndexesException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception thrown if invalid indexes were given  <a href="structtfel_1_1math_1_1_tensor_invalid_indexes_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_invalid_initializer_list_size_exception.html">TensorInvalidInitializerListSizeException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">exception thrown if an std::initializer_list with no appropriate size is affected to a tensor.  <a href="structtfel_1_1math_1_1_tensor_invalid_initializer_list_size_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_concept_base.html">TensorConceptBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base class which implements the tensor concept  <a href="structtfel_1_1math_1_1_tensor_concept_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_tensor_tag_00_01_type_01_4.html">ConceptRebind&lt; TensorTag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for tensors  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_tensor_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_tensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; TensorTag, TensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_tensor_tag_00_01_tensor_tag_00_01_a_fb7968297c609df9f6bd008aa6515055.html">ComputeBinaryOperationHandler&lt; TensorTag, TensorTag, A, B, OpDotProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_tensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryOperationHandler&lt; TensorTag, StensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_stensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_01_4.html">ComputeBinaryOperationHandler&lt; StensorTag, TensorTag, A, B, Op &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_tensor_tag_00_01_stensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; TensorTag, StensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_stensor_tag_00_01_tensor_tag_00_01_a_00_01_b_00_01_op_mult_01_4.html">ComputeBinaryOperationHandler&lt; StensorTag, TensorTag, A, B, OpMult &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_tensor_tag_00_01_tensor_tag_00_01_a_e3271876e32c9c40fb30e66bde7b2504.html">ComputeBinaryOperationHandler&lt; TensorTag, TensorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_compute_unary_result___3_01_tensor_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; TensorTag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_expr_base.html">TensorProductExprBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_expr1_d.html">TensorProductExpr1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_expr2_d.html">TensorProductExpr2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_product_expr3_d.html">TensorProductExpr3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_unary_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; tensor&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_tensor_tag_00_01_scalar_tag_00_01tens7d7bf1ff90455e1fead19231289de24d.html">ComputeBinaryOperationResult&lt; TensorTag, ScalarTag, tensor&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_tensor_tag_00_01_scalar_tag_00_01tens7d7bf1ff90455e1fead19231289de24d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_tensor_tag_00_01_scalar_tag_00_01tens6d25d6270a86d768820fab315999b845.html">ComputeBinaryOperationResult&lt; TensorTag, ScalarTag, tensor&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_tensor_tag_00_01_scalar_tag_00_01tens6d25d6270a86d768820fab315999b845.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_tensor_tag_00_01_sca68d0623f0af2a1f355292d532c8c1119.html">ComputeBinaryOperationResult&lt; ScalarTag, TensorTag, Scal, tensor&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_tensor_tag_00_01_sca68d0623f0af2a1f355292d532c8c1119.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; stensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_diadic_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01tensor_3_01_n_00_01_t_01_4_00_01_op_plus_01_4.html">ResultType&lt; stensor&lt; N, T2 &gt;, tensor&lt; N, T &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01tensor_3_01_n_00_01_t_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, stensor&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01stensor_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01tensor_3_01_n_00_01_t_01_4_00_01_op_minus_01_4.html">ResultType&lt; stensor&lt; N, T2 &gt;, tensor&lt; N, T &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01stensor_3_01_n_00_01_t2_01_4_00_01tensor_3_01_n_00_01_t_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html">ResultType&lt; tensor&lt; N, T &gt;, tensor&lt; N, T2 &gt;, OpDotProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tensor.  <a href="classtfel_1_1math_1_1_result_type_3_01tensor_3_01_n_00_01_t_01_4_00_01tensor_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_transpose_expr_base.html">TensorTransposeExprBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_transpose_expr1_d.html">TensorTransposeExpr1D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_transpose_expr2_d.html">TensorTransposeExpr2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_transpose_expr3_d.html">TensorTransposeExpr3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_view_from_stensor_expr.html">TensorViewFromStensorExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">tensor view from a symmetric tensor  <a href="structtfel_1_1math_1_1_tensor_view_from_stensor_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_expr_3_01tensor_3_01_n_00_01_value_type_01_4_00_01_tensor_view_from_stensor_expr_3_01_t_01_4_01_4.html">Expr&lt; tensor&lt; N, ValueType &gt;, TensorViewFromStensorExpr&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tensor_view_from_stensor.html">TensorViewFromStensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_tensor_tag_00_01_scalar_tag_00_01_tensor_type_00_01_scalar_type_01_4.html">DerivativeTypeDispatcher&lt; TensorTag, ScalarTag, TensorType, ScalarType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_tensor_tag_00_01_scalar_tag_00_01_tensor_type_00_01_scalar_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_tensor_tag_00_01_scalar_type_00_01_tensor_type_01_4.html">DerivativeTypeDispatcher&lt; ScalarTag, TensorTag, ScalarType, TensorType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_tensor_tag_00_01_scalar_type_00_01_tensor_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stack_allocated_tiny_broyden2_solver_workspace.html">StackAllocatedTinyBroyden2SolverWorkspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class allocating on the stack a workspace usable by the <code>TinyBroydenSolver2</code> class.  <a href="structtfel_1_1math_1_1_stack_allocated_tiny_broyden2_solver_workspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_broyden2_solver.html">TinyBroyden2Solver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class based on the curiously recurring template pattern (CRTP) to solve system of non linear equations using the second Broyden algorithm.  <a href="structtfel_1_1math_1_1_tiny_broyden2_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stack_allocated_tiny_broyden_solver_workspace.html">StackAllocatedTinyBroydenSolverWorkspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class allocating on the stack a workspace usable by the <code><a class="el" href="structtfel_1_1math_1_1_tiny_broyden_solver.html" title="A class based on the curiously recurring template pattern (CRTP) to solve system of non linear equati...">TinyBroydenSolver</a></code> class.  <a href="structtfel_1_1math_1_1_stack_allocated_tiny_broyden_solver_workspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_broyden_solver.html">TinyBroydenSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class based on the curiously recurring template pattern (CRTP) to solve system of non linear equations using the Broyden algorithm.  <a href="structtfel_1_1math_1_1_tiny_broyden_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stack_allocated_tiny_levenberg_marquardt_solver_workspace.html">StackAllocatedTinyLevenbergMarquardtSolverWorkspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class allocating on the stack a workspace usable by the <code><a class="el" href="structtfel_1_1math_1_1_tiny_levenberg_marquardt_solver.html" title="A class based on the curiously recurring template pattern (CRTP) to solve system of non linear equati...">TinyLevenbergMarquardtSolver</a></code> class.  <a href="structtfel_1_1math_1_1_stack_allocated_tiny_levenberg_marquardt_solver_workspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_levenberg_marquardt_solver.html">TinyLevenbergMarquardtSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class based on the curiously recurring template pattern (CRTP) to solve system of non linear equations using the Newton-Raphson algorithm.  <a href="structtfel_1_1math_1_1_tiny_levenberg_marquardt_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_invert.html">TinyMatrixInvert</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve_base.html">TinyMatrixSolveBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve.html">TinyMatrixSolve</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve_3_011u_00_01_t_00_01use__exceptions_00_01perform__runtime__checks_01_4.html">TinyMatrixSolve&lt; 1u, T, use_exceptions, perform_runtime_checks &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve_3_012u_00_01_t_00_01use__exceptions_00_01perform__runtime__checks_01_4.html">TinyMatrixSolve&lt; 2u, T, use_exceptions, perform_runtime_checks &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_matrix_solve_3_013u_00_01_t_00_01use__exceptions_00_01perform__runtime__checks_01_4.html">TinyMatrixSolve&lt; 3u, T, use_exceptions, perform_runtime_checks &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stack_allocated_tiny_newton_raphson_solver_workspace.html">StackAllocatedTinyNewtonRaphsonSolverWorkspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class allocating on the stack a workspace usable by the <code><a class="el" href="structtfel_1_1math_1_1_tiny_newton_raphson_solver.html" title="A class based on the curiously recurring template pattern (CRTP) to solve system of non linear equati...">TinyNewtonRaphsonSolver</a></code> class.  <a href="structtfel_1_1math_1_1_stack_allocated_tiny_newton_raphson_solver_workspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_newton_raphson_solver.html">TinyNewtonRaphsonSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class based on the curiously recurring template pattern (CRTP) to solve system of non linear equations using the Newton-Raphson algorithm.  <a href="structtfel_1_1math_1_1_tiny_newton_raphson_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stack_allocated_tiny_powell_dog_leg_broyden_solver_workspace.html">StackAllocatedTinyPowellDogLegBroydenSolverWorkspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class allocating on the stack a workspace usable by the <code><a class="el" href="structtfel_1_1math_1_1_tiny_powell_dog_leg_broyden_solver.html" title="A class based on the curiously recurring template pattern (CRTP) to solve system of non linear equati...">TinyPowellDogLegBroydenSolver</a></code> class.  <a href="structtfel_1_1math_1_1_stack_allocated_tiny_powell_dog_leg_broyden_solver_workspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_powell_dog_leg_broyden_solver.html">TinyPowellDogLegBroydenSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class based on the curiously recurring template pattern (CRTP) to solve system of non linear equations using the Newton-Raphson algorithm coupled with the Powell' dog leg algorithm.  <a href="structtfel_1_1math_1_1_tiny_powell_dog_leg_broyden_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_stack_allocated_tiny_powell_dog_leg_newton_raphson_solver_workspace.html">StackAllocatedTinyPowellDogLegNewtonRaphsonSolverWorkspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class allocating on the stack a workspace usable by the <code><a class="el" href="structtfel_1_1math_1_1_tiny_powell_dog_leg_newton_raphson_solver.html" title="A class based on the curiously recurring template pattern (CRTP) to solve system of non linear equati...">TinyPowellDogLegNewtonRaphsonSolver</a></code> class.  <a href="structtfel_1_1math_1_1_stack_allocated_tiny_powell_dog_leg_newton_raphson_solver_workspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_tiny_powell_dog_leg_newton_raphson_solver.html">TinyPowellDogLegNewtonRaphsonSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class based on the curiously recurring template pattern (CRTP) to solve system of non linear equations using the Newton-Raphson algorithm coupled with the Powell' dog leg algorithm.  <a href="structtfel_1_1math_1_1_tiny_powell_dog_leg_newton_raphson_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_matrix_tag_00_01_scalar_tag_00_01tmatrix_9c0deb987762f79ef485bf0cb61816fc.html">DerivativeTypeDispatcher&lt; MatrixTag, ScalarTag, tmatrix&lt; N, M, TMatrixNumericType &gt;, ScalarType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_matrix_tag_00_01_scalar_tag_00_01tmatrix_9c0deb987762f79ef485bf0cb61816fc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_matrix_tag_00_01_scalar_55980c9d9faf234cad9c9d1d524ba52e.html">DerivativeTypeDispatcher&lt; ScalarTag, MatrixTag, ScalarType, tmatrix&lt; N, M, TMatrixNumericType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_matrix_tag_00_01_scalar_55980c9d9faf234cad9c9d1d524ba52e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_vector_tag_00_01_vector_tag_00_01tvector_c6da30a2eb349e2b8f7044ab4352d283.html">DerivativeTypeDispatcher&lt; VectorTag, VectorTag, tvector&lt; N1, TVectorNumericTypeType1 &gt;, tvector&lt; N2, TVectorNumericTypeType2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_vector_tag_00_01_vector_tag_00_01tvector_c6da30a2eb349e2b8f7044ab4352d283.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_is_t_vector_scalar_operation_valid.html">IsTVectorScalarOperationValid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_vector_tag_00_01_scalar_tag_00_01tvector_f1b11acc8c2ecf9e815ed7393824e387.html">DerivativeTypeDispatcher&lt; VectorTag, ScalarTag, tvector&lt; N, TVectorNumericType &gt;, ScalarType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_vector_tag_00_01_scalar_tag_00_01tvector_f1b11acc8c2ecf9e815ed7393824e387.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_vector_tag_00_01_scalar_514087ad5bdf8dcd0fc8794bdb49a0ec.html">DerivativeTypeDispatcher&lt; ScalarTag, VectorTag, ScalarType, tvector&lt; N, TVectorNumericType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of the <code><a class="el" href="structtfel_1_1math_1_1_derivative_type_dispatcher.html" title="an helper metafunction used to determine the type representing the derivative of an object of type Fu...">DerivativeTypeDispatcher</a></code> metafunction.  <a href="structtfel_1_1math_1_1_derivative_type_dispatcher_3_01_scalar_tag_00_01_vector_tag_00_01_scalar_514087ad5bdf8dcd0fc8794bdb49a0ec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; tvector&lt; N, T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_vector_tag_00_01_scalar_tag_00_01tvec82d3577f4f8b8cdf6fa2eb3ca3a062ac.html">ComputeBinaryOperationResult&lt; VectorTag, ScalarTag, tvector&lt; N, T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_vector_tag_00_01_scalar_tag_00_01tvec82d3577f4f8b8cdf6fa2eb3ca3a062ac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_vector_tag_00_01_scalar_tag_00_01tvec33298b09e4d40ce2fea1d7ed7bf23489.html">ComputeBinaryOperationResult&lt; VectorTag, ScalarTag, tvector&lt; N, T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_vector_tag_00_01_scalar_tag_00_01tvec33298b09e4d40ce2fea1d7ed7bf23489.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_vector_tag_00_01_sca156a13e775864b55b51497c1b6ef0211.html">ComputeBinaryOperationResult&lt; ScalarTag, VectorTag, Scal, tvector&lt; N, T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_vector_tag_00_01_sca156a13e775864b55b51497c1b6ef0211.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_m_00_01_t2_09e8a9814bcfc77e83ac21a8ba95ba5f9.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; M, T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="classtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_m_00_01_t2_09e8a9814bcfc77e83ac21a8ba95ba5f9.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html">ResultType&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt;, OpDotProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector.  <a href="structtfel_1_1math_1_1_result_type_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_00_01_op_dot_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_dot_product_handle_3_01tvector_3_01_n_00_01_t_01_4_00_01tvector_3_01_n_00_01_t2_01_4_01_4.html">VectorDotProductHandle&lt; tvector&lt; N, T &gt;, tvector&lt; N, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_tag.html">VectorTag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to characterise vectors.  <a href="structtfel_1_1math_1_1_vector_tag.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_concept_base.html">VectorConceptBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_concept_rebind_3_01_vector_tag_00_01_type_01_4.html">ConceptRebind&lt; VectorTag, Type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">paratial specialisation for vectors  <a href="structtfel_1_1math_1_1_concept_rebind_3_01_vector_tag_00_01_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_dot_product_handle.html">VectorDotProductHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_vector_tag_00_01_vector_tag_00_01_a_680d87fa71ba0ad72fe9ca09bcfe9a10.html">ComputeBinaryOperationHandler&lt; VectorTag, VectorTag, A, B, OpDotProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_handler_3_01_vector_tag_00_01_vector_tag_00_01_a_ee9b8306cdbc37a8db07c06faecc88e0.html">ComputeBinaryOperationHandler&lt; VectorTag, VectorTag, A, B, OpDiadicProduct &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_unary_result___3_01_vector_tag_00_01_unary_operator_tag_00_01_a_00_01_op_neg_01_4.html">ComputeUnaryResult_&lt; VectorTag, UnaryOperatorTag, A, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_unary_result_type_3_01vector_3_01_t_01_4_00_01_op_neg_01_4.html">UnaryResultType&lt; vector&lt; T &gt;, OpNeg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_vector_tag_00_01_scalar_tag_00_01vectd84c33b7f473ed499f3fff15d42a3ad2.html">ComputeBinaryOperationResult&lt; VectorTag, ScalarTag, vector&lt; T &gt;, Scal, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_vector_tag_00_01_scalar_tag_00_01vectd84c33b7f473ed499f3fff15d42a3ad2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_vector_tag_00_01_scace697cf9d02d4ceb07ba6e81815144c2.html">ComputeBinaryOperationResult&lt; ScalarTag, VectorTag, Scal, vector&lt; T &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for tvector and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_scalar_tag_00_01_vector_tag_00_01_scace697cf9d02d4ceb07ba6e81815144c2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_dot_product_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpDotProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_dot_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_vector_tag_00_01_scalar_tag_00_01vectce63a8be576f1bfc5b9458fe1247036f.html">ComputeBinaryOperationResult&lt; VectorTag, ScalarTag, vector&lt; T &gt;, Scal, OpDiv &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector and scalars operations.  <a href="classtfel_1_1math_1_1_compute_binary_operation_result_3_01_vector_tag_00_01_scalar_tag_00_01vectce63a8be576f1bfc5b9458fe1247036f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_diadic_product_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpDiadicProduct &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_diadic_product_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_plus_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpPlus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_plus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_minus_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpMinus &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_minus_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_mult_01_4.html">ResultType&lt; vector&lt; T &gt;, vector&lt; T2 &gt;, OpMult &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialisation for vector.  <a href="classtfel_1_1math_1_1_result_type_3_01vector_3_01_t_01_4_00_01vector_3_01_t2_01_4_00_01_op_mult_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtfel_1_1math_1_1_vector_vector_dot_product.html">VectorVectorDotProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae3b6c911fc77e28319842187680d240e"><td class="memTemplParams" colspan="2"><a id="ae3b6c911fc77e28319842187680d240e"></a>
template&lt;typename MappedType , typename IndexingPolicyType &gt; </td></tr>
<tr class="memitem:ae3b6c911fc77e28319842187680d240e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae3b6c911fc77e28319842187680d240e">selectViewArrayBase</a> = std::conditional_t&lt; std::is_const_v&lt; MappedType &gt;, std::conditional_t&lt; IndexingPolicyType::hasFixedSizes, <a class="el" href="structtfel_1_1math_1_1_const_fixed_size_array_base.html">ConstFixedSizeArrayBase</a>&lt; <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; MappedType, IndexingPolicyType &gt;, <a class="el" href="structtfel_1_1math_1_1_view_array_policy.html">ViewArrayPolicy</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; MappedType &gt;, IndexingPolicyType &gt; &gt;, <a class="el" href="structtfel_1_1math_1_1_const_runtime_array_base.html">ConstRuntimeArrayBase</a>&lt; <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; MappedType, IndexingPolicyType &gt;, <a class="el" href="structtfel_1_1math_1_1_view_array_policy.html">ViewArrayPolicy</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; MappedType &gt;, IndexingPolicyType &gt; &gt;&gt;, std::conditional_t&lt; IndexingPolicyType::hasFixedSizes, <a class="el" href="structtfel_1_1math_1_1_mutable_fixed_size_array_base.html">MutableFixedSizeArrayBase</a>&lt; <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; MappedType, IndexingPolicyType &gt;, <a class="el" href="structtfel_1_1math_1_1_view_array_policy.html">ViewArrayPolicy</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; MappedType &gt;, IndexingPolicyType &gt; &gt;, <a class="el" href="structtfel_1_1math_1_1_mutable_runtime_array_base.html">MutableRuntimeArrayBase</a>&lt; <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; MappedType, IndexingPolicyType &gt;, <a class="el" href="structtfel_1_1math_1_1_view_array_policy.html">ViewArrayPolicy</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; MappedType &gt;, IndexingPolicyType &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:ae3b6c911fc77e28319842187680d240e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:ae3b6c911fc77e28319842187680d240e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05830e6b41afd642ac45e65ab86b6c7"><td class="memTemplParams" colspan="2"><a id="aa05830e6b41afd642ac45e65ab86b6c7"></a>
template&lt;typename MappedType &gt; </td></tr>
<tr class="memitem:aa05830e6b41afd642ac45e65ab86b6c7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ViewStorageType</b> = std::conditional_t&lt; isQuantity&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; std::remove_cv_t&lt; MappedType &gt; &gt;&gt;(), <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; std::remove_cv_t&lt; MappedType &gt; &gt;&gt;, <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; std::remove_cv_t&lt; MappedType &gt; &gt;&gt;</td></tr>
<tr class="separator:aa05830e6b41afd642ac45e65ab86b6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df0622749ef30c2fcb1dfb20797addd"><td class="memTemplParams" colspan="2"><a id="a5df0622749ef30c2fcb1dfb20797addd"></a>
template&lt;typename MappedType &gt; </td></tr>
<tr class="memitem:a5df0622749ef30c2fcb1dfb20797addd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ViewDataPointerType</b> = std::conditional_t&lt; std::is_const_v&lt; MappedType &gt;, const ViewStorageType&lt; MappedType &gt; *, ViewStorageType&lt; MappedType &gt; * &gt;</td></tr>
<tr class="separator:a5df0622749ef30c2fcb1dfb20797addd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946e775345f0361c54604c43370019d8"><td class="memTemplParams" colspan="2"><a id="a946e775345f0361c54604c43370019d8"></a>
template&lt;typename MappedType &gt; </td></tr>
<tr class="memitem:a946e775345f0361c54604c43370019d8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ViewConstDataPointerType</b> = const ViewStorageType&lt; MappedType &gt; *</td></tr>
<tr class="separator:a946e775345f0361c54604c43370019d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76cb3f290377f36ba39de985aef57a0"><td class="memTemplParams" colspan="2"><a id="ab76cb3f290377f36ba39de985aef57a0"></a>
template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:ab76cb3f290377f36ba39de985aef57a0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab76cb3f290377f36ba39de985aef57a0">scalar_view</a> = std::conditional_t&lt; <a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; ScalarType &gt;(), std::conditional_t&lt; std::is_const_v&lt; ScalarType &gt;, std::conditional_t&lt; isQuantity&lt; ScalarType &gt;(), const <a class="el" href="namespacetfel_1_1math.html#afad035219dbadf321238dc0c157dffd9">qt_ref</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_quantity_traits.html">QuantityTraits</a>&lt; ScalarType &gt;::UnitType, typename <a class="el" href="structtfel_1_1math_1_1_quantity_traits.html">QuantityTraits</a>&lt; ScalarType &gt;::ValueType &gt;, const ScalarType &amp; &gt;, std::conditional_t&lt; isQuantity&lt; ScalarType &gt;(), <a class="el" href="namespacetfel_1_1math.html#afad035219dbadf321238dc0c157dffd9">qt_ref</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_quantity_traits.html">QuantityTraits</a>&lt; ScalarType &gt;::UnitType, typename <a class="el" href="structtfel_1_1math_1_1_quantity_traits.html">QuantityTraits</a>&lt; ScalarType &gt;::ValueType &gt;, ScalarType &amp; &gt; &gt;, tfel::meta::InvalidType &gt;</td></tr>
<tr class="memdesc:ab76cb3f290377f36ba39de985aef57a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">view to a scalar <br /></td></tr>
<tr class="separator:ab76cb3f290377f36ba39de985aef57a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202b158799dc3efc7b16c5a9f4d42533"><td class="memTemplParams" colspan="2"><a id="a202b158799dc3efc7b16c5a9f4d42533"></a>
template&lt;typename MappedType , typename IndexingPolicyType  = typename std::remove_cv_t&lt;MappedType&gt;::indexing_policy&gt; </td></tr>
<tr class="memitem:a202b158799dc3efc7b16c5a9f4d42533"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstView</b> = <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; const std::remove_cv_t&lt; MappedType &gt;, IndexingPolicyType &gt;</td></tr>
<tr class="separator:a202b158799dc3efc7b16c5a9f4d42533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1e469d35bbeb45d57faa77680c8a4e"><td class="memTemplParams" colspan="2"><a id="afe1e469d35bbeb45d57faa77680c8a4e"></a>
template&lt;typename MappedType &gt; </td></tr>
<tr class="memitem:afe1e469d35bbeb45d57faa77680c8a4e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#afe1e469d35bbeb45d57faa77680c8a4e">ViewsArrayNumericType</a> = std::conditional_t&lt; <a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; MappedType &gt;(), std::remove_cv_t&lt; MappedType &gt;, <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; MappedType &gt; &gt;</td></tr>
<tr class="memdesc:afe1e469d35bbeb45d57faa77680c8a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the numeric type used by the mapped type <br /></td></tr>
<tr class="separator:afe1e469d35bbeb45d57faa77680c8a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ee62421d92643599d399646e39b1c2"><td class="memTemplParams" colspan="2"><a id="a22ee62421d92643599d399646e39b1c2"></a>
template&lt;typename MappedType &gt; </td></tr>
<tr class="memitem:a22ee62421d92643599d399646e39b1c2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a22ee62421d92643599d399646e39b1c2">ViewsArrayDataPointerType</a> = std::conditional_t&lt; std::is_const_v&lt; MappedType &gt;, const <a class="el" href="namespacetfel_1_1math.html#afe1e469d35bbeb45d57faa77680c8a4e">ViewsArrayNumericType</a>&lt; MappedType &gt; *, <a class="el" href="namespacetfel_1_1math.html#afe1e469d35bbeb45d57faa77680c8a4e">ViewsArrayNumericType</a>&lt; MappedType &gt; * &gt;</td></tr>
<tr class="memdesc:a22ee62421d92643599d399646e39b1c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">the pointer type used to build the view <br /></td></tr>
<tr class="separator:a22ee62421d92643599d399646e39b1c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0fdd50d2bd183b372bad6b4b7a8813"><td class="memTemplParams" colspan="2"><a id="a4d0fdd50d2bd183b372bad6b4b7a8813"></a>
template&lt;typename MappedType , typename SizeType , SizeType N, SizeType Stride = getViewsArrayMinimalStride&lt;MappedType&gt;()&gt; </td></tr>
<tr class="memitem:a4d0fdd50d2bd183b372bad6b4b7a8813"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ViewsFixedSizeVector</b> = <a class="el" href="structtfel_1_1math_1_1_views_array.html">ViewsArray</a>&lt; MappedType, <a class="el" href="structtfel_1_1math_1_1_views_fixed_size_vector_indexing_policy.html">ViewsFixedSizeVectorIndexingPolicy</a>&lt; MappedType, SizeType, N, Stride &gt; &gt;</td></tr>
<tr class="separator:a4d0fdd50d2bd183b372bad6b4b7a8813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037360e732078b2d8b6bee5f80a0c819"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a037360e732078b2d8b6bee5f80a0c819"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a> = <a class="el" href="structstd_1_1complex.html">std::complex</a>&lt; ValueType &gt;</td></tr>
<tr class="memdesc:a037360e732078b2d8b6bee5f80a0c819"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias <a class="el" href="structstd_1_1complex.html">std::complex</a>.  <a href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">More...</a><br /></td></tr>
<tr class="separator:a037360e732078b2d8b6bee5f80a0c819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77fbcb0679a70e562fe1e0f10f5e61c"><td class="memTemplParams" colspan="2"><a id="af77fbcb0679a70e562fe1e0f10f5e61c"></a>
template&lt;typename ObjectType &gt; </td></tr>
<tr class="memitem:af77fbcb0679a70e562fe1e0f10f5e61c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af77fbcb0679a70e562fe1e0f10f5e61c">EvaluationResult</a> = typename <a class="el" href="structtfel_1_1math_1_1_result_of_evaluation.html">ResultOfEvaluation</a>&lt; std::decay_t&lt; ObjectType &gt; &gt;::type</td></tr>
<tr class="memdesc:af77fbcb0679a70e562fe1e0f10f5e61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:af77fbcb0679a70e562fe1e0f10f5e61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6ed9aad6fa85a1d87034f5fe612b8f"><td class="memItemLeft" align="right" valign="top"><a id="aec6ed9aad6fa85a1d87034f5fe612b8f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aec6ed9aad6fa85a1d87034f5fe612b8f">NoUnit</a> = <a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a>&lt; std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; int, 0 &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt;, std::integral_constant&lt; unsigned int, 1u &gt; &gt;</td></tr>
<tr class="memdesc:aec6ed9aad6fa85a1d87034f5fe612b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:aec6ed9aad6fa85a1d87034f5fe612b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd56523febfd59ddb740d38a686a4a8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 0, 0, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7cd56523febfd59ddb740d38a686a4a8">Mass</a></td></tr>
<tr class="memdesc:a7cd56523febfd59ddb740d38a686a4a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Mass unit.  <a href="namespacetfel_1_1math.html#a7cd56523febfd59ddb740d38a686a4a8">More...</a><br /></td></tr>
<tr class="separator:a7cd56523febfd59ddb740d38a686a4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2b52b863e01ed4c1e86a87c5e42633"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 1, 0, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3a2b52b863e01ed4c1e86a87c5e42633">Length</a></td></tr>
<tr class="memdesc:a3a2b52b863e01ed4c1e86a87c5e42633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Length unit.  <a href="namespacetfel_1_1math.html#a3a2b52b863e01ed4c1e86a87c5e42633">More...</a><br /></td></tr>
<tr class="separator:a3a2b52b863e01ed4c1e86a87c5e42633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c743e2591ae63c3e4ee54465ea14aa"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 1, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a00c743e2591ae63c3e4ee54465ea14aa">Time</a></td></tr>
<tr class="memdesc:a00c743e2591ae63c3e4ee54465ea14aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Time unit.  <a href="namespacetfel_1_1math.html#a00c743e2591ae63c3e4ee54465ea14aa">More...</a><br /></td></tr>
<tr class="separator:a00c743e2591ae63c3e4ee54465ea14aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa788e6a053ffcfd3383c326608623621"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 1, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa788e6a053ffcfd3383c326608623621">Ampere</a></td></tr>
<tr class="memdesc:aa788e6a053ffcfd3383c326608623621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Ampere unit.  <a href="namespacetfel_1_1math.html#aa788e6a053ffcfd3383c326608623621">More...</a><br /></td></tr>
<tr class="separator:aa788e6a053ffcfd3383c326608623621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dca8ad371d67538aeb06fcb76d052a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0, 1, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a11dca8ad371d67538aeb06fcb76d052a">Temperature</a></td></tr>
<tr class="memdesc:a11dca8ad371d67538aeb06fcb76d052a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Temperature unit.  <a href="namespacetfel_1_1math.html#a11dca8ad371d67538aeb06fcb76d052a">More...</a><br /></td></tr>
<tr class="separator:a11dca8ad371d67538aeb06fcb76d052a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e302646eb52f224860ed116b2d2460"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0, 1, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af9e302646eb52f224860ed116b2d2460">Kelvin</a></td></tr>
<tr class="memdesc:af9e302646eb52f224860ed116b2d2460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Kelvin unit.  <a href="namespacetfel_1_1math.html#af9e302646eb52f224860ed116b2d2460">More...</a><br /></td></tr>
<tr class="separator:af9e302646eb52f224860ed116b2d2460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c377618f94581e9b3f896d98df7cec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0, 0, 1, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a20c377618f94581e9b3f896d98df7cec">Candela</a></td></tr>
<tr class="memdesc:a20c377618f94581e9b3f896d98df7cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Candela unit.  <a href="namespacetfel_1_1math.html#a20c377618f94581e9b3f896d98df7cec">More...</a><br /></td></tr>
<tr class="separator:a20c377618f94581e9b3f896d98df7cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b083381360ba74dcdef115ee9802b16"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0, 0, 0, 1 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1b083381360ba74dcdef115ee9802b16">Mole</a></td></tr>
<tr class="memdesc:a1b083381360ba74dcdef115ee9802b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Mole unit.  <a href="namespacetfel_1_1math.html#a1b083381360ba74dcdef115ee9802b16">More...</a><br /></td></tr>
<tr class="separator:a1b083381360ba74dcdef115ee9802b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8956b31691945e6ad86c9b35a9cc9449"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, -1, 0, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8956b31691945e6ad86c9b35a9cc9449">InvLength</a></td></tr>
<tr class="memdesc:a8956b31691945e6ad86c9b35a9cc9449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the InvLength unit.  <a href="namespacetfel_1_1math.html#a8956b31691945e6ad86c9b35a9cc9449">More...</a><br /></td></tr>
<tr class="separator:a8956b31691945e6ad86c9b35a9cc9449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f942447bae7c61931c33048337111cf"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, 0, 0, -1, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1f942447bae7c61931c33048337111cf">InvTemperature</a></td></tr>
<tr class="memdesc:a1f942447bae7c61931c33048337111cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the InvTemperature unit.  <a href="namespacetfel_1_1math.html#a1f942447bae7c61931c33048337111cf">More...</a><br /></td></tr>
<tr class="separator:a1f942447bae7c61931c33048337111cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af313c4c99c0c972905f4ea4664d37d7a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 0, -1, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af313c4c99c0c972905f4ea4664d37d7a">Frequency</a></td></tr>
<tr class="memdesc:af313c4c99c0c972905f4ea4664d37d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Frequency unit.  <a href="namespacetfel_1_1math.html#af313c4c99c0c972905f4ea4664d37d7a">More...</a><br /></td></tr>
<tr class="separator:af313c4c99c0c972905f4ea4664d37d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098b63954160182ad3703acebc91eded"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 1, -1, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a098b63954160182ad3703acebc91eded">Speed</a></td></tr>
<tr class="memdesc:a098b63954160182ad3703acebc91eded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Speed unit.  <a href="namespacetfel_1_1math.html#a098b63954160182ad3703acebc91eded">More...</a><br /></td></tr>
<tr class="separator:a098b63954160182ad3703acebc91eded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa416b0f269aa81f1431967a34e32cfb6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, 1, -2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa416b0f269aa81f1431967a34e32cfb6">Acceleration</a></td></tr>
<tr class="memdesc:aa416b0f269aa81f1431967a34e32cfb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Acceleration unit.  <a href="namespacetfel_1_1math.html#aa416b0f269aa81f1431967a34e32cfb6">More...</a><br /></td></tr>
<tr class="separator:aa416b0f269aa81f1431967a34e32cfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ada2a52f9c1af346d8b736ade08e2d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 1, -1, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af6ada2a52f9c1af346d8b736ade08e2d">Momentum</a></td></tr>
<tr class="memdesc:af6ada2a52f9c1af346d8b736ade08e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Momentum unit.  <a href="namespacetfel_1_1math.html#af6ada2a52f9c1af346d8b736ade08e2d">More...</a><br /></td></tr>
<tr class="separator:af6ada2a52f9c1af346d8b736ade08e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de9a5807f32274781605d88cbb90ecc"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 1, -2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8de9a5807f32274781605d88cbb90ecc">Force</a></td></tr>
<tr class="memdesc:a8de9a5807f32274781605d88cbb90ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Momentum unit.  <a href="namespacetfel_1_1math.html#a8de9a5807f32274781605d88cbb90ecc">More...</a><br /></td></tr>
<tr class="separator:a8de9a5807f32274781605d88cbb90ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60129cc8e9010447033707d46d41816"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 1, -2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab60129cc8e9010447033707d46d41816">Newton</a></td></tr>
<tr class="memdesc:ab60129cc8e9010447033707d46d41816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Newton unit.  <a href="namespacetfel_1_1math.html#ab60129cc8e9010447033707d46d41816">More...</a><br /></td></tr>
<tr class="separator:ab60129cc8e9010447033707d46d41816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa2a425a67055d9bd9f3698ccb36f80"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, -1, -2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aafa2a425a67055d9bd9f3698ccb36f80">Stress</a></td></tr>
<tr class="memdesc:aafa2a425a67055d9bd9f3698ccb36f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Stress unit.  <a href="namespacetfel_1_1math.html#aafa2a425a67055d9bd9f3698ccb36f80">More...</a><br /></td></tr>
<tr class="separator:aafa2a425a67055d9bd9f3698ccb36f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41bb413e30c83ae508ba80aedb1278c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, -1, -3, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab41bb413e30c83ae508ba80aedb1278c">StressRate</a></td></tr>
<tr class="memdesc:ab41bb413e30c83ae508ba80aedb1278c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the StressRate unit.  <a href="namespacetfel_1_1math.html#ab41bb413e30c83ae508ba80aedb1278c">More...</a><br /></td></tr>
<tr class="separator:ab41bb413e30c83ae508ba80aedb1278c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7681121858bfa43509d51b045e59004a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, -1, -2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7681121858bfa43509d51b045e59004a">Pressure</a></td></tr>
<tr class="memdesc:a7681121858bfa43509d51b045e59004a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Pressure unit.  <a href="namespacetfel_1_1math.html#a7681121858bfa43509d51b045e59004a">More...</a><br /></td></tr>
<tr class="separator:a7681121858bfa43509d51b045e59004a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab352b475ea35e1dd9c987bfc53b9f5b8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 2, -2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab352b475ea35e1dd9c987bfc53b9f5b8">Energy</a></td></tr>
<tr class="memdesc:ab352b475ea35e1dd9c987bfc53b9f5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Energy unit.  <a href="namespacetfel_1_1math.html#ab352b475ea35e1dd9c987bfc53b9f5b8">More...</a><br /></td></tr>
<tr class="separator:ab352b475ea35e1dd9c987bfc53b9f5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479db7d0cfb4a65822b9b9838cc64f81"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, -1, -2, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a479db7d0cfb4a65822b9b9838cc64f81">EnergyDensity</a></td></tr>
<tr class="memdesc:a479db7d0cfb4a65822b9b9838cc64f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the EnergyDensity unit.  <a href="namespacetfel_1_1math.html#a479db7d0cfb4a65822b9b9838cc64f81">More...</a><br /></td></tr>
<tr class="separator:a479db7d0cfb4a65822b9b9838cc64f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4899498fd64cfacfc0f16c2ac5ca545c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, -3, 0, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4899498fd64cfacfc0f16c2ac5ca545c">Density</a></td></tr>
<tr class="memdesc:a4899498fd64cfacfc0f16c2ac5ca545c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the Density unit.  <a href="namespacetfel_1_1math.html#a4899498fd64cfacfc0f16c2ac5ca545c">More...</a><br /></td></tr>
<tr class="separator:a4899498fd64cfacfc0f16c2ac5ca545c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919fd4942be8ad5b9fd7e9e93361fe38"><td class="memItemLeft" align="right" valign="top"><a id="a919fd4942be8ad5b9fd7e9e93361fe38"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a919fd4942be8ad5b9fd7e9e93361fe38">TemperatureGradient</a> = <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 0, -1, 0, 0, 1, 0, 0 &gt;::type</td></tr>
<tr class="memdesc:a919fd4942be8ad5b9fd7e9e93361fe38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the TemperatureGradient unit. <br /></td></tr>
<tr class="separator:a919fd4942be8ad5b9fd7e9e93361fe38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef06691de5802e7c5490736adf49533"><td class="memItemLeft" align="right" valign="top"><a id="a5ef06691de5802e7c5490736adf49533"></a>
typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 1, -3, 0, -1, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5ef06691de5802e7c5490736adf49533">ThermalConductivity</a></td></tr>
<tr class="memdesc:a5ef06691de5802e7c5490736adf49533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the ThermalConductivity unit. <br /></td></tr>
<tr class="separator:a5ef06691de5802e7c5490736adf49533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690355bc049d3560404acb9fcccb4d6c"><td class="memItemLeft" align="right" valign="top"><a id="a690355bc049d3560404acb9fcccb4d6c"></a>
typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; 1, 0, -3, 0, 0, 0, 0 &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a690355bc049d3560404acb9fcccb4d6c">HeatFluxDensity</a></td></tr>
<tr class="memdesc:a690355bc049d3560404acb9fcccb4d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the HeatFluxDensity unit. <br /></td></tr>
<tr class="separator:a690355bc049d3560404acb9fcccb4d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ea76e48b98b755d87cb16dc74d2afa"><td class="memTemplParams" colspan="2"><a id="a09ea76e48b98b755d87cb16dc74d2afa"></a>
template&lt;typename UnitType , typename ValueType  = double&gt; </td></tr>
<tr class="memitem:a09ea76e48b98b755d87cb16dc74d2afa"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a09ea76e48b98b755d87cb16dc74d2afa">qt</a> = <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, <a class="el" href="structtfel_1_1math_1_1internals_1_1_quantity_value_ownership_policy.html">tfel::math::internals::QuantityValueOwnershipPolicy</a>&lt; ValueType, std::is_same_v&lt; UnitType, <a class="el" href="namespacetfel_1_1math.html#aec6ed9aad6fa85a1d87034f5fe612b8f">NoUnit</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a09ea76e48b98b755d87cb16dc74d2afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a09ea76e48b98b755d87cb16dc74d2afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad035219dbadf321238dc0c157dffd9"><td class="memTemplParams" colspan="2"><a id="afad035219dbadf321238dc0c157dffd9"></a>
template&lt;typename UnitType , typename ValueType  = double&gt; </td></tr>
<tr class="memitem:afad035219dbadf321238dc0c157dffd9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#afad035219dbadf321238dc0c157dffd9">qt_ref</a> = <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, <a class="el" href="structtfel_1_1math_1_1internals_1_1_quantity_reference_ownership_policy.html">tfel::math::internals::QuantityReferenceOwnershipPolicy</a>&lt; ValueType, std::is_same_v&lt; UnitType, <a class="el" href="namespacetfel_1_1math.html#aec6ed9aad6fa85a1d87034f5fe612b8f">NoUnit</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:afad035219dbadf321238dc0c157dffd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:afad035219dbadf321238dc0c157dffd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bc98df0ea174b4e5423fea91a1b05e"><td class="memTemplParams" colspan="2"><a id="a81bc98df0ea174b4e5423fea91a1b05e"></a>
template&lt;typename UnitType , typename ValueType  = double&gt; </td></tr>
<tr class="memitem:a81bc98df0ea174b4e5423fea91a1b05e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a81bc98df0ea174b4e5423fea91a1b05e">const_qt_ref</a> = <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, <a class="el" href="structtfel_1_1math_1_1internals_1_1_quantity_reference_ownership_policy.html">tfel::math::internals::QuantityReferenceOwnershipPolicy</a>&lt; const ValueType, std::is_same_v&lt; UnitType, <a class="el" href="namespacetfel_1_1math.html#aec6ed9aad6fa85a1d87034f5fe612b8f">NoUnit</a> &gt; &gt;&gt;</td></tr>
<tr class="memdesc:a81bc98df0ea174b4e5423fea91a1b05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a81bc98df0ea174b4e5423fea91a1b05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52e34b6e4b09c86550e97e37098d013"><td class="memTemplParams" colspan="2"><a id="ae52e34b6e4b09c86550e97e37098d013"></a>
template&lt;typename ValueType , int N1 = 0, int N2 = 0, int N3 = 0, int N4 = 0, int N5 = 0, int N6 = 0, int N7 = 0, unsigned int D1 = 1, unsigned int D2 = 1, unsigned int D3 = 1, unsigned int D4 = 1, unsigned int D5 = 1, unsigned int D6 = 1, unsigned int D7 = 1&gt; </td></tr>
<tr class="memitem:ae52e34b6e4b09c86550e97e37098d013"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae52e34b6e4b09c86550e97e37098d013">quantity</a> = <a class="el" href="namespacetfel_1_1math.html#a09ea76e48b98b755d87cb16dc74d2afa">qt</a>&lt; typename <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt; N1, N2, N3, N4, N5, N6, N7, D1, D2, D3, D4, D5, D6, D7 &gt;::type, typename <a class="el" href="structtfel_1_1math_1_1internals_1_1_make_quantity_value_type.html">tfel::math::internals::MakeQuantityValueType</a>&lt; ValueType &gt;::type &gt;</td></tr>
<tr class="memdesc:ae52e34b6e4b09c86550e97e37098d013"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:ae52e34b6e4b09c86550e97e37098d013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373af1865a931dd29d7ff54ed4ea7b86"><td class="memTemplParams" colspan="2"><a id="a373af1865a931dd29d7ff54ed4ea7b86"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a373af1865a931dd29d7ff54ed4ea7b86"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a> = <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3, 3, <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a373af1865a931dd29d7ff54ed4ea7b86"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a373af1865a931dd29d7ff54ed4ea7b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36bc9045afd07925b2bfef0a00c27f7"><td class="memTemplParams" colspan="2"><a id="af36bc9045afd07925b2bfef0a00c27f7"></a>
template&lt;typename T1 , typename T2 , typename Op &gt; </td></tr>
<tr class="memitem:af36bc9045afd07925b2bfef0a00c27f7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af36bc9045afd07925b2bfef0a00c27f7">BinaryOperationResult</a> = typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, Op &gt;::Result</td></tr>
<tr class="memdesc:af36bc9045afd07925b2bfef0a00c27f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias for the result of an binary operation <br /></td></tr>
<tr class="separator:af36bc9045afd07925b2bfef0a00c27f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f46866ed03b641861851d837909263"><td class="memTemplParams" colspan="2"><a id="a21f46866ed03b641861851d837909263"></a>
template&lt;typename T1 , typename T2 , typename Op &gt; </td></tr>
<tr class="memitem:a21f46866ed03b641861851d837909263"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a21f46866ed03b641861851d837909263">BinaryOperationHandler</a> = typename <a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a>&lt; T1, T2, Op &gt;::Handle</td></tr>
<tr class="memdesc:a21f46866ed03b641861851d837909263"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias of the handler of an binary operation <br /></td></tr>
<tr class="separator:a21f46866ed03b641861851d837909263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9671854151ae83ea6ea63a6c742f769d"><td class="memTemplParams" colspan="2"><a id="a9671854151ae83ea6ea63a6c742f769d"></a>
template&lt;typename T1 , typename Op &gt; </td></tr>
<tr class="memitem:a9671854151ae83ea6ea63a6c742f769d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9671854151ae83ea6ea63a6c742f769d">UnaryOperationResult</a> = typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T1, Op &gt;::Result</td></tr>
<tr class="memdesc:a9671854151ae83ea6ea63a6c742f769d"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias for the result of an unary operation <br /></td></tr>
<tr class="separator:a9671854151ae83ea6ea63a6c742f769d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223f10977fb55f4581bbe021800bcf4c"><td class="memTemplParams" colspan="2"><a id="a223f10977fb55f4581bbe021800bcf4c"></a>
template&lt;typename T1 , typename Op &gt; </td></tr>
<tr class="memitem:a223f10977fb55f4581bbe021800bcf4c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a223f10977fb55f4581bbe021800bcf4c">UnaryOperationHandler</a> = typename <a class="el" href="classtfel_1_1math_1_1_compute_unary_result.html">ComputeUnaryResult</a>&lt; T1, Op &gt;::Handle</td></tr>
<tr class="memdesc:a223f10977fb55f4581bbe021800bcf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias of the handler of an unary operation <br /></td></tr>
<tr class="separator:a223f10977fb55f4581bbe021800bcf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8691d8234e536cdd0d357a2bc5d10c"><td class="memTemplParams" colspan="2">template&lt;typename FunctionType , typename... VariableTypes&gt; </td></tr>
<tr class="memitem:a8a8691d8234e536cdd0d357a2bc5d10c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8a8691d8234e536cdd0d357a2bc5d10c">derivative_type</a> = typename <a class="el" href="structtfel_1_1math_1_1_derivative_type_meta_function.html">DerivativeTypeMetaFunction</a>&lt; FunctionType, VariableTypes... &gt;::type</td></tr>
<tr class="memdesc:a8a8691d8234e536cdd0d357a2bc5d10c"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias giving the type representing the derivative of an object of type <code>FunctionType</code> with respect to objects of the type given by the template argument pack <code>VariableTypes</code>.  <a href="namespacetfel_1_1math.html#a8a8691d8234e536cdd0d357a2bc5d10c">More...</a><br /></td></tr>
<tr class="separator:a8a8691d8234e536cdd0d357a2bc5d10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269ae6d80236c1e3a8f97af7c50997e9"><td class="memTemplParams" colspan="2"><a id="a269ae6d80236c1e3a8f97af7c50997e9"></a>
template&lt;typename MathObjectType &gt; </td></tr>
<tr class="memitem:a269ae6d80236c1e3a8f97af7c50997e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a> = std::conditional_t&lt; tfel::typetraits::isScalar&lt; std::decay_t&lt; MathObjectType &gt; &gt;(), std::decay_t&lt; MathObjectType &gt;, typename <a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a>&lt; std::decay_t&lt; MathObjectType &gt; &gt;::value_type &gt;</td></tr>
<tr class="memdesc:a269ae6d80236c1e3a8f97af7c50997e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a269ae6d80236c1e3a8f97af7c50997e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf42373bf172e38d879a8eb8666402fd"><td class="memTemplParams" colspan="2"><a id="acf42373bf172e38d879a8eb8666402fd"></a>
template&lt;typename MathObjectType &gt; </td></tr>
<tr class="memitem:acf42373bf172e38d879a8eb8666402fd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#acf42373bf172e38d879a8eb8666402fd">index_type</a> = typename <a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a>&lt; std::decay_t&lt; MathObjectType &gt; &gt;::size_type</td></tr>
<tr class="memdesc:acf42373bf172e38d879a8eb8666402fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:acf42373bf172e38d879a8eb8666402fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee110500aba43bd0fc73c7a5ecd510e9"><td class="memTemplParams" colspan="2"><a id="aee110500aba43bd0fc73c7a5ecd510e9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aee110500aba43bd0fc73c7a5ecd510e9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a> = std::conditional_t&lt; tfel::typetraits::isScalar&lt; T &gt;(), <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; T &gt;, <a class="el" href="_base_type_8hxx.html#a30eeb1d2ba39137579bef92548c75bef">tfel::typetraits::base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; T &gt; &gt;&gt;</td></tr>
<tr class="memdesc:aee110500aba43bd0fc73c7a5ecd510e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:aee110500aba43bd0fc73c7a5ecd510e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148d63c9fac3faf5a99af96ffdb36664"><td class="memTemplParams" colspan="2"><a id="a148d63c9fac3faf5a99af96ffdb36664"></a>
template&lt;typename A , typename B , typename Op &gt; </td></tr>
<tr class="memitem:a148d63c9fac3faf5a99af96ffdb36664"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a148d63c9fac3faf5a99af96ffdb36664">result_type</a> = typename <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>&lt; A, B, Op &gt;::type</td></tr>
<tr class="memdesc:a148d63c9fac3faf5a99af96ffdb36664"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a148d63c9fac3faf5a99af96ffdb36664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e66a89d27dd63d28e7b8ddff17fc8c9"><td class="memTemplParams" colspan="2"><a id="a3e66a89d27dd63d28e7b8ddff17fc8c9"></a>
template&lt;typename MathObjectType &gt; </td></tr>
<tr class="memitem:a3e66a89d27dd63d28e7b8ddff17fc8c9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3e66a89d27dd63d28e7b8ddff17fc8c9">invert_type</a> = typename <a class="el" href="structtfel_1_1math_1_1_inverse_type_implementation.html">InverseTypeImplementation</a>&lt; tfel::typetraits::isScalar&lt; MathObjectType &gt;(), MathObjectType &gt;::type</td></tr>
<tr class="memdesc:a3e66a89d27dd63d28e7b8ddff17fc8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias to compute the type of the inverse of a type <br /></td></tr>
<tr class="separator:a3e66a89d27dd63d28e7b8ddff17fc8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab826a6a11801d081c6ec38075abda4"><td class="memTemplParams" colspan="2"><a id="a8ab826a6a11801d081c6ec38075abda4"></a>
template&lt;typename A , typename Op &gt; </td></tr>
<tr class="memitem:a8ab826a6a11801d081c6ec38075abda4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8ab826a6a11801d081c6ec38075abda4">unary_result_type</a> = typename <a class="el" href="classtfel_1_1math_1_1_unary_result_type.html">UnaryResultType</a>&lt; A, Op &gt;::type</td></tr>
<tr class="memdesc:a8ab826a6a11801d081c6ec38075abda4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias <br /></td></tr>
<tr class="separator:a8ab826a6a11801d081c6ec38075abda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712d25c02db991be9ecf8cf44daa2936"><td class="memTemplParams" colspan="2"><a id="a712d25c02db991be9ecf8cf44daa2936"></a>
template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a712d25c02db991be9ecf8cf44daa2936"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a712d25c02db991be9ecf8cf44daa2936">MatrixTraits</a> = std::conditional_t&lt; <a class="el" href="namespacetfel_1_1math.html#a383101542c9ac60f276aa9516e798a5c">MatrixConcept</a>&lt; MatrixType &gt;, <a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a>&lt; MatrixType &gt;, <a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a>&lt; tfel::meta::InvalidType &gt; &gt;</td></tr>
<tr class="memdesc:a712d25c02db991be9ecf8cf44daa2936"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility with versions prior to 4.0 <br /></td></tr>
<tr class="separator:a712d25c02db991be9ecf8cf44daa2936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ae7aa43dae3d234a33b4b03be38a88"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a45ae7aa43dae3d234a33b4b03be38a88"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a45ae7aa43dae3d234a33b4b03be38a88">ST2toST2View</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:a45ae7aa43dae3d234a33b4b03be38a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#a45ae7aa43dae3d234a33b4b03be38a88">More...</a><br /></td></tr>
<tr class="separator:a45ae7aa43dae3d234a33b4b03be38a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d90727381ad7dd3c40f65da28d0dd7"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a13d90727381ad7dd3c40f65da28d0dd7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a13d90727381ad7dd3c40f65da28d0dd7">ConstST2toST2View</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt; <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:a13d90727381ad7dd3c40f65da28d0dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#a13d90727381ad7dd3c40f65da28d0dd7">More...</a><br /></td></tr>
<tr class="separator:a13d90727381ad7dd3c40f65da28d0dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afdd1bf012f99cec4f4c4b1813e10d4"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a8afdd1bf012f99cec4f4c4b1813e10d4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8afdd1bf012f99cec4f4c4b1813e10d4">ST2toT2View</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:a8afdd1bf012f99cec4f4c4b1813e10d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#a8afdd1bf012f99cec4f4c4b1813e10d4">More...</a><br /></td></tr>
<tr class="separator:a8afdd1bf012f99cec4f4c4b1813e10d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd32e2bd3bebecba89520218da81b04"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a7cd32e2bd3bebecba89520218da81b04"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7cd32e2bd3bebecba89520218da81b04">ConstST2toT2View</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt; <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:a7cd32e2bd3bebecba89520218da81b04"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#a7cd32e2bd3bebecba89520218da81b04">More...</a><br /></td></tr>
<tr class="separator:a7cd32e2bd3bebecba89520218da81b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe47edfd3e3b7510d5aa6a40f91cd5ee"><td class="memTemplParams" colspan="2"><a id="abe47edfd3e3b7510d5aa6a40f91cd5ee"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:abe47edfd3e3b7510d5aa6a40f91cd5ee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#abe47edfd3e3b7510d5aa6a40f91cd5ee">StensorTraits</a> = std::conditional_t&lt; <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a>&lt; tfel::meta::InvalidType &gt; &gt;</td></tr>
<tr class="memdesc:abe47edfd3e3b7510d5aa6a40f91cd5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility with versions prior to 4.0 <br /></td></tr>
<tr class="separator:abe47edfd3e3b7510d5aa6a40f91cd5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443756155e02a258140e6913163a3ad9"><td class="memTemplParams" colspan="2"><a id="a443756155e02a258140e6913163a3ad9"></a>
template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a443756155e02a258140e6913163a3ad9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a443756155e02a258140e6913163a3ad9">StensorNumType</a> = std::conditional_t&lt; <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a>&lt; StensorType &gt;, <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; StensorType &gt;, <a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a>&lt; tfel::meta::InvalidType &gt; &gt;</td></tr>
<tr class="memdesc:a443756155e02a258140e6913163a3ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility with versions prior to 4.0 <br /></td></tr>
<tr class="separator:a443756155e02a258140e6913163a3ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb4470bb96bdbf94c7ef5c2fbef6050"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a6bb4470bb96bdbf94c7ef5c2fbef6050"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6bb4470bb96bdbf94c7ef5c2fbef6050">StensorView</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:a6bb4470bb96bdbf94c7ef5c2fbef6050"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#a6bb4470bb96bdbf94c7ef5c2fbef6050">More...</a><br /></td></tr>
<tr class="separator:a6bb4470bb96bdbf94c7ef5c2fbef6050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e78b48e464dd3f9fbc9a266debb220"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a46e78b48e464dd3f9fbc9a266debb220"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a46e78b48e464dd3f9fbc9a266debb220">ConstStensorView</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt; <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:a46e78b48e464dd3f9fbc9a266debb220"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#a46e78b48e464dd3f9fbc9a266debb220">More...</a><br /></td></tr>
<tr class="separator:a46e78b48e464dd3f9fbc9a266debb220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f02c3b952ac9d506fd9e7679beaa054"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a7f02c3b952ac9d506fd9e7679beaa054"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7f02c3b952ac9d506fd9e7679beaa054">T2toST2View</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:a7f02c3b952ac9d506fd9e7679beaa054"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#a7f02c3b952ac9d506fd9e7679beaa054">More...</a><br /></td></tr>
<tr class="separator:a7f02c3b952ac9d506fd9e7679beaa054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65137e5a4d1faf3bb149a32f75dacd13"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a65137e5a4d1faf3bb149a32f75dacd13"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a65137e5a4d1faf3bb149a32f75dacd13">ConstT2toST2View</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt; <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:a65137e5a4d1faf3bb149a32f75dacd13"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#a65137e5a4d1faf3bb149a32f75dacd13">More...</a><br /></td></tr>
<tr class="separator:a65137e5a4d1faf3bb149a32f75dacd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9206e7674fc5908164cf22cd9fb4e5fc"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a9206e7674fc5908164cf22cd9fb4e5fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9206e7674fc5908164cf22cd9fb4e5fc">T2toT2View</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:a9206e7674fc5908164cf22cd9fb4e5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#a9206e7674fc5908164cf22cd9fb4e5fc">More...</a><br /></td></tr>
<tr class="separator:a9206e7674fc5908164cf22cd9fb4e5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9066340849fcd2c843a24466303e29"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:aee9066340849fcd2c843a24466303e29"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aee9066340849fcd2c843a24466303e29">ConstT2toT2View</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt; <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:aee9066340849fcd2c843a24466303e29"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#aee9066340849fcd2c843a24466303e29">More...</a><br /></td></tr>
<tr class="separator:aee9066340849fcd2c843a24466303e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cfcd2301de3a90e440082f059b68f5"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:ad6cfcd2301de3a90e440082f059b68f5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad6cfcd2301de3a90e440082f059b68f5">TensorView</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:ad6cfcd2301de3a90e440082f059b68f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#ad6cfcd2301de3a90e440082f059b68f5">More...</a><br /></td></tr>
<tr class="separator:ad6cfcd2301de3a90e440082f059b68f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ce1aa255cf403472e8322e818498ac"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:aa1ce1aa255cf403472e8322e818498ac"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa1ce1aa255cf403472e8322e818498ac">ConstTensorView</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt; <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:aa1ce1aa255cf403472e8322e818498ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#aa1ce1aa255cf403472e8322e818498ac">More...</a><br /></td></tr>
<tr class="separator:aa1ce1aa255cf403472e8322e818498ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c29e208b8ef2c33c0a187401120ff0"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, unsigned short M, typename T &gt; </td></tr>
<tr class="memitem:a51c29e208b8ef2c33c0a187401120ff0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a51c29e208b8ef2c33c0a187401120ff0">TMatrixView</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &gt;</td></tr>
<tr class="memdesc:a51c29e208b8ef2c33c0a187401120ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#a51c29e208b8ef2c33c0a187401120ff0">More...</a><br /></td></tr>
<tr class="separator:a51c29e208b8ef2c33c0a187401120ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac621530311d1973cea9f57df51dc5f90"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, unsigned short M, typename T &gt; </td></tr>
<tr class="memitem:ac621530311d1973cea9f57df51dc5f90"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac621530311d1973cea9f57df51dc5f90">ConstTMatrixView</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &gt;</td></tr>
<tr class="memdesc:ac621530311d1973cea9f57df51dc5f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#ac621530311d1973cea9f57df51dc5f90">More...</a><br /></td></tr>
<tr class="separator:ac621530311d1973cea9f57df51dc5f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ca08095dda1754ec1294f599a9e042"><td class="memTemplParams" colspan="2">template&lt;unsigned short M, typename FunctionType , typename VariableType &gt; </td></tr>
<tr class="memitem:a01ca08095dda1754ec1294f599a9e042"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a01ca08095dda1754ec1294f599a9e042">derivative_view_from_tiny_matrix</a> = typename <a class="el" href="structtfel_1_1math_1_1internals_1_1_build_derivative_view_from_tiny_matrix.html">tfel::math::internals::BuildDerivativeViewFromTinyMatrix</a>&lt; M, FunctionType, VariableType &gt;::type</td></tr>
<tr class="memdesc:a01ca08095dda1754ec1294f599a9e042"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias to a view type on a derivative in tiny matrix of M columns.  <a href="namespacetfel_1_1math.html#a01ca08095dda1754ec1294f599a9e042">More...</a><br /></td></tr>
<tr class="separator:a01ca08095dda1754ec1294f599a9e042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19439c10da11eeacfe7af93ddcf6df36"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a19439c10da11eeacfe7af93ddcf6df36"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a19439c10da11eeacfe7af93ddcf6df36">TVectorView</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:a19439c10da11eeacfe7af93ddcf6df36"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#a19439c10da11eeacfe7af93ddcf6df36">More...</a><br /></td></tr>
<tr class="separator:a19439c10da11eeacfe7af93ddcf6df36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d41659e1167f77d7b5f9d9774158ee9"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a0d41659e1167f77d7b5f9d9774158ee9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0d41659e1167f77d7b5f9d9774158ee9">ConstTVectorView</a> = <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;</td></tr>
<tr class="memdesc:a0d41659e1167f77d7b5f9d9774158ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility  <a href="namespacetfel_1_1math.html#a0d41659e1167f77d7b5f9d9774158ee9">More...</a><br /></td></tr>
<tr class="separator:a0d41659e1167f77d7b5f9d9774158ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad794f9876b69f4465b5e91c85fc34097"><td class="memTemplParams" colspan="2"><a id="ad794f9876b69f4465b5e91c85fc34097"></a>
template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:ad794f9876b69f4465b5e91c85fc34097"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad794f9876b69f4465b5e91c85fc34097">VectorTraits</a> = std::conditional_t&lt; <a class="el" href="namespacetfel_1_1math.html#a2573a7378fc579582e8c2c07042efbde">VectorConcept</a>&lt; VectorType &gt;, <a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a>&lt; VectorType &gt;, <a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a>&lt; tfel::meta::InvalidType &gt; &gt;</td></tr>
<tr class="memdesc:ad794f9876b69f4465b5e91c85fc34097"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple alias for backward compatibility with versions prior to 4.0 <br /></td></tr>
<tr class="separator:ad794f9876b69f4465b5e91c85fc34097"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2b759ee7f33caa991286726bb496361a"><td class="memTemplParams" colspan="2">template&lt;typename NumericType , typename IndexType &gt; </td></tr>
<tr class="memitem:a2b759ee7f33caa991286726bb496361a"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2b759ee7f33caa991286726bb496361a">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_aitken_acceleration_algorithm.html">AitkenAccelerationAlgorithm</a>&lt; NumericType, IndexType &gt; &amp;)</td></tr>
<tr class="memdesc:a2b759ee7f33caa991286726bb496361a"><td class="mdescLeft">&#160;</td><td class="mdescRight">output stream operator  <a href="namespacetfel_1_1math.html#a2b759ee7f33caa991286726bb496361a">More...</a><br /></td></tr>
<tr class="separator:a2b759ee7f33caa991286726bb496361a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4580b97ec337d1b3bf293803dcc8acb"><td class="memTemplParams" colspan="2">template&lt;typename ArrayType &gt; </td></tr>
<tr class="memitem:aa4580b97ec337d1b3bf293803dcc8acb"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa4580b97ec337d1b3bf293803dcc8acb">implementsArrayConcept</a> ()</td></tr>
<tr class="memdesc:aa4580b97ec337d1b3bf293803dcc8acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code>ArrayConcept</code>.  <a href="namespacetfel_1_1math.html#aa4580b97ec337d1b3bf293803dcc8acb">More...</a><br /></td></tr>
<tr class="separator:aa4580b97ec337d1b3bf293803dcc8acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa526bbcc59e298b1248eb27bcd7bcc68"><td class="memTemplParams" colspan="2">template&lt;typename ArrayPolicyType &gt; </td></tr>
<tr class="memitem:aa526bbcc59e298b1248eb27bcd7bcc68"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa526bbcc59e298b1248eb27bcd7bcc68">hasArrayPolicyFixedSizes</a> ()</td></tr>
<tr class="separator:aa526bbcc59e298b1248eb27bcd7bcc68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c59691d17f54f06a7c695d50a334153"><td class="memTemplParams" colspan="2">template&lt;typename ArrayPolicyType &gt; </td></tr>
<tr class="memitem:a2c59691d17f54f06a7c695d50a334153"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2c59691d17f54f06a7c695d50a334153">getArrayPolicySize</a> ()</td></tr>
<tr class="separator:a2c59691d17f54f06a7c695d50a334153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295dd7bbf51747fb8f571773e1df3937"><td class="memTemplParams" colspan="2">template&lt;typename ArrayPolicyType &gt; </td></tr>
<tr class="memitem:a295dd7bbf51747fb8f571773e1df3937"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a295dd7bbf51747fb8f571773e1df3937">getArrayPolicyMinimalDataSize</a> ()</td></tr>
<tr class="separator:a295dd7bbf51747fb8f571773e1df3937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e847d1c24567cea3f45361f8daf4fba"><td class="memTemplParams" colspan="2">template&lt;typename ArrayPolicyType &gt; </td></tr>
<tr class="memitem:a0e847d1c24567cea3f45361f8daf4fba"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0e847d1c24567cea3f45361f8daf4fba">hasArrayPolicyFixedSizes</a> ()</td></tr>
<tr class="separator:a0e847d1c24567cea3f45361f8daf4fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da9373d9580cf05602537b786ae3c77"><td class="memTemplParams" colspan="2"><a id="a1da9373d9580cf05602537b786ae3c77"></a>
template&lt;typename Array1 , typename Array2 , index_type&lt; FixedSizeArrayDerivative&lt; Array1, Array2 &gt;&gt;... I1, index_type&lt; FixedSizeArrayDerivative&lt; Array1, Array2 &gt;&gt;... I2&gt; </td></tr>
<tr class="memitem:a1da9373d9580cf05602537b786ae3c77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getValue</b> (<a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt; &amp;a, const std::array&lt; <a class="el" href="namespacetfel_1_1math.html#acf42373bf172e38d879a8eb8666402fd">index_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt;&gt;, Array1::indexing_policy::arity &gt; &amp;i1, const std::array&lt; <a class="el" href="namespacetfel_1_1math.html#acf42373bf172e38d879a8eb8666402fd">index_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt;&gt;, Array2::indexing_policy::arity &gt; &amp;i2, const std::integer_sequence&lt; <a class="el" href="namespacetfel_1_1math.html#acf42373bf172e38d879a8eb8666402fd">index_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt;&gt;, I1... &gt; &amp;, const std::integer_sequence&lt; <a class="el" href="namespacetfel_1_1math.html#acf42373bf172e38d879a8eb8666402fd">index_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt;&gt;, I2... &gt; &amp;)</td></tr>
<tr class="separator:a1da9373d9580cf05602537b786ae3c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91d75c74bb688f8a17920bcd2ec18e0"><td class="memTemplParams" colspan="2"><a id="aa91d75c74bb688f8a17920bcd2ec18e0"></a>
template&lt;typename Array1 , typename Array2 &gt; </td></tr>
<tr class="memitem:aa91d75c74bb688f8a17920bcd2ec18e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getValue</b> (<a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt; &amp;a, const std::array&lt; <a class="el" href="namespacetfel_1_1math.html#acf42373bf172e38d879a8eb8666402fd">index_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt;&gt;, Array1::indexing_policy::arity &gt; &amp;i1, const std::array&lt; <a class="el" href="namespacetfel_1_1math.html#acf42373bf172e38d879a8eb8666402fd">index_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt;&gt;, Array2::indexing_policy::arity &gt; &amp;i2)</td></tr>
<tr class="separator:aa91d75c74bb688f8a17920bcd2ec18e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e54e8638391cce43adfdbd4de66759"><td class="memTemplParams" colspan="2"><a id="a97e54e8638391cce43adfdbd4de66759"></a>
template&lt;typename Array1 , typename Array2 , index_type&lt; FixedSizeArrayDerivative&lt; Array1, Array2 &gt;&gt;... I1, index_type&lt; FixedSizeArrayDerivative&lt; Array1, Array2 &gt;&gt;... I2&gt; </td></tr>
<tr class="memitem:a97e54e8638391cce43adfdbd4de66759"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getValue</b> (const <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt; &amp;a, const std::array&lt; <a class="el" href="namespacetfel_1_1math.html#acf42373bf172e38d879a8eb8666402fd">index_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt;&gt;, Array1::indexing_policy::arity &gt; &amp;i1, const std::array&lt; <a class="el" href="namespacetfel_1_1math.html#acf42373bf172e38d879a8eb8666402fd">index_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt;&gt;, Array2::indexing_policy::arity &gt; &amp;i2, const std::integer_sequence&lt; <a class="el" href="namespacetfel_1_1math.html#acf42373bf172e38d879a8eb8666402fd">index_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt;&gt;, I1... &gt; &amp;, const std::integer_sequence&lt; <a class="el" href="namespacetfel_1_1math.html#acf42373bf172e38d879a8eb8666402fd">index_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt;&gt;, I2... &gt; &amp;)</td></tr>
<tr class="separator:a97e54e8638391cce43adfdbd4de66759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a68d5da5525f9225763fffbff513ee"><td class="memTemplParams" colspan="2"><a id="a15a68d5da5525f9225763fffbff513ee"></a>
template&lt;typename Array1 , typename Array2 &gt; </td></tr>
<tr class="memitem:a15a68d5da5525f9225763fffbff513ee"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getValue</b> (const <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt; &amp;a, const std::array&lt; <a class="el" href="namespacetfel_1_1math.html#acf42373bf172e38d879a8eb8666402fd">index_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt;&gt;, Array1::indexing_policy::arity &gt; &amp;i1, const std::array&lt; <a class="el" href="namespacetfel_1_1math.html#acf42373bf172e38d879a8eb8666402fd">index_type</a>&lt; <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array1, Array2 &gt;&gt;, Array2::indexing_policy::arity &gt; &amp;i2)</td></tr>
<tr class="separator:a15a68d5da5525f9225763fffbff513ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe35829771d0bc8afb086a4d96495d28"><td class="memTemplParams" colspan="2"><a id="afe35829771d0bc8afb086a4d96495d28"></a>
template&lt;typename Array11 , typename Array12 , typename Array21 , typename Array22 &gt; </td></tr>
<tr class="memitem:afe35829771d0bc8afb086a4d96495d28"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array11, Array22 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array11, Array12 &gt; &amp;a, const <a class="el" href="structtfel_1_1math_1_1_fixed_size_array_derivative.html">FixedSizeArrayDerivative</a>&lt; Array21, Array22 &gt; &amp;b)</td></tr>
<tr class="separator:afe35829771d0bc8afb086a4d96495d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fc287521de837c9e662fbc2814f401"><td class="memTemplParams" colspan="2"><a id="ab0fc287521de837c9e662fbc2814f401"></a>
template&lt;typename IndexingPolicy &gt; </td></tr>
<tr class="memitem:ab0fc287521de837c9e662fbc2814f401"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getUnderlyingArrayMinimalSize</b> ()</td></tr>
<tr class="separator:ab0fc287521de837c9e662fbc2814f401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1452ce7541b8a7a34e565be078c81ff"><td class="memTemplParams" colspan="2"><a id="ac1452ce7541b8a7a34e565be078c81ff"></a>
template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:ac1452ce7541b8a7a34e565be078c81ff"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1fsarray.html">fsarray</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="separator:ac1452ce7541b8a7a34e565be078c81ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec6842b43fdb947b4b7a1fbb5d6402f"><td class="memItemLeft" align="right" valign="top"><a id="a8ec6842b43fdb947b4b7a1fbb5d6402f"></a>
constexpr TFEL_HOST_DEVICE&#160;</td><td class="memItemRight" valign="bottom"><b>Child</b> ()) &amp;&amp;(!std</td></tr>
<tr class="separator:a8ec6842b43fdb947b4b7a1fbb5d6402f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b459f682995f0219538b45d902193c"><td class="memItemLeft" align="right" valign="top"><a id="ad8b459f682995f0219538b45d902193c"></a>
constexpr TFEL_HOST_DEVICE Child&#160;</td><td class="memItemRight" valign="bottom"><b>Child</b> ())</td></tr>
<tr class="separator:ad8b459f682995f0219538b45d902193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae467b6055157e814590865cd45c95d4"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy , typename... Indices&gt; </td></tr>
<tr class="memitem:aae467b6055157e814590865cd45c95d4"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aae467b6055157e814590865cd45c95d4">checkIndicesValiditity</a> () noexcept</td></tr>
<tr class="memdesc:aae467b6055157e814590865cd45c95d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple function to check that the type of the indices are compatible with the given indexing policy  <a href="namespacetfel_1_1math.html#aae467b6055157e814590865cd45c95d4">More...</a><br /></td></tr>
<tr class="separator:aae467b6055157e814590865cd45c95d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b14ccb6f9ba60d621b977572293ad9"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </td></tr>
<tr class="memitem:a88b14ccb6f9ba60d621b977572293ad9"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a88b14ccb6f9ba60d621b977572293ad9">checkIndexingPoliciesCompatiblity</a> ()</td></tr>
<tr class="memdesc:a88b14ccb6f9ba60d621b977572293ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two indexing policies can be compatible.  <a href="namespacetfel_1_1math.html#a88b14ccb6f9ba60d621b977572293ad9">More...</a><br /></td></tr>
<tr class="separator:a88b14ccb6f9ba60d621b977572293ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2482dac276fb6d101662603b4a95ea"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </td></tr>
<tr class="memitem:afb2482dac276fb6d101662603b4a95ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#afb2482dac276fb6d101662603b4a95ea">haveIndexingPoliciesTheSameMemoryLayout</a> ()</td></tr>
<tr class="separator:afb2482dac276fb6d101662603b4a95ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f62f75674bfb14650e599b39b242ee1"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </td></tr>
<tr class="memitem:a4f62f75674bfb14650e599b39b242ee1"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4f62f75674bfb14650e599b39b242ee1">areIndexingPoliciesCompatibleAtRunTime</a> (const IndexingPolicy1 &amp;, const IndexingPolicy2 &amp;)</td></tr>
<tr class="separator:a4f62f75674bfb14650e599b39b242ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a1978aaac3db5b83d137766c816e17"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </td></tr>
<tr class="memitem:ac6a1978aaac3db5b83d137766c816e17"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac6a1978aaac3db5b83d137766c816e17">checkIndexingPoliciesRuntimeCompatiblity</a> (const IndexingPolicy1 &amp;, const IndexingPolicy2 &amp;)</td></tr>
<tr class="memdesc:ac6a1978aaac3db5b83d137766c816e17"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two indexing policies are compatible at runtime.  <a href="namespacetfel_1_1math.html#ac6a1978aaac3db5b83d137766c816e17">More...</a><br /></td></tr>
<tr class="separator:ac6a1978aaac3db5b83d137766c816e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698bd2b94d7b21bda328c8ff54b7aba2"><td class="memTemplParams" colspan="2"><a id="a698bd2b94d7b21bda328c8ff54b7aba2"></a>
template&lt;typename IndexingPolicy , typename... T, std::size_t... I&gt; </td></tr>
<tr class="memitem:a698bd2b94d7b21bda328c8ff54b7aba2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>buildIndexingPolicyFromTuple</b> (const std::tuple&lt; T... &gt; &amp;, const std::index_sequence&lt; I... &gt; &amp;)</td></tr>
<tr class="separator:a698bd2b94d7b21bda328c8ff54b7aba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7a13f00082611c06ef013e038ec0d9"><td class="memTemplParams" colspan="2"><a id="a9c7a13f00082611c06ef013e038ec0d9"></a>
template&lt;typename IndexingPolicy , typename... Args&gt; </td></tr>
<tr class="memitem:a9c7a13f00082611c06ef013e038ec0d9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>buildIndexingPolicyAndExtractPointerToData</b> (Args &amp;... args)</td></tr>
<tr class="separator:a9c7a13f00082611c06ef013e038ec0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6666876b2276f2ee69e574f0d53371"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a6666876b2276f2ee69e574f0d53371"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8a6666876b2276f2ee69e574f0d53371">hasIndexingPolicy</a> ()</td></tr>
<tr class="memdesc:a8a6666876b2276f2ee69e574f0d53371"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple metafunction which looks if the given type provides an internal type called <code>indexing_policy</code>  <a href="namespacetfel_1_1math.html#a8a6666876b2276f2ee69e574f0d53371">More...</a><br /></td></tr>
<tr class="separator:a8a6666876b2276f2ee69e574f0d53371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331c0a1318f53ec008ca94d6576d179a"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </td></tr>
<tr class="memitem:a331c0a1318f53ec008ca94d6576d179a"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a331c0a1318f53ec008ca94d6576d179a">checkIndexingPoliciesCompatiblity</a> ()</td></tr>
<tr class="memdesc:a331c0a1318f53ec008ca94d6576d179a"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two indexing policies can be compatible.  <a href="namespacetfel_1_1math.html#a331c0a1318f53ec008ca94d6576d179a">More...</a><br /></td></tr>
<tr class="separator:a331c0a1318f53ec008ca94d6576d179a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6978e9e809a086d009ee40a12b87d169"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </td></tr>
<tr class="memitem:a6978e9e809a086d009ee40a12b87d169"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6978e9e809a086d009ee40a12b87d169">haveIndexingPoliciesTheSameMemoryLayout</a> ()</td></tr>
<tr class="separator:a6978e9e809a086d009ee40a12b87d169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2a5bfed11bc018f14af36d6bfdd82b"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </td></tr>
<tr class="memitem:a0f2a5bfed11bc018f14af36d6bfdd82b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0f2a5bfed11bc018f14af36d6bfdd82b">areIndexingPoliciesCompatibleAtRunTime</a> (const IndexingPolicy1 &amp;p1, const IndexingPolicy2 &amp;p2)</td></tr>
<tr class="separator:a0f2a5bfed11bc018f14af36d6bfdd82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada78dd532490845171f78ffb4aa07641"><td class="memTemplParams" colspan="2">template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </td></tr>
<tr class="memitem:ada78dd532490845171f78ffb4aa07641"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ada78dd532490845171f78ffb4aa07641">checkIndexingPoliciesRuntimeCompatiblity</a> (const IndexingPolicy1 &amp;p1, const IndexingPolicy2 &amp;p2)</td></tr>
<tr class="memdesc:ada78dd532490845171f78ffb4aa07641"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if two indexing policies are compatible at runtime.  <a href="namespacetfel_1_1math.html#ada78dd532490845171f78ffb4aa07641">More...</a><br /></td></tr>
<tr class="separator:ada78dd532490845171f78ffb4aa07641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4415c9d4b3406ee33b6b544ba53b5217"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4415c9d4b3406ee33b6b544ba53b5217"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4415c9d4b3406ee33b6b544ba53b5217">hasIndexingPolicy</a> ()</td></tr>
<tr class="memdesc:a4415c9d4b3406ee33b6b544ba53b5217"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple metafunction which looks if the given type provides an internal type called <code>indexing_policy</code>  <a href="namespacetfel_1_1math.html#a4415c9d4b3406ee33b6b544ba53b5217">More...</a><br /></td></tr>
<tr class="separator:a4415c9d4b3406ee33b6b544ba53b5217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09487945b147a74edaf11aa46ed495c"><td class="memTemplParams" colspan="2"><a id="ac09487945b147a74edaf11aa46ed495c"></a>
template&lt;typename UnaryOperator , typename FirstArgument &gt; </td></tr>
<tr class="memitem:ac09487945b147a74edaf11aa46ed495c"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1_multi_indices_unary_operator_functor.html">MultiIndicesUnaryOperatorFunctor</a>&lt; UnaryOperator, FirstArgument &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeMultiIndicesUnaryOperatorFunctor</b> (FirstArgument &amp;a)</td></tr>
<tr class="separator:ac09487945b147a74edaf11aa46ed495c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9f824ef1a142954ba458cfa1ab5bd2"><td class="memTemplParams" colspan="2"><a id="aeb9f824ef1a142954ba458cfa1ab5bd2"></a>
template&lt;typename UnaryOperator , typename FirstArgument &gt; </td></tr>
<tr class="memitem:aeb9f824ef1a142954ba458cfa1ab5bd2"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1_multi_indices_unary_operator_functor.html">MultiIndicesUnaryOperatorFunctor</a>&lt; UnaryOperator, FirstArgument &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeMultiIndicesUnaryOperatorFunctor</b> (const UnaryOperator &amp;o, FirstArgument &amp;a)</td></tr>
<tr class="separator:aeb9f824ef1a142954ba458cfa1ab5bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae932d5af4bfa5c7f588690d19bd856da"><td class="memTemplParams" colspan="2"><a id="ae932d5af4bfa5c7f588690d19bd856da"></a>
template&lt;typename BinaryOperator , typename FirstArgument , typename SecondArgument &gt; </td></tr>
<tr class="memitem:ae932d5af4bfa5c7f588690d19bd856da"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1_multi_indices_binary_operator_functor.html">MultiIndicesBinaryOperatorFunctor</a>&lt; BinaryOperator, FirstArgument, SecondArgument &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeMultiIndicesBinaryOperatorFunctor</b> (FirstArgument &amp;a, SecondArgument &amp;b)</td></tr>
<tr class="separator:ae932d5af4bfa5c7f588690d19bd856da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63da621d1de670fcb1542f9ff35804dd"><td class="memTemplParams" colspan="2"><a id="a63da621d1de670fcb1542f9ff35804dd"></a>
template&lt;typename BinaryOperator , typename FirstArgument , typename SecondArgument &gt; </td></tr>
<tr class="memitem:a63da621d1de670fcb1542f9ff35804dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1_multi_indices_binary_operator_functor.html">MultiIndicesBinaryOperatorFunctor</a>&lt; BinaryOperator, FirstArgument, SecondArgument &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeMultiIndicesBinaryOperatorFunctor</b> (const BinaryOperator &amp;o, FirstArgument &amp;a, const SecondArgument &amp;b)</td></tr>
<tr class="separator:a63da621d1de670fcb1542f9ff35804dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba04f7a303adea5c227957145a62b6ae"><td class="memTemplParams" colspan="2"><a id="aba04f7a303adea5c227957145a62b6ae"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba04f7a303adea5c227957145a62b6ae"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1runtime__array.html">runtime_array</a>&lt; T &gt; &amp;)</td></tr>
<tr class="separator:aba04f7a303adea5c227957145a62b6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc09bffa260485018e23c42abd88abd"><td class="memTemplParams" colspan="2"><a id="acdc09bffa260485018e23c42abd88abd"></a>
template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:acdc09bffa260485018e23c42abd88abd"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="namespacetfel_1_1math.html#ab76cb3f290377f36ba39de985aef57a0">scalar_view</a>&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (<a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; ScalarType &gt; *const p) requires(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; ScalarType &gt;())</td></tr>
<tr class="separator:acdc09bffa260485018e23c42abd88abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56a3733b4f43824aa11d977856dc287"><td class="memTemplParams" colspan="2"><a id="ae56a3733b4f43824aa11d977856dc287"></a>
template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:ae56a3733b4f43824aa11d977856dc287"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="namespacetfel_1_1math.html#ab76cb3f290377f36ba39de985aef57a0">scalar_view</a>&lt; ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (<a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; ScalarType &gt; &amp;v) requires(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; ScalarType &gt;())</td></tr>
<tr class="separator:ae56a3733b4f43824aa11d977856dc287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb3a4cd6d1a1fb3854d4aa6f7483e9d"><td class="memTemplParams" colspan="2"><a id="a3bb3a4cd6d1a1fb3854d4aa6f7483e9d"></a>
template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a3bb3a4cd6d1a1fb3854d4aa6f7483e9d"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="namespacetfel_1_1math.html#ab76cb3f290377f36ba39de985aef57a0">scalar_view</a>&lt; const ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (const <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; ScalarType &gt; *const p) requires(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; ScalarType &gt;())</td></tr>
<tr class="separator:a3bb3a4cd6d1a1fb3854d4aa6f7483e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0783f3192ab71648e05727b6af25cc"><td class="memTemplParams" colspan="2"><a id="a3a0783f3192ab71648e05727b6af25cc"></a>
template&lt;typename ScalarType &gt; </td></tr>
<tr class="memitem:a3a0783f3192ab71648e05727b6af25cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="namespacetfel_1_1math.html#ab76cb3f290377f36ba39de985aef57a0">scalar_view</a>&lt; const ScalarType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (const <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; ScalarType &gt; &amp;v) requires(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; ScalarType &gt;())</td></tr>
<tr class="separator:a3a0783f3192ab71648e05727b6af25cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c3d10e6170c55da38ecef0d529d915"><td class="memTemplParams" colspan="2">template&lt;typename MappedType , typename IndexingPolicyType  = typename MappedType::indexing_policy&gt; </td></tr>
<tr class="memitem:a96c3d10e6170c55da38ecef0d529d915"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; MappedType, IndexingPolicyType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a96c3d10e6170c55da38ecef0d529d915">map</a> (const ViewDataPointerType&lt; MappedType &gt; p) requires((!std</td></tr>
<tr class="memdesc:a96c3d10e6170c55da38ecef0d529d915"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a view from a memory area  <a href="namespacetfel_1_1math.html#a96c3d10e6170c55da38ecef0d529d915">More...</a><br /></td></tr>
<tr class="separator:a96c3d10e6170c55da38ecef0d529d915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6139a9e7883569e0d5d44beec5c556"><td class="memTemplParams" colspan="2"><a id="adf6139a9e7883569e0d5d44beec5c556"></a>
template&lt;typename MappedType , typename IndexingPolicyType  = typename std::remove_cv_t&lt;MappedType&gt;::indexing_policy&gt; </td></tr>
<tr class="memitem:adf6139a9e7883569e0d5d44beec5c556"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; const MappedType, IndexingPolicyType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (const ViewConstDataPointerType&lt; MappedType &gt; p) requires((!<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; MappedType &gt;()) &amp;&amp;(std</td></tr>
<tr class="separator:adf6139a9e7883569e0d5d44beec5c556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a993124d1019d66162dcc8cbfe645f307"><td class="memTemplParams" colspan="2"><a id="a993124d1019d66162dcc8cbfe645f307"></a>
template&lt;typename MappedType , typename... Args&gt; </td></tr>
<tr class="memitem:a993124d1019d66162dcc8cbfe645f307"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a993124d1019d66162dcc8cbfe645f307">canMakeViewFromLastArgument</a> ()</td></tr>
<tr class="memdesc:a993124d1019d66162dcc8cbfe645f307"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper metafunction which check of the last type of the type list is convertible to a pointer to a memory area that can be used to create a view. <br /></td></tr>
<tr class="separator:a993124d1019d66162dcc8cbfe645f307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0892f68b26e3bde4de26f70782ed2d0"><td class="memTemplParams" colspan="2"><a id="ae0892f68b26e3bde4de26f70782ed2d0"></a>
template&lt;typename MappedType , typename... Args&gt; </td></tr>
<tr class="memitem:ae0892f68b26e3bde4de26f70782ed2d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae0892f68b26e3bde4de26f70782ed2d0">canMakeConstViewFromLastArgument</a> ()</td></tr>
<tr class="memdesc:ae0892f68b26e3bde4de26f70782ed2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper metafunction which check of the last type of the type list is convertible to a const pointer to a memory area that can be used to create a view. <br /></td></tr>
<tr class="separator:ae0892f68b26e3bde4de26f70782ed2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ed3cf8d70cebb3ac06426943485a3f"><td class="memTemplParams" colspan="2"><a id="ac0ed3cf8d70cebb3ac06426943485a3f"></a>
template&lt;typename MappedType , typename... Args, typename IndexingPolicyType  = typename MappedType::indexing_policy&gt; </td></tr>
<tr class="memitem:ac0ed3cf8d70cebb3ac06426943485a3f"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; MappedType, IndexingPolicyType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac0ed3cf8d70cebb3ac06426943485a3f">map</a> (Args &amp;&amp;... args) requires((!std</td></tr>
<tr class="memdesc:ac0ed3cf8d70cebb3ac06426943485a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a view from a memory area <br /></td></tr>
<tr class="separator:ac0ed3cf8d70cebb3ac06426943485a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e6ffc118d6c62c87be8b388339a3da"><td class="memTemplParams" colspan="2"><a id="a92e6ffc118d6c62c87be8b388339a3da"></a>
template&lt;typename MappedType , typename... Args, typename IndexingPolicyType  = typename std::remove_cv_t&lt;MappedType&gt;::indexing_policy&gt; </td></tr>
<tr class="memitem:a92e6ffc118d6c62c87be8b388339a3da"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt; const MappedType, IndexingPolicyType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a92e6ffc118d6c62c87be8b388339a3da">map</a> (const Args &amp;... args) requires((!std</td></tr>
<tr class="memdesc:a92e6ffc118d6c62c87be8b388339a3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a view from a memory area <br /></td></tr>
<tr class="separator:a92e6ffc118d6c62c87be8b388339a3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc565bd93d818874a327dc9140022539"><td class="memTemplParams" colspan="2"><a id="abc565bd93d818874a327dc9140022539"></a>
template&lt;typename MappedType &gt; </td></tr>
<tr class="memitem:abc565bd93d818874a327dc9140022539"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#abc565bd93d818874a327dc9140022539">getViewsArrayMinimalStride</a> ()</td></tr>
<tr class="memdesc:abc565bd93d818874a327dc9140022539"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the minimal size required to a store the given object <br /></td></tr>
<tr class="separator:abc565bd93d818874a327dc9140022539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac12bf9ca166925db35f3313e72b9929"><td class="memTemplParams" colspan="2"><a id="aac12bf9ca166925db35f3313e72b9929"></a>
template&lt;typename ArrayType &gt; </td></tr>
<tr class="memitem:aac12bf9ca166925db35f3313e72b9929"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_array</b> (const <a class="el" href="namespacetfel_1_1math.html#a22ee62421d92643599d399646e39b1c2">ViewsArrayDataPointerType</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; ArrayType &gt;&gt; p)</td></tr>
<tr class="separator:aac12bf9ca166925db35f3313e72b9929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513a1092af4e5fa697f739812ffbe30b"><td class="memTemplParams" colspan="2"><a id="a513a1092af4e5fa697f739812ffbe30b"></a>
template&lt;typename MappedType , typename MemoryIndexingPolicyType , typename ViewIndexingPolicyType &gt; </td></tr>
<tr class="memitem:a513a1092af4e5fa697f739812ffbe30b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structtfel_1_1math_1_1_views_array.html">ViewsArray</a>&lt; MappedType, MemoryIndexingPolicyType, ViewIndexingPolicyType &gt; &amp;a)</td></tr>
<tr class="separator:a513a1092af4e5fa697f739812ffbe30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa578f04d6447731cf0f1172b63b81d71"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </td></tr>
<tr class="memitem:aa578f04d6447731cf0f1172b63b81d71"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa578f04d6447731cf0f1172b63b81d71">broyden</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, T &gt; &amp;, const T, const unsigned short)</td></tr>
<tr class="separator:aa578f04d6447731cf0f1172b63b81d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380c8452ec4b01ff8ed3096ae8e229a4"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </td></tr>
<tr class="memitem:a380c8452ec4b01ff8ed3096ae8e229a4"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a380c8452ec4b01ff8ed3096ae8e229a4">broyden</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, const T, const unsigned short)</td></tr>
<tr class="separator:a380c8452ec4b01ff8ed3096ae8e229a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96bcf9320cc0ea1527878c464eaa1e8"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </td></tr>
<tr class="memitem:ab96bcf9320cc0ea1527878c464eaa1e8"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab96bcf9320cc0ea1527878c464eaa1e8">broyden2</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, T &gt; &amp;, const T, const unsigned short)</td></tr>
<tr class="separator:ab96bcf9320cc0ea1527878c464eaa1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0955c3da239e6c30ad743a8d5f320e10"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </td></tr>
<tr class="memitem:a0955c3da239e6c30ad743a8d5f320e10"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0955c3da239e6c30ad743a8d5f320e10">broyden2</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, const T, const unsigned short)</td></tr>
<tr class="separator:a0955c3da239e6c30ad743a8d5f320e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a6bf76a5c223f4b3d832d7cbb19840"><td class="memTemplParams" colspan="2">template&lt;bool extrapolate, typename CollocationPointContainer , typename AbscissaType &gt; </td></tr>
<tr class="memitem:ab8a6bf76a5c223f4b3d832d7cbb19840"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab8a6bf76a5c223f4b3d832d7cbb19840">computeCubicSplineInterpolation</a> (const CollocationPointContainer &amp;, const AbscissaType)</td></tr>
<tr class="separator:ab8a6bf76a5c223f4b3d832d7cbb19840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec33c3e7b08d2989259a952cb0f588f"><td class="memTemplParams" colspan="2">template&lt;bool extrapolate, typename CollocationPointContainer , typename AbscissaType &gt; </td></tr>
<tr class="memitem:a2ec33c3e7b08d2989259a952cb0f588f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2ec33c3e7b08d2989259a952cb0f588f">computeCubicSplineInterpolationAndDerivative</a> (const CollocationPointContainer &amp;, const AbscissaType)</td></tr>
<tr class="separator:a2ec33c3e7b08d2989259a952cb0f588f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add78759d62a38f9554085c8ecf781d4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add78759d62a38f9554085c8ecf781d4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#add78759d62a38f9554085c8ecf781d4d">geometricDiscretization</a> (T &amp;v, const typename T::value_type, const typename T::value_type, const typename T::value_type, const typename T::value_type, const typename T::size_type)</td></tr>
<tr class="memdesc:add78759d62a38f9554085c8ecf781d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">discretize a segment into a fixed number of elements trying to satisfy as much as possible given discretization densities at the beginning and the end of the segment. Elements size grows according to a geometric progression.  <a href="namespacetfel_1_1math.html#add78759d62a38f9554085c8ecf781d4d">More...</a><br /></td></tr>
<tr class="separator:add78759d62a38f9554085c8ecf781d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce654ea4324ea12243df2df8283582e"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename Operation &gt; </td></tr>
<tr class="memitem:a5ce654ea4324ea12243df2df8283582e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5ce654ea4324ea12243df2df8283582e">eval</a> (const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>, Operation &gt; &amp;e)</td></tr>
<tr class="memdesc:a5ce654ea4324ea12243df2df8283582e"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate an expression  <a href="namespacetfel_1_1math.html#a5ce654ea4324ea12243df2df8283582e">More...</a><br /></td></tr>
<tr class="separator:a5ce654ea4324ea12243df2df8283582e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721334a6647265d30ab99fe497973966"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:a721334a6647265d30ab99fe497973966"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a721334a6647265d30ab99fe497973966">operator-</a> (T1 &amp;&amp;a) noexcept -&gt; <a class="el" href="namespacetfel_1_1math.html#a223f10977fb55f4581bbe021800bcf4c">UnaryOperationHandler</a>&lt; decltype(a), OpNeg &gt; requires((!<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T1 &gt;()) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a6292a7c384f0948638525b508e213de7">isUnaryOperationResultTypeValid</a>&lt; decltype(a), OpNeg &gt;()) &amp;&amp;(!<a class="el" href="namespacetfel_1_1math.html#ac32a69a130c0d7dfdd5860981401e860">isInvalid</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a223f10977fb55f4581bbe021800bcf4c">UnaryOperationHandler</a>&lt; decltype(a), OpNeg &gt;&gt;()))</td></tr>
<tr class="memdesc:a721334a6647265d30ab99fe497973966"><td class="mdescLeft">&#160;</td><td class="mdescRight">negate a mathematical object  <a href="namespacetfel_1_1math.html#a721334a6647265d30ab99fe497973966">More...</a><br /></td></tr>
<tr class="separator:a721334a6647265d30ab99fe497973966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c9780f20804d1173f52cd2ed109e23"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a83c9780f20804d1173f52cd2ed109e23"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a83c9780f20804d1173f52cd2ed109e23">operator+</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) noexcept -&gt; <a class="el" href="namespacetfel_1_1math.html#a21f46866ed03b641861851d837909263">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), OpPlus &gt; requires((<a class="el" href="namespacetfel_1_1math.html#aaae1241d6d75bc14b37305447a79256a">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), OpPlus &gt;()) &amp;&amp;(!((<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T1 &gt;()) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T2 &gt;()))))</td></tr>
<tr class="memdesc:a83c9780f20804d1173f52cd2ed109e23"><td class="mdescLeft">&#160;</td><td class="mdescRight">add to mathematical object  <a href="namespacetfel_1_1math.html#a83c9780f20804d1173f52cd2ed109e23">More...</a><br /></td></tr>
<tr class="separator:a83c9780f20804d1173f52cd2ed109e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad810d64b41d9017c7640ae221a7266ae"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad810d64b41d9017c7640ae221a7266ae"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad810d64b41d9017c7640ae221a7266ae">operator-</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) noexcept -&gt; <a class="el" href="namespacetfel_1_1math.html#a21f46866ed03b641861851d837909263">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), OpMinus &gt; requires((<a class="el" href="namespacetfel_1_1math.html#aaae1241d6d75bc14b37305447a79256a">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), OpMinus &gt;()) &amp;&amp;(!((<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T1 &gt;()) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T2 &gt;()))))</td></tr>
<tr class="memdesc:ad810d64b41d9017c7640ae221a7266ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">substract to mathematical object  <a href="namespacetfel_1_1math.html#ad810d64b41d9017c7640ae221a7266ae">More...</a><br /></td></tr>
<tr class="separator:ad810d64b41d9017c7640ae221a7266ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7beb69fa9bc7ed13e98051cf5bab1621"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a7beb69fa9bc7ed13e98051cf5bab1621"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7beb69fa9bc7ed13e98051cf5bab1621">operator*</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) noexcept -&gt; <a class="el" href="namespacetfel_1_1math.html#a21f46866ed03b641861851d837909263">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), OpMult &gt; requires((<a class="el" href="namespacetfel_1_1math.html#aaae1241d6d75bc14b37305447a79256a">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), OpMult &gt;()) &amp;&amp;(!((<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T1 &gt;()) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T2 &gt;()))))</td></tr>
<tr class="memdesc:a7beb69fa9bc7ed13e98051cf5bab1621"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply to mathematical object  <a href="namespacetfel_1_1math.html#a7beb69fa9bc7ed13e98051cf5bab1621">More...</a><br /></td></tr>
<tr class="separator:a7beb69fa9bc7ed13e98051cf5bab1621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0b901feaedc6089cfc4c3790627751"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aef0b901feaedc6089cfc4c3790627751"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aef0b901feaedc6089cfc4c3790627751">operator/</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) noexcept -&gt; <a class="el" href="namespacetfel_1_1math.html#a21f46866ed03b641861851d837909263">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), OpDiv &gt; requires((<a class="el" href="namespacetfel_1_1math.html#aaae1241d6d75bc14b37305447a79256a">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), OpDiv &gt;()) &amp;&amp;(!((<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T1 &gt;()) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T2 &gt;()))))</td></tr>
<tr class="memdesc:aef0b901feaedc6089cfc4c3790627751"><td class="mdescLeft">&#160;</td><td class="mdescRight">divide a mathematical object by another  <a href="namespacetfel_1_1math.html#aef0b901feaedc6089cfc4c3790627751">More...</a><br /></td></tr>
<tr class="separator:aef0b901feaedc6089cfc4c3790627751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acedfea91e71a020b1c8c3b7b5b824dfd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:acedfea91e71a020b1c8c3b7b5b824dfd"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#acedfea91e71a020b1c8c3b7b5b824dfd">operator^</a> (T1 &amp;&amp;a, T2 &amp;&amp;b) noexcept -&gt; <a class="el" href="namespacetfel_1_1math.html#a21f46866ed03b641861851d837909263">BinaryOperationHandler</a>&lt; decltype(a), decltype(b), OpDiadicProduct &gt; requires((<a class="el" href="namespacetfel_1_1math.html#aaae1241d6d75bc14b37305447a79256a">isBinaryOperationResultTypeValid</a>&lt; decltype(a), decltype(b), OpDiadicProduct &gt;()) &amp;&amp;(!((<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T1 &gt;()) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T2 &gt;()))))</td></tr>
<tr class="memdesc:acedfea91e71a020b1c8c3b7b5b824dfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">diadic product between two mathematical objects  <a href="namespacetfel_1_1math.html#acedfea91e71a020b1c8c3b7b5b824dfd">More...</a><br /></td></tr>
<tr class="separator:acedfea91e71a020b1c8c3b7b5b824dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39472ec66a29e42a7851d566a5304f2"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:ae39472ec66a29e42a7851d566a5304f2"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae39472ec66a29e42a7851d566a5304f2">regularisedFischerBurmeisterFunction</a> (const real &amp;, const real &amp;, const real &amp;=real{})</td></tr>
<tr class="memdesc:ae39472ec66a29e42a7851d566a5304f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a regularised version of the Fischer-Burmeister function defined by: [ f\left(x,y)=x+y-\sqrt{x^{2}+y^{2}+\varepsilon^{2}} ] This function is such that: [ f\left(x,y)=0 \RighatArrow x\leq 0, y\leq 0 and \sqrt{2\,x\,y}=\varepsilon^{2} ]  <a href="namespacetfel_1_1math.html#ae39472ec66a29e42a7851d566a5304f2">More...</a><br /></td></tr>
<tr class="separator:ae39472ec66a29e42a7851d566a5304f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b44a8d886f9e1a6748429141a4bb99"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:ae6b44a8d886f9e1a6748429141a4bb99"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::tuple&lt; real, real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae6b44a8d886f9e1a6748429141a4bb99">regularisedFischerBurmeisterFunctionFirstDerivatives</a> (const real &amp;, const real &amp;, const real &amp;)</td></tr>
<tr class="separator:ae6b44a8d886f9e1a6748429141a4bb99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6373c72a52fe938120ffcfb6a6952789"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:a6373c72a52fe938120ffcfb6a6952789"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6373c72a52fe938120ffcfb6a6952789">squaredFischerBurmeisterFunction</a> (const real &amp;, const real &amp;)</td></tr>
<tr class="separator:a6373c72a52fe938120ffcfb6a6952789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae946a12af0950352569b2d4961fac39f"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:ae946a12af0950352569b2d4961fac39f"><td class="memTemplItemLeft" align="right" valign="top">TFEL_MATH_INLINE std::tuple&lt; real, real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae946a12af0950352569b2d4961fac39f">squaredFischerBurmeisterFunctionFirstDerivatives</a> (const real &amp;, const real &amp;)</td></tr>
<tr class="separator:ae946a12af0950352569b2d4961fac39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af944b60fb53c166c7f8f18f25fc2f702"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:af944b60fb53c166c7f8f18f25fc2f702"><td class="memTemplItemLeft" align="right" valign="top">real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af944b60fb53c166c7f8f18f25fc2f702">regularisedFischerBurmeisterFunction</a> (const real &amp;x, const real &amp;y, const real &amp;e)</td></tr>
<tr class="memdesc:af944b60fb53c166c7f8f18f25fc2f702"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a regularised version of the Fischer-Burmeister function defined by: [ f\left(x,y)=x+y-\sqrt{x^{2}+y^{2}+\varepsilon^{2}} ] This function is such that: [ f\left(x,y)=0 \RighatArrow x\leq 0, y\leq 0 and \sqrt{2\,x\,y}=\varepsilon^{2} ]  <a href="namespacetfel_1_1math.html#af944b60fb53c166c7f8f18f25fc2f702">More...</a><br /></td></tr>
<tr class="separator:af944b60fb53c166c7f8f18f25fc2f702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eeb7dd9cc4a53a955127f9b48dfe6ea"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:a1eeb7dd9cc4a53a955127f9b48dfe6ea"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; real, real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1eeb7dd9cc4a53a955127f9b48dfe6ea">regularisedFischerBurmeisterFunctionFirstDerivatives</a> (const real &amp;x, const real &amp;y, const real &amp;e)</td></tr>
<tr class="separator:a1eeb7dd9cc4a53a955127f9b48dfe6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28368afe179eb2a167faa54d1b75af3"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:af28368afe179eb2a167faa54d1b75af3"><td class="memTemplItemLeft" align="right" valign="top">real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af28368afe179eb2a167faa54d1b75af3">squaredFischerBurmeisterFunction</a> (const real &amp;x, const real &amp;y)</td></tr>
<tr class="separator:af28368afe179eb2a167faa54d1b75af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c5ce8ac8f93979d28714d681c302f5"><td class="memTemplParams" colspan="2">template&lt;typename real &gt; </td></tr>
<tr class="memitem:a45c5ce8ac8f93979d28714d681c302f5"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; real, real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a45c5ce8ac8f93979d28714d681c302f5">squaredFischerBurmeisterFunctionFirstDerivatives</a> (const real &amp;x, const real &amp;y)</td></tr>
<tr class="separator:a45c5ce8ac8f93979d28714d681c302f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c05fec53750312d49276a630e8e27dd"><td class="memTemplParams" colspan="2"><a id="a1c05fec53750312d49276a630e8e27dd"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy &gt; </td></tr>
<tr class="memitem:a1c05fec53750312d49276a630e8e27dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1c05fec53750312d49276a630e8e27dd">base_type_cast</a> (<a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a1c05fec53750312d49276a630e8e27dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast the value to the base type <br /></td></tr>
<tr class="separator:a1c05fec53750312d49276a630e8e27dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f13a9c786261bf587b1ea4cd1375e4"><td class="memTemplParams" colspan="2"><a id="ae0f13a9c786261bf587b1ea4cd1375e4"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy &gt; </td></tr>
<tr class="memitem:ae0f13a9c786261bf587b1ea4cd1375e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE const ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae0f13a9c786261bf587b1ea4cd1375e4">base_type_cast</a> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ae0f13a9c786261bf587b1ea4cd1375e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast the value to the base type <br /></td></tr>
<tr class="separator:ae0f13a9c786261bf587b1ea4cd1375e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991347d3d16c98ee8f7ec1626c699ad2"><td class="memTemplParams" colspan="2"><a id="a991347d3d16c98ee8f7ec1626c699ad2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a991347d3d16c98ee8f7ec1626c699ad2"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>isQuantity</b> ()</td></tr>
<tr class="separator:a991347d3d16c98ee8f7ec1626c699ad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ec780cec38c275aa5aee7a69ad0349"><td class="memTemplParams" colspan="2"><a id="a30ec780cec38c275aa5aee7a69ad0349"></a>
template&lt;unsigned short N&gt; </td></tr>
<tr class="memitem:a30ec780cec38c275aa5aee7a69ad0349"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>requires</b> ((N==1u)||(N==2u)||(N==3u)) struct <a class="el" href="class_stensor_dime_to_size.html">StensorDimeToSize</a></td></tr>
<tr class="separator:a30ec780cec38c275aa5aee7a69ad0349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e0ab367749162e8586e0120faf49a9"><td class="memTemplParams" colspan="2"><a id="ab2e0ab367749162e8586e0120faf49a9"></a>
template&lt;unsigned short N&gt; </td></tr>
<tr class="memitem:ab2e0ab367749162e8586e0120faf49a9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>requires</b> ((N==3u)||(N==4u)||(N==6u)) struct <a class="el" href="class_stensor_size_to_dime.html">StensorSizeToDime</a></td></tr>
<tr class="separator:ab2e0ab367749162e8586e0120faf49a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3702908c7bcb0c9c470ec8a42045fb7"><td class="memTemplParams" colspan="2"><a id="aa3702908c7bcb0c9c470ec8a42045fb7"></a>
template&lt;unsigned short N&gt; </td></tr>
<tr class="memitem:aa3702908c7bcb0c9c470ec8a42045fb7"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE unsigned short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa3702908c7bcb0c9c470ec8a42045fb7">getStensorSize</a> ()</td></tr>
<tr class="memdesc:aa3702908c7bcb0c9c470ec8a42045fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">a small helper function around <code><a class="el" href="class_stensor_dime_to_size.html" title="Metafunction which returns the number of components of an stensor given the spatial dimension used....">StensorDimeToSize</a></code> <br /></td></tr>
<tr class="separator:aa3702908c7bcb0c9c470ec8a42045fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa10b5abbdbd5ea2afffcdd466b31d8"><td class="memTemplParams" colspan="2"><a id="a3aa10b5abbdbd5ea2afffcdd466b31d8"></a>
template&lt;unsigned short N&gt; </td></tr>
<tr class="memitem:a3aa10b5abbdbd5ea2afffcdd466b31d8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>requires</b> ((N==3u)||(N==5u)||(N==9u)) struct <a class="el" href="class_tensor_size_to_dime.html">TensorSizeToDime</a></td></tr>
<tr class="separator:a3aa10b5abbdbd5ea2afffcdd466b31d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af050e102f9de313e48a2796916a7f8f7"><td class="memTemplParams" colspan="2"><a id="af050e102f9de313e48a2796916a7f8f7"></a>
template&lt;typename... T&gt; </td></tr>
<tr class="memitem:af050e102f9de313e48a2796916a7f8f7"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fsarray</b> (T &amp;&amp;... t) -&gt; <a class="el" href="structtfel_1_1math_1_1fsarray.html">fsarray</a>&lt; sizeof...(T), std::common_type_t&lt; T... &gt;&gt;</td></tr>
<tr class="separator:af050e102f9de313e48a2796916a7f8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac413ecff66eaa8acb2cbff09b693c5fa"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, unsigned short N, typename ValueType &gt; </td></tr>
<tr class="memitem:ac413ecff66eaa8acb2cbff09b693c5fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE std::tuple_element_t&lt; i, <a class="el" href="structtfel_1_1math_1_1fsarray.html">fsarray</a>&lt; N, ValueType &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac413ecff66eaa8acb2cbff09b693c5fa">get</a> (<a class="el" href="structtfel_1_1math_1_1fsarray.html">fsarray</a>&lt; N, ValueType &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ac413ecff66eaa8acb2cbff09b693c5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <code>std::get</code> for <code><a class="el" href="structtfel_1_1math_1_1fsarray.html" title="a class representing tiny vectors of fixed size.">tfel::math::fsarray</a></code>  <a href="namespacetfel_1_1math.html#ac413ecff66eaa8acb2cbff09b693c5fa">More...</a><br /></td></tr>
<tr class="separator:ac413ecff66eaa8acb2cbff09b693c5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec5b54890dbf67e6ee860f547b5836e"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, unsigned short N, typename ValueType &gt; </td></tr>
<tr class="memitem:adec5b54890dbf67e6ee860f547b5836e"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE const std::tuple_element_t&lt; i, <a class="el" href="structtfel_1_1math_1_1fsarray.html">fsarray</a>&lt; N, ValueType &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#adec5b54890dbf67e6ee860f547b5836e">get</a> (const <a class="el" href="structtfel_1_1math_1_1fsarray.html">fsarray</a>&lt; N, ValueType &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:adec5b54890dbf67e6ee860f547b5836e"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <code>std::get</code> for <code><a class="el" href="structtfel_1_1math_1_1fsarray.html" title="a class representing tiny vectors of fixed size.">tfel::math::fsarray</a></code>  <a href="namespacetfel_1_1math.html#adec5b54890dbf67e6ee860f547b5836e">More...</a><br /></td></tr>
<tr class="separator:adec5b54890dbf67e6ee860f547b5836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499519d35b23a2d0a8565c69fcfc0593"><td class="memTemplParams" colspan="2">template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:a499519d35b23a2d0a8565c69fcfc0593"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a499519d35b23a2d0a8565c69fcfc0593">abs</a> (const NumericType &amp;s) noexcept requires(tfel</td></tr>
<tr class="separator:a499519d35b23a2d0a8565c69fcfc0593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafaebb8e828aea419a069041a08c72af"><td class="memTemplParams" colspan="2">template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:aafaebb8e828aea419a069041a08c72af"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aafaebb8e828aea419a069041a08c72af">abs</a> (const <a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; NumericType &gt; &amp;s) requires(tfel</td></tr>
<tr class="separator:aafaebb8e828aea419a069041a08c72af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7611707abbdd715c78815912484c38"><td class="memItemLeft" align="right" valign="top"><a id="abe7611707abbdd715c78815912484c38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (unsigned short)</td></tr>
<tr class="separator:abe7611707abbdd715c78815912484c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef640756e876931e951300db6d6357ba"><td class="memItemLeft" align="right" valign="top"><a id="aef640756e876931e951300db6d6357ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (unsigned int)</td></tr>
<tr class="separator:aef640756e876931e951300db6d6357ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394811bedb7775124ba51ce3ebc20fd6"><td class="memItemLeft" align="right" valign="top"><a id="a394811bedb7775124ba51ce3ebc20fd6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (long unsigned int)</td></tr>
<tr class="separator:a394811bedb7775124ba51ce3ebc20fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cd6a2d2e58760ec69122cba1bd94b6"><td class="memItemLeft" align="right" valign="top"><a id="a21cd6a2d2e58760ec69122cba1bd94b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (short)</td></tr>
<tr class="separator:a21cd6a2d2e58760ec69122cba1bd94b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89bcd53a3d2bdd03772cc418ab4085d"><td class="memItemLeft" align="right" valign="top"><a id="af89bcd53a3d2bdd03772cc418ab4085d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (int)</td></tr>
<tr class="separator:af89bcd53a3d2bdd03772cc418ab4085d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f143dd8083c2602578e835a85679924"><td class="memItemLeft" align="right" valign="top"><a id="a6f143dd8083c2602578e835a85679924"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (long int)</td></tr>
<tr class="separator:a6f143dd8083c2602578e835a85679924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7057a83a6f3ffa962b32cd4dfa4d6f93"><td class="memItemLeft" align="right" valign="top"><a id="a7057a83a6f3ffa962b32cd4dfa4d6f93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (float)</td></tr>
<tr class="separator:a7057a83a6f3ffa962b32cd4dfa4d6f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdad99801c6e370eff256ca98f69d0d"><td class="memItemLeft" align="right" valign="top"><a id="abfdad99801c6e370eff256ca98f69d0d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (double)</td></tr>
<tr class="separator:abfdad99801c6e370eff256ca98f69d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3d7bf48aeaaf14a87252ae1897234f7"><td class="memItemLeft" align="right" valign="top"><a id="ae3d7bf48aeaaf14a87252ae1897234f7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE</b> (long double)</td></tr>
<tr class="separator:ae3d7bf48aeaaf14a87252ae1897234f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904fb6dcf64ca52185cb99e30f10a273"><td class="memTemplParams" colspan="2"><a id="a904fb6dcf64ca52185cb99e30f10a273"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a904fb6dcf64ca52185cb99e30f10a273"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (const T src) noexcept requires((tfel</td></tr>
<tr class="separator:a904fb6dcf64ca52185cb99e30f10a273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc00097043862af36eb791e6a3d890b1"><td class="memTemplParams" colspan="2"><a id="acc00097043862af36eb791e6a3d890b1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc00097043862af36eb791e6a3d890b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const T src) noexcept requires((tfel</td></tr>
<tr class="separator:acc00097043862af36eb791e6a3d890b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45a9684e431c09324e6d2490d04fe1f"><td class="memItemLeft" align="right" valign="top"><a id="ad45a9684e431c09324e6d2490d04fe1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (unsigned short)</td></tr>
<tr class="separator:ad45a9684e431c09324e6d2490d04fe1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb863cc44823a5e87d27ecaf1843ef36"><td class="memItemLeft" align="right" valign="top"><a id="acb863cc44823a5e87d27ecaf1843ef36"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (unsigned int)</td></tr>
<tr class="separator:acb863cc44823a5e87d27ecaf1843ef36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55125acfcbd8b87c19910bd8d2206521"><td class="memItemLeft" align="right" valign="top"><a id="a55125acfcbd8b87c19910bd8d2206521"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (long unsigned int)</td></tr>
<tr class="separator:a55125acfcbd8b87c19910bd8d2206521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83096473d77d4510e274001696cf7e93"><td class="memItemLeft" align="right" valign="top"><a id="a83096473d77d4510e274001696cf7e93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (short)</td></tr>
<tr class="separator:a83096473d77d4510e274001696cf7e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d0298a35d5c9042563024d87c13d10"><td class="memItemLeft" align="right" valign="top"><a id="a68d0298a35d5c9042563024d87c13d10"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (int)</td></tr>
<tr class="separator:a68d0298a35d5c9042563024d87c13d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65df6c4d94069e4d1b8e8dd5abffe167"><td class="memItemLeft" align="right" valign="top"><a id="a65df6c4d94069e4d1b8e8dd5abffe167"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (long int)</td></tr>
<tr class="separator:a65df6c4d94069e4d1b8e8dd5abffe167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fbe6efcfe832a44bb6daa9f10d4cad"><td class="memItemLeft" align="right" valign="top"><a id="a15fbe6efcfe832a44bb6daa9f10d4cad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (float)</td></tr>
<tr class="separator:a15fbe6efcfe832a44bb6daa9f10d4cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f7c37a7d76aad42c64a8cb3d213861f"><td class="memItemLeft" align="right" valign="top"><a id="a0f7c37a7d76aad42c64a8cb3d213861f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (double)</td></tr>
<tr class="separator:a0f7c37a7d76aad42c64a8cb3d213861f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a316757fe62b93ba944c714e6bfe1d4"><td class="memItemLeft" align="right" valign="top"><a id="a1a316757fe62b93ba944c714e6bfe1d4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_RESULT_TYPE_COMPLEX</b> (long double)</td></tr>
<tr class="separator:a1a316757fe62b93ba944c714e6bfe1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae1241d6d75bc14b37305447a79256a"><td class="memTemplParams" colspan="2"><a id="aaae1241d6d75bc14b37305447a79256a"></a>
template&lt;typename T1 , typename T2 , typename Op &gt; </td></tr>
<tr class="memitem:aaae1241d6d75bc14b37305447a79256a"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aaae1241d6d75bc14b37305447a79256a">isBinaryOperationResultTypeValid</a> ()</td></tr>
<tr class="memdesc:aaae1241d6d75bc14b37305447a79256a"><td class="mdescLeft">&#160;</td><td class="mdescRight">a metafunction returning true if the result of the binary operation is valid <br /></td></tr>
<tr class="separator:aaae1241d6d75bc14b37305447a79256a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1368ebe96ba564610a80ae69a67170"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb1368ebe96ba564610a80ae69a67170"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#acb1368ebe96ba564610a80ae69a67170">hasConceptTag</a> ()</td></tr>
<tr class="memdesc:acb1368ebe96ba564610a80ae69a67170"><td class="mdescLeft">&#160;</td><td class="mdescRight">metafunction returning of the given type defines a type called <code>ConceptTag</code>.  <a href="namespacetfel_1_1math.html#acb1368ebe96ba564610a80ae69a67170">More...</a><br /></td></tr>
<tr class="separator:acb1368ebe96ba564610a80ae69a67170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa1154d827c15dafe8a2ac0b01c461b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8aa1154d827c15dafe8a2ac0b01c461b"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8aa1154d827c15dafe8a2ac0b01c461b">hasConceptTag</a> ()</td></tr>
<tr class="memdesc:a8aa1154d827c15dafe8a2ac0b01c461b"><td class="mdescLeft">&#160;</td><td class="mdescRight">metafunction returning of the given type defines a type called <code>ConceptTag</code>.  <a href="namespacetfel_1_1math.html#a8aa1154d827c15dafe8a2ac0b01c461b">More...</a><br /></td></tr>
<tr class="separator:a8aa1154d827c15dafe8a2ac0b01c461b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6292a7c384f0948638525b508e213de7"><td class="memTemplParams" colspan="2"><a id="a6292a7c384f0948638525b508e213de7"></a>
template&lt;typename T1 , typename Op &gt; </td></tr>
<tr class="memitem:a6292a7c384f0948638525b508e213de7"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6292a7c384f0948638525b508e213de7">isUnaryOperationResultTypeValid</a> ()</td></tr>
<tr class="memdesc:a6292a7c384f0948638525b508e213de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">an alias <br /></td></tr>
<tr class="separator:a6292a7c384f0948638525b508e213de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce5052f3be1ed8aafc46864ee173477"><td class="memTemplParams" colspan="2">template&lt;typename FunctionType , typename VariableType , typename ScalarType &gt; </td></tr>
<tr class="memitem:a9ce5052f3be1ed8aafc46864ee173477"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetfel_1_1math.html#a8a8691d8234e536cdd0d357a2bc5d10c">derivative_type</a>&lt; std::invoke_result_t&lt; FunctionType, VariableType &gt;, VariableType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9ce5052f3be1ed8aafc46864ee173477">computeNumericalDerivative</a> (const FunctionType &amp;, const VariableType &amp;, const ScalarType &amp;)</td></tr>
<tr class="memdesc:a9ce5052f3be1ed8aafc46864ee173477"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute a numerical approximation of the derivative a a function with respect to a variable with a centered finite difference scheme.  <a href="namespacetfel_1_1math.html#a9ce5052f3be1ed8aafc46864ee173477">More...</a><br /></td></tr>
<tr class="separator:a9ce5052f3be1ed8aafc46864ee173477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a16b6504017630437c88d18d5f083d1"><td class="memTemplParams" colspan="2"><a id="a3a16b6504017630437c88d18d5f083d1"></a>
template&lt;typename iterator_base &gt; </td></tr>
<tr class="memitem:a3a16b6504017630437c88d18d5f083d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt;::difference_type n, const <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt; p)</td></tr>
<tr class="separator:a3a16b6504017630437c88d18d5f083d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a346d17d68f05b4977f74ee91415aae89"><td class="memTemplParams" colspan="2"><a id="a346d17d68f05b4977f74ee91415aae89"></a>
template&lt;typename iterator_base &gt; </td></tr>
<tr class="memitem:a346d17d68f05b4977f74ee91415aae89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const typename <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt;::difference_type n, const <a class="el" href="structtfel_1_1math_1_1_difference_random_access_iterator.html">DifferenceRandomAccessIterator</a>&lt; iterator_base &gt; p)</td></tr>
<tr class="separator:a346d17d68f05b4977f74ee91415aae89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78ab6a4a8144ff8e44de5477d457449"><td class="memItemLeft" align="right" valign="top"><a id="aa78ab6a4a8144ff8e44de5477d457449"></a>
constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a> &amp;)</td></tr>
<tr class="separator:aa78ab6a4a8144ff8e44de5477d457449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30e9167e38df5af606993373d3e902a"><td class="memItemLeft" align="right" valign="top"><a id="aa30e9167e38df5af606993373d3e902a"></a>
constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a> &amp;, const <a class="el" href="structtfel_1_1math_1_1_empty_run_time_properties.html">EmptyRunTimeProperties</a> &amp;)</td></tr>
<tr class="separator:aa30e9167e38df5af606993373d3e902a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d8364a7cc6de24932f2d1f677a78fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a44d8364a7cc6de24932f2d1f677a78fb">init_floating_point_exceptions</a> ()</td></tr>
<tr class="separator:a44d8364a7cc6de24932f2d1f677a78fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad085ecc3447c997c8b396977a5a6403a"><td class="memTemplParams" colspan="2"><a id="ad085ecc3447c997c8b396977a5a6403a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad085ecc3447c997c8b396977a5a6403a"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; T &gt;::cond, T &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad085ecc3447c997c8b396977a5a6403a">base_type_cast</a> (T &amp;v) noexcept</td></tr>
<tr class="memdesc:ad085ecc3447c997c8b396977a5a6403a"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast the value to the base type <br /></td></tr>
<tr class="separator:ad085ecc3447c997c8b396977a5a6403a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a53dfe2e37c7618e1d5c9f2e48f784"><td class="memTemplParams" colspan="2"><a id="a22a53dfe2e37c7618e1d5c9f2e48f784"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22a53dfe2e37c7618e1d5c9f2e48f784"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE std::enable_if_t&lt; <a class="el" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt; T &gt;::cond, const T &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a22a53dfe2e37c7618e1d5c9f2e48f784">base_type_cast</a> (const T &amp;v) noexcept</td></tr>
<tr class="memdesc:a22a53dfe2e37c7618e1d5c9f2e48f784"><td class="mdescLeft">&#160;</td><td class="mdescRight">cast the value to the base type <br /></td></tr>
<tr class="separator:a22a53dfe2e37c7618e1d5c9f2e48f784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a771d27759ba3cd62bfb1b3ad06a0fa"><td class="memTemplParams" colspan="2">template&lt;typename MathObjectType &gt; </td></tr>
<tr class="memitem:a9a771d27759ba3cd62bfb1b3ad06a0fa"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE unsigned short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a> ()</td></tr>
<tr class="memdesc:a9a771d27759ba3cd62bfb1b3ad06a0fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function to retrieve the space dimension associated with a math object.  <a href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">More...</a><br /></td></tr>
<tr class="separator:a9a771d27759ba3cd62bfb1b3ad06a0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2a48b5882876da6707ada2c302f4bd"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aea2a48b5882876da6707ada2c302f4bd"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aea2a48b5882876da6707ada2c302f4bd">isAssignableTo</a> ()</td></tr>
<tr class="memdesc:aea2a48b5882876da6707ada2c302f4bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function around <code>isAssignableTo</code>  <a href="namespacetfel_1_1math.html#aea2a48b5882876da6707ada2c302f4bd">More...</a><br /></td></tr>
<tr class="separator:aea2a48b5882876da6707ada2c302f4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32a69a130c0d7dfdd5860981401e860"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac32a69a130c0d7dfdd5860981401e860"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac32a69a130c0d7dfdd5860981401e860">isInvalid</a> ()</td></tr>
<tr class="memdesc:ac32a69a130c0d7dfdd5860981401e860"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple wrapper around <code><a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html" title="Traits class which says if its argument is invalid.">tfel::typetraits::IsInvalid</a></code>  <a href="namespacetfel_1_1math.html#ac32a69a130c0d7dfdd5860981401e860">More...</a><br /></td></tr>
<tr class="separator:ac32a69a130c0d7dfdd5860981401e860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43abf99e1b4a3f6efa986124a21ccbd4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43abf99e1b4a3f6efa986124a21ccbd4"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a> ()</td></tr>
<tr class="memdesc:a43abf99e1b4a3f6efa986124a21ccbd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">a simple wrapper around <code><a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html" title="Traits class which says if its argument stands for a scalar.">tfel::typetraits::IsScalar</a></code>  <a href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">More...</a><br /></td></tr>
<tr class="separator:a43abf99e1b4a3f6efa986124a21ccbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402e6e88fe9409016b77e3b95f155067"><td class="memTemplParams" colspan="2"><a id="a402e6e88fe9409016b77e3b95f155067"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a402e6e88fe9409016b77e3b95f155067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getRandomRotationMatrix</b> ()</td></tr>
<tr class="separator:a402e6e88fe9409016b77e3b95f155067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f20b955fc36abd1608525116ff7f696"><td class="memTemplParams" colspan="2"><a id="a6f20b955fc36abd1608525116ff7f696"></a>
template&lt;typename iterator_base &gt; </td></tr>
<tr class="memitem:a6f20b955fc36abd1608525116ff7f696"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const typename <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt;::difference_type n, const <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt; p)</td></tr>
<tr class="separator:a6f20b955fc36abd1608525116ff7f696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bc888c51e94431b3ea585559fd01b0"><td class="memTemplParams" colspan="2"><a id="ad8bc888c51e94431b3ea585559fd01b0"></a>
template&lt;typename iterator_base &gt; </td></tr>
<tr class="memitem:ad8bc888c51e94431b3ea585559fd01b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const typename <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt;::difference_type n, const <a class="el" href="structtfel_1_1math_1_1_strided_random_access_iterator.html">StridedRandomAccessIterator</a>&lt; iterator_base &gt; p)</td></tr>
<tr class="separator:ad8bc888c51e94431b3ea585559fd01b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bca031867ff6567faaa6009ebb6d17"><td class="memTemplParams" colspan="2">template&lt;bool extrapolate, typename AbscissaContainer , typename ValueContainer , typename AbscissaType &gt; </td></tr>
<tr class="memitem:a69bca031867ff6567faaa6009ebb6d17"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a69bca031867ff6567faaa6009ebb6d17">computeLinearInterpolation</a> (const AbscissaContainer &amp;, const ValueContainer &amp;, const AbscissaType)</td></tr>
<tr class="memdesc:a69bca031867ff6567faaa6009ebb6d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute a linear interpolation based on the given abscissae and values  <a href="namespacetfel_1_1math.html#a69bca031867ff6567faaa6009ebb6d17">More...</a><br /></td></tr>
<tr class="separator:a69bca031867ff6567faaa6009ebb6d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d12e566c669ea3d38ed9f0c5a90d869"><td class="memTemplParams" colspan="2">template&lt;bool extrapolate, typename AbscissaContainer , typename ValueContainer , typename AbscissaType &gt; </td></tr>
<tr class="memitem:a5d12e566c669ea3d38ed9f0c5a90d869"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5d12e566c669ea3d38ed9f0c5a90d869">computeLinearInterpolationAndDerivative</a> (const AbscissaContainer &amp;, const ValueContainer &amp;, const AbscissaType)</td></tr>
<tr class="memdesc:a5d12e566c669ea3d38ed9f0c5a90d869"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute a linear interpolation based on the given abscissae and values and the associated derivative  <a href="namespacetfel_1_1math.html#a5d12e566c669ea3d38ed9f0c5a90d869">More...</a><br /></td></tr>
<tr class="separator:a5d12e566c669ea3d38ed9f0c5a90d869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a379784cc00b5a95031a679ef75bc6f2d"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a379784cc00b5a95031a679ef75bc6f2d"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a379784cc00b5a95031a679ef75bc6f2d">implementsMatrixConcept</a> ()</td></tr>
<tr class="memdesc:a379784cc00b5a95031a679ef75bc6f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code>MatrixConcept</code>.  <a href="namespacetfel_1_1math.html#a379784cc00b5a95031a679ef75bc6f2d">More...</a><br /></td></tr>
<tr class="separator:a379784cc00b5a95031a679ef75bc6f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be8a39585878e40e7c7d67af203ec31"><td class="memTemplParams" colspan="2"><a id="a7be8a39585878e40e7c7d67af203ec31"></a>
template&lt;unsigned short N, unsigned short M, typename T &gt; </td></tr>
<tr class="memitem:a7be8a39585878e40e7c7d67af203ec31"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;)</td></tr>
<tr class="separator:a7be8a39585878e40e7c7d67af203ec31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2051d610c24beaab4c3405ad25e80b1e"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a2051d610c24beaab4c3405ad25e80b1e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2051d610c24beaab4c3405ad25e80b1e">matrix</a> (const std::initializer_list&lt; std::initializer_list&lt; ValueType &gt;&gt; &amp;) -&gt; <a class="el" href="structtfel_1_1math_1_1matrix.html">matrix</a>&lt; ValueType &gt;</td></tr>
<tr class="memdesc:a2051d610c24beaab4c3405ad25e80b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">class template argument deduction  <a href="namespacetfel_1_1math.html#a2051d610c24beaab4c3405ad25e80b1e">More...</a><br /></td></tr>
<tr class="separator:a2051d610c24beaab4c3405ad25e80b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a2fc98dcdf453463e8a57d050ad943"><td class="memTemplParams" colspan="2">template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:ae2a2fc98dcdf453463e8a57d050ad943"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae2a2fc98dcdf453463e8a57d050ad943">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_bissection_algorithm_data.html">BissectionAlgorithmData</a>&lt; NumericType &gt; &amp;)</td></tr>
<tr class="memdesc:ae2a2fc98dcdf453463e8a57d050ad943"><td class="mdescLeft">&#160;</td><td class="mdescRight">output stream  <a href="namespacetfel_1_1math.html#ae2a2fc98dcdf453463e8a57d050ad943">More...</a><br /></td></tr>
<tr class="separator:ae2a2fc98dcdf453463e8a57d050ad943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150aa17b4b9b5abbb5f87489adaf663f"><td class="memTemplParams" colspan="2">template&lt;typename NumericType &gt; </td></tr>
<tr class="memitem:a150aa17b4b9b5abbb5f87489adaf663f"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a150aa17b4b9b5abbb5f87489adaf663f">operator&lt;&lt;</a> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1_bissection_algorithm_base.html">BissectionAlgorithmBase</a>&lt; NumericType &gt; &amp;)</td></tr>
<tr class="memdesc:a150aa17b4b9b5abbb5f87489adaf663f"><td class="mdescLeft">&#160;</td><td class="mdescRight">output stream  <a href="namespacetfel_1_1math.html#a150aa17b4b9b5abbb5f87489adaf663f">More...</a><br /></td></tr>
<tr class="separator:a150aa17b4b9b5abbb5f87489adaf663f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acecfed63f80323d4d1f3a13da6b9e0"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Criterion , typename NumericType , typename IndexType &gt; </td></tr>
<tr class="memitem:a4acecfed63f80323d4d1f3a13da6b9e0"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; bool, NumericType, IndexType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4acecfed63f80323d4d1f3a13da6b9e0">scalarNewtonRaphson</a> (const Function &amp;f, const Criterion &amp;c, const NumericType x0, const IndexType im)</td></tr>
<tr class="memdesc:a4acecfed63f80323d4d1f3a13da6b9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the root of the given function.  <a href="namespacetfel_1_1math.html#a4acecfed63f80323d4d1f3a13da6b9e0">More...</a><br /></td></tr>
<tr class="separator:a4acecfed63f80323d4d1f3a13da6b9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f0b6160cbd1f54871cb5ef925b936e"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Criterion , typename NumericType , typename IndexType &gt; </td></tr>
<tr class="memitem:ad8f0b6160cbd1f54871cb5ef925b936e"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; bool, NumericType, IndexType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad8f0b6160cbd1f54871cb5ef925b936e">scalarNewtonRaphson</a> (const Function &amp;f, const Criterion &amp;c, const <a class="el" href="structtfel_1_1math_1_1_scalar_newton_raphson_parameters.html">ScalarNewtonRaphsonParameters</a>&lt; NumericType, IndexType &gt; &amp;p)</td></tr>
<tr class="memdesc:ad8f0b6160cbd1f54871cb5ef925b936e"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the root of the given function.  <a href="namespacetfel_1_1math.html#ad8f0b6160cbd1f54871cb5ef925b936e">More...</a><br /></td></tr>
<tr class="separator:ad8f0b6160cbd1f54871cb5ef925b936e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af6a76863040300a210e557ebd47fd9"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename NumericType &gt; </td></tr>
<tr class="memitem:a2af6a76863040300a210e557ebd47fd9"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2af6a76863040300a210e557ebd47fd9">applyPowellDogLegAlgorithm</a> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, NumericType &gt; &amp;delta_zeros, const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, NumericType &gt; &amp;jacobian, const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, NumericType &gt; &amp;fzeros, const NumericType radius) noexcept</td></tr>
<tr class="memdesc:a2af6a76863040300a210e557ebd47fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply Powell' dog leg algorithm  <a href="namespacetfel_1_1math.html#a2af6a76863040300a210e557ebd47fd9">More...</a><br /></td></tr>
<tr class="separator:a2af6a76863040300a210e557ebd47fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea0cf1f95cd7c6591d7377e70c934b8"><td class="memTemplParams" colspan="2">template&lt;int N, unsigned int D&gt; </td></tr>
<tr class="memitem:a1ea0cf1f95cd7c6591d7377e70c934b8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1ea0cf1f95cd7c6591d7377e70c934b8">requires</a> (D !=0) struct <a class="el" href="classtfel_1_1math_1_1_unary_result_type.html">UnaryResultType</a>&lt; float</td></tr>
<tr class="memdesc:a1ea0cf1f95cd7c6591d7377e70c934b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation for the <a class="el" href="classtfel_1_1math_1_1_unary_result_type.html">UnaryResultType</a> class for exponentation of floating point number using rational exponent  <a href="namespacetfel_1_1math.html#a1ea0cf1f95cd7c6591d7377e70c934b8">More...</a><br /></td></tr>
<tr class="separator:a1ea0cf1f95cd7c6591d7377e70c934b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1508fec9c3e7e4bbe85e720ba19456"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:a1b1508fec9c3e7e4bbe85e720ba19456"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1b1508fec9c3e7e4bbe85e720ba19456">power</a> (const std::floating_point auto) noexcept</td></tr>
<tr class="memdesc:a1b1508fec9c3e7e4bbe85e720ba19456"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes x to the power N  <a href="namespacetfel_1_1math.html#a1b1508fec9c3e7e4bbe85e720ba19456">More...</a><br /></td></tr>
<tr class="separator:a1b1508fec9c3e7e4bbe85e720ba19456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514b41b0e229b71e1eafecba4931bd25"><td class="memTemplParams" colspan="2">template&lt;int N, unsigned int D, typename T &gt; </td></tr>
<tr class="memitem:a514b41b0e229b71e1eafecba4931bd25"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a514b41b0e229b71e1eafecba4931bd25">power</a> (const std::floating_point auto) noexcept requires(D !=0)</td></tr>
<tr class="memdesc:a514b41b0e229b71e1eafecba4931bd25"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes x to the power N/D  <a href="namespacetfel_1_1math.html#a514b41b0e229b71e1eafecba4931bd25">More...</a><br /></td></tr>
<tr class="separator:a514b41b0e229b71e1eafecba4931bd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53620ecd1d9302ea6742d3a47a576bb8"><td class="memTemplParams" colspan="2">template&lt;int N, unsigned int D&gt; </td></tr>
<tr class="memitem:a53620ecd1d9302ea6742d3a47a576bb8"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a53620ecd1d9302ea6742d3a47a576bb8">power</a> (const std::floating_point auto x) noexcept requires(D !=0)</td></tr>
<tr class="memdesc:a53620ecd1d9302ea6742d3a47a576bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes x to the power N/D  <a href="namespacetfel_1_1math.html#a53620ecd1d9302ea6742d3a47a576bb8">More...</a><br /></td></tr>
<tr class="separator:a53620ecd1d9302ea6742d3a47a576bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9701388a117648a67decfa16003049d"><td class="memTemplParams" colspan="2"><a id="ae9701388a117648a67decfa16003049d"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy &gt; </td></tr>
<tr class="memitem:ae9701388a117648a67decfa16003049d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Quantity</b> (<a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt;) -&gt; <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt;</td></tr>
<tr class="separator:ae9701388a117648a67decfa16003049d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa855588c6d485958d2ca5ef0bfd2fbdb"><td class="memTemplParams" colspan="2"><a id="aa855588c6d485958d2ca5ef0bfd2fbdb"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy , typename UnitType2 , typename ValueType2 , typename OwnershipPolicy2 &gt; </td></tr>
<tr class="memitem:aa855588c6d485958d2ca5ef0bfd2fbdb"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;a, const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType2, ValueType2, OwnershipPolicy2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:aa855588c6d485958d2ca5ef0bfd2fbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc4b2c96e1005590edc48c9c45f203d"><td class="memTemplParams" colspan="2"><a id="a9bc4b2c96e1005590edc48c9c45f203d"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy , typename UnitType2 , typename ValueType2 , typename OwnershipPolicy2 &gt; </td></tr>
<tr class="memitem:a9bc4b2c96e1005590edc48c9c45f203d"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;a, const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType2, ValueType2, OwnershipPolicy2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:a9bc4b2c96e1005590edc48c9c45f203d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7ee77eaeeb4ddaa947d9be8aac41e8"><td class="memTemplParams" colspan="2"><a id="abe7ee77eaeeb4ddaa947d9be8aac41e8"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy , typename UnitType2 , typename ValueType2 , typename OwnershipPolicy2 &gt; </td></tr>
<tr class="memitem:abe7ee77eaeeb4ddaa947d9be8aac41e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;a, const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType2, ValueType2, OwnershipPolicy2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:abe7ee77eaeeb4ddaa947d9be8aac41e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f38dce04026fa1182d08d0a5ecd0861"><td class="memTemplParams" colspan="2"><a id="a8f38dce04026fa1182d08d0a5ecd0861"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy , typename UnitType2 , typename ValueType2 , typename OwnershipPolicy2 &gt; </td></tr>
<tr class="memitem:a8f38dce04026fa1182d08d0a5ecd0861"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;a, const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType2, ValueType2, OwnershipPolicy2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:a8f38dce04026fa1182d08d0a5ecd0861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65845ebe2ef538513a43bd89cddfdebf"><td class="memTemplParams" colspan="2"><a id="a65845ebe2ef538513a43bd89cddfdebf"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy , typename UnitType2 , typename ValueType2 , typename OwnershipPolicy2 &gt; </td></tr>
<tr class="memitem:a65845ebe2ef538513a43bd89cddfdebf"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;a, const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType2, ValueType2, OwnershipPolicy2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:a65845ebe2ef538513a43bd89cddfdebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d67be6803fc1e7253ceea7f2c25f27"><td class="memTemplParams" colspan="2"><a id="a62d67be6803fc1e7253ceea7f2c25f27"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy , typename UnitType2 , typename ValueType2 , typename OwnershipPolicy2 &gt; </td></tr>
<tr class="memitem:a62d67be6803fc1e7253ceea7f2c25f27"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;a, const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType2, ValueType2, OwnershipPolicy2 &gt; &amp;b) noexcept</td></tr>
<tr class="separator:a62d67be6803fc1e7253ceea7f2c25f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad182bc8d0c508531fbf7930f5491ade3"><td class="memTemplParams" colspan="2"><a id="ad182bc8d0c508531fbf7930f5491ade3"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy &gt; </td></tr>
<tr class="memitem:ad182bc8d0c508531fbf7930f5491ade3"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="namespacetfel_1_1math.html#a09ea76e48b98b755d87cb16dc74d2afa">qt</a>&lt; UnitType, ValueType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;v) noexcept</td></tr>
<tr class="separator:ad182bc8d0c508531fbf7930f5491ade3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ef5ed6258039bca2f814ea9578c9609"><td class="memTemplParams" colspan="2"><a id="a5ef5ed6258039bca2f814ea9578c9609"></a>
template&lt;int N, typename Unit , typename ValueType , typename OwnershipPolicy &gt; </td></tr>
<tr class="memitem:a5ef5ed6258039bca2f814ea9578c9609"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>power</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; <a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a>, ValueType, OwnershipPolicy &gt; &amp;x) requires(std</td></tr>
<tr class="separator:a5ef5ed6258039bca2f814ea9578c9609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010da7ffec407af42152df08b41bb5e2"><td class="memTemplParams" colspan="2"><a id="a010da7ffec407af42152df08b41bb5e2"></a>
template&lt;int N, unsigned int D, typename Unit , typename ValueType , typename OwnershipPolicy &gt; </td></tr>
<tr class="memitem:a010da7ffec407af42152df08b41bb5e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>power</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; <a class="el" href="structtfel_1_1math_1_1_unit.html">Unit</a>, ValueType, OwnershipPolicy &gt; &amp;x) requires(std</td></tr>
<tr class="separator:a010da7ffec407af42152df08b41bb5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0a182ba4cb34875e6262dd8a35b63f"><td class="memTemplParams" colspan="2"><a id="acb0a182ba4cb34875e6262dd8a35b63f"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy &gt; </td></tr>
<tr class="memitem:acb0a182ba4cb34875e6262dd8a35b63f"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>square_root</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;q) noexcept</td></tr>
<tr class="separator:acb0a182ba4cb34875e6262dd8a35b63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae1f060d1fd43019c513294b9eb667d"><td class="memTemplParams" colspan="2"><a id="afae1f060d1fd43019c513294b9eb667d"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy &gt; </td></tr>
<tr class="memitem:afae1f060d1fd43019c513294b9eb667d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;q)</td></tr>
<tr class="separator:afae1f060d1fd43019c513294b9eb667d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9798d62cbd05215482e1db0372069f5b"><td class="memTemplParams" colspan="2"><a id="a9798d62cbd05215482e1db0372069f5b"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy , typename UnitType2 , typename ValueType2 , typename OwnershipPolicy2 &gt; </td></tr>
<tr class="memitem:a9798d62cbd05215482e1db0372069f5b"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="namespacetfel_1_1math.html#a09ea76e48b98b755d87cb16dc74d2afa">qt</a>&lt; UnitType, typename <a class="el" href="structtfel_1_1typetraits_1_1_promote.html">tfel::typetraits::Promote</a>&lt; ValueType, ValueType2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;a, const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType2, ValueType2, OwnershipPolicy2 &gt; &amp;b)</td></tr>
<tr class="separator:a9798d62cbd05215482e1db0372069f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea24a33a1aedd253c5e744a3c217da1b"><td class="memTemplParams" colspan="2"><a id="aea24a33a1aedd253c5e744a3c217da1b"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy , typename UnitType2 , typename ValueType2 , typename OwnershipPolicy2 &gt; </td></tr>
<tr class="memitem:aea24a33a1aedd253c5e744a3c217da1b"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="namespacetfel_1_1math.html#a09ea76e48b98b755d87cb16dc74d2afa">qt</a>&lt; UnitType, typename <a class="el" href="structtfel_1_1typetraits_1_1_promote.html">tfel::typetraits::Promote</a>&lt; ValueType, ValueType2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;a, const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType2, ValueType2, OwnershipPolicy2 &gt; &amp;b)</td></tr>
<tr class="separator:aea24a33a1aedd253c5e744a3c217da1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf10fee13ef791aff22dd8782ccf2668"><td class="memTemplParams" colspan="2"><a id="aaf10fee13ef791aff22dd8782ccf2668"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy , typename UnitType2 , typename ValueType2 , typename OwnershipPolicy2 &gt; </td></tr>
<tr class="memitem:aaf10fee13ef791aff22dd8782ccf2668"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;a, const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType2, ValueType2, OwnershipPolicy2 &gt; &amp;b)</td></tr>
<tr class="separator:aaf10fee13ef791aff22dd8782ccf2668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6188df89a96a200cc1fdd9be966575b7"><td class="memTemplParams" colspan="2"><a id="a6188df89a96a200cc1fdd9be966575b7"></a>
template&lt;typename UnitType , typename ValueType , typename OwnershipPolicy , typename UnitType2 , typename ValueType2 , typename OwnershipPolicy2 &gt; </td></tr>
<tr class="memitem:a6188df89a96a200cc1fdd9be966575b7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator/</b> (const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType, ValueType, OwnershipPolicy &gt; &amp;a, const <a class="el" href="structtfel_1_1math_1_1_quantity.html">Quantity</a>&lt; UnitType2, ValueType2, OwnershipPolicy2 &gt; &amp;b)</td></tr>
<tr class="separator:a6188df89a96a200cc1fdd9be966575b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab7173c9a45104be6e59067b56eeeb1"><td class="memItemLeft" align="right" valign="top"><a id="adab7173c9a45104be6e59067b56eeeb1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (unsigned short)</td></tr>
<tr class="separator:adab7173c9a45104be6e59067b56eeeb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f32ebcd9a6efefb8faa2f393272581b"><td class="memItemLeft" align="right" valign="top"><a id="a9f32ebcd9a6efefb8faa2f393272581b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (unsigned int)</td></tr>
<tr class="separator:a9f32ebcd9a6efefb8faa2f393272581b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ada837fc939a0c0025b232255ea467"><td class="memItemLeft" align="right" valign="top"><a id="ac7ada837fc939a0c0025b232255ea467"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (long unsigned int)</td></tr>
<tr class="separator:ac7ada837fc939a0c0025b232255ea467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f67c635586ec8b65a269e6fe9378a51"><td class="memItemLeft" align="right" valign="top"><a id="a3f67c635586ec8b65a269e6fe9378a51"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (short)</td></tr>
<tr class="separator:a3f67c635586ec8b65a269e6fe9378a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916c631c4fe77be750306d2b34705c67"><td class="memItemLeft" align="right" valign="top"><a id="a916c631c4fe77be750306d2b34705c67"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (int)</td></tr>
<tr class="separator:a916c631c4fe77be750306d2b34705c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed908c8b1013a17abf261f33ca78f1f4"><td class="memItemLeft" align="right" valign="top"><a id="aed908c8b1013a17abf261f33ca78f1f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (long int)</td></tr>
<tr class="separator:aed908c8b1013a17abf261f33ca78f1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f90dfe5bca96b115545ca722c5e01a1"><td class="memItemLeft" align="right" valign="top"><a id="a1f90dfe5bca96b115545ca722c5e01a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (float)</td></tr>
<tr class="separator:a1f90dfe5bca96b115545ca722c5e01a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24edbd54793754aff6f6ec9630dd9a3"><td class="memItemLeft" align="right" valign="top"><a id="ab24edbd54793754aff6f6ec9630dd9a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (double)</td></tr>
<tr class="separator:ab24edbd54793754aff6f6ec9630dd9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7472a74fc6529cc3cb1e4151f6fa4ebb"><td class="memItemLeft" align="right" valign="top"><a id="a7472a74fc6529cc3cb1e4151f6fa4ebb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (long double)</td></tr>
<tr class="separator:a7472a74fc6529cc3cb1e4151f6fa4ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5e2a955c0f6c07c2d3ee24a61c9094"><td class="memItemLeft" align="right" valign="top"><a id="a9c5e2a955c0f6c07c2d3ee24a61c9094"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; unsigned short &gt;)</td></tr>
<tr class="separator:a9c5e2a955c0f6c07c2d3ee24a61c9094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05482b999cf982b6bc7a4438f9387e6d"><td class="memItemLeft" align="right" valign="top"><a id="a05482b999cf982b6bc7a4438f9387e6d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; unsigned int &gt;)</td></tr>
<tr class="separator:a05482b999cf982b6bc7a4438f9387e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f42b392eb089e71b18b09e2089b62ed"><td class="memItemLeft" align="right" valign="top"><a id="a0f42b392eb089e71b18b09e2089b62ed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; long unsigned int &gt;)</td></tr>
<tr class="separator:a0f42b392eb089e71b18b09e2089b62ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2623e1508b49ea40564fae4e254683e8"><td class="memItemLeft" align="right" valign="top"><a id="a2623e1508b49ea40564fae4e254683e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; short &gt;)</td></tr>
<tr class="separator:a2623e1508b49ea40564fae4e254683e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c85265ca94db02d68cf060610e041a"><td class="memItemLeft" align="right" valign="top"><a id="aa6c85265ca94db02d68cf060610e041a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; int &gt;)</td></tr>
<tr class="separator:aa6c85265ca94db02d68cf060610e041a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33478a852eaa220dc7dd74aa7ce75d29"><td class="memItemLeft" align="right" valign="top"><a id="a33478a852eaa220dc7dd74aa7ce75d29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; long int &gt;)</td></tr>
<tr class="separator:a33478a852eaa220dc7dd74aa7ce75d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32245f06e6ff642415b23afb9b12b4fa"><td class="memItemLeft" align="right" valign="top"><a id="a32245f06e6ff642415b23afb9b12b4fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; float &gt;)</td></tr>
<tr class="separator:a32245f06e6ff642415b23afb9b12b4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ef50f8e55ddb76f86ccd45c821d07"><td class="memItemLeft" align="right" valign="top"><a id="a028ef50f8e55ddb76f86ccd45c821d07"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; double &gt;)</td></tr>
<tr class="separator:a028ef50f8e55ddb76f86ccd45c821d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42763fa6b66892f25cf493faa35f4d71"><td class="memItemLeft" align="right" valign="top"><a id="a42763fa6b66892f25cf493faa35f4d71"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TFEL_MATH_QT_SCALAR_OPERATIONS</b> (<a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; long double &gt;)</td></tr>
<tr class="separator:a42763fa6b66892f25cf493faa35f4d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736687b37815fcec1211737cf6f0d7d0"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Criterion , typename NumericType , typename IndexType &gt; </td></tr>
<tr class="memitem:a736687b37815fcec1211737cf6f0d7d0"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE std::tuple&lt; bool, NumericType, IndexType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a736687b37815fcec1211737cf6f0d7d0">scalarNewtonRaphson</a> (const Function &amp;, const Criterion &amp;, const NumericType, const IndexType)</td></tr>
<tr class="memdesc:a736687b37815fcec1211737cf6f0d7d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the root of the given function.  <a href="namespacetfel_1_1math.html#a736687b37815fcec1211737cf6f0d7d0">More...</a><br /></td></tr>
<tr class="separator:a736687b37815fcec1211737cf6f0d7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8462ce00da4cf90d92ac67ce7bd8199c"><td class="memTemplParams" colspan="2">template&lt;typename Function , typename Criterion , typename NumericType , typename IndexType &gt; </td></tr>
<tr class="memitem:a8462ce00da4cf90d92ac67ce7bd8199c"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE std::tuple&lt; bool, NumericType, IndexType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8462ce00da4cf90d92ac67ce7bd8199c">scalarNewtonRaphson</a> (const Function &amp;, const Criterion &amp;, const <a class="el" href="structtfel_1_1math_1_1_scalar_newton_raphson_parameters.html">ScalarNewtonRaphsonParameters</a>&lt; NumericType, IndexType &gt; &amp;)</td></tr>
<tr class="memdesc:a8462ce00da4cf90d92ac67ce7bd8199c"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the root of the given function.  <a href="namespacetfel_1_1math.html#a8462ce00da4cf90d92ac67ce7bd8199c">More...</a><br /></td></tr>
<tr class="separator:a8462ce00da4cf90d92ac67ce7bd8199c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fbe364d7b6e778d7823d65fc23f434"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad8fbe364d7b6e778d7823d65fc23f434">abs</a> (const <a class="el" href="namespacetfel_1_1math.html#aeca06c0ef953bcbf93189fa8513ce243">ST2toST2Concept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:ad8fbe364d7b6e778d7823d65fc23f434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25051153822df1582044c5ba9c97350a"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a25051153822df1582044c5ba9c97350a">transpose</a> (<a class="el" href="namespacetfel_1_1math.html#aeca06c0ef953bcbf93189fa8513ce243">ST2toST2Concept</a> auto &amp;&amp;) noexcept</td></tr>
<tr class="separator:a25051153822df1582044c5ba9c97350a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7b0f7a8b8d414307c63a08e0e6bffe"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5b7b0f7a8b8d414307c63a08e0e6bffe">det</a> (const <a class="el" href="namespacetfel_1_1math.html#aeca06c0ef953bcbf93189fa8513ce243">ST2toST2Concept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:a5b7b0f7a8b8d414307c63a08e0e6bffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676f1e0cadeefce5385dbdece2e7ed5c"><td class="memTemplParams" colspan="2">template&lt;typename ST2toST2Type &gt; </td></tr>
<tr class="memitem:a676f1e0cadeefce5385dbdece2e7ed5c"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a676f1e0cadeefce5385dbdece2e7ed5c">implementsST2toST2Concept</a> ()</td></tr>
<tr class="memdesc:a676f1e0cadeefce5385dbdece2e7ed5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code>ST2toST2Concept</code>.  <a href="namespacetfel_1_1math.html#a676f1e0cadeefce5385dbdece2e7ed5c">More...</a><br /></td></tr>
<tr class="separator:a676f1e0cadeefce5385dbdece2e7ed5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace63cf94149ccd1306f1deeb12e23ef5"><td class="memTemplParams" colspan="2"><a id="ace63cf94149ccd1306f1deeb12e23ef5"></a>
template&lt;ST2toST2Concept ST2toST2ResultType, TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:ace63cf94149ccd1306f1deeb12e23ef5"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computePushForwardDerivative</b> (ST2toST2ResultType &amp;r, const TensorType &amp;F) noexcept requires(tfel</td></tr>
<tr class="separator:ace63cf94149ccd1306f1deeb12e23ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a582a19b8af1739da60b7093611cb6"><td class="memItemLeft" align="right" valign="top"><a id="a43a582a19b8af1739da60b7093611cb6"></a>
TFEL_HOST std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="namespacetfel_1_1math.html#aeca06c0ef953bcbf93189fa8513ce243">ST2toST2Concept</a> auto &amp;s)</td></tr>
<tr class="separator:a43a582a19b8af1739da60b7093611cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c8ad5490ca7330cd53a187b9ab8d4b"><td class="memTemplParams" colspan="2">template&lt;StensorConcept T1, ST2toST2Concept T2&gt; </td></tr>
<tr class="memitem:aa4c8ad5490ca7330cd53a187b9ab8d4b"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa4c8ad5490ca7330cd53a187b9ab8d4b">operator|</a> (const T1 &amp;a, const T2 &amp;b) noexcept</td></tr>
<tr class="separator:aa4c8ad5490ca7330cd53a187b9ab8d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5daed62efdce54317638a978c87298d8"><td class="memTemplParams" colspan="2"><a id="a5daed62efdce54317638a978c87298d8"></a>
template&lt;StensorConcept StensorType1, StensorConcept StensorType2&gt; </td></tr>
<tr class="memitem:a5daed62efdce54317638a978c87298d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>symmetric_product_derivative_daba_da</b> (const StensorType1 &amp;a, const StensorType2 &amp;b) noexcept -&gt; <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; 1u, decltype(a[0] *b[0])&gt; requires((<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; StensorType1 &gt;()==1u) &amp;&amp;(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; StensorType2 &gt;()==1u))</td></tr>
<tr class="separator:a5daed62efdce54317638a978c87298d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac47b9a7f7ff05b9719e7a8b98565c01"><td class="memTemplParams" colspan="2"><a id="aac47b9a7f7ff05b9719e7a8b98565c01"></a>
template&lt;StensorConcept StensorType&gt; </td></tr>
<tr class="memitem:aac47b9a7f7ff05b9719e7a8b98565c01"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>symmetric_product_derivative_daba_db</b> (const StensorType &amp;a) noexcept -&gt; <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; 1u, decltype(a[0] *a[0])&gt; requires(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; StensorType &gt;()==1u)</td></tr>
<tr class="separator:aac47b9a7f7ff05b9719e7a8b98565c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf53f435672deac6c3cdcb05a3f5929d"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , std::size_t M, std::size_t... d&gt; </td></tr>
<tr class="memitem:adf53f435672deac6c3cdcb05a3f5929d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#adf53f435672deac6c3cdcb05a3f5929d">st2tost2</a> (ValueType const (&amp;)[M], ValueType const (&amp;... arrays)[d]) -&gt; <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="class_stensor_size_to_dime.html">StensorSizeToDime</a>&lt; sizeof...(d)+1 &gt;::value, ValueType &gt;</td></tr>
<tr class="memdesc:adf53f435672deac6c3cdcb05a3f5929d"><td class="mdescLeft">&#160;</td><td class="mdescRight">class template argument deduction  <a href="namespacetfel_1_1math.html#adf53f435672deac6c3cdcb05a3f5929d">More...</a><br /></td></tr>
<tr class="separator:adf53f435672deac6c3cdcb05a3f5929d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c641ff58638cd335232b08de8a9794"><td class="memTemplParams" colspan="2">template&lt;ST2toST2Concept ST2toST2Type&gt; </td></tr>
<tr class="memitem:ae3c641ff58638cd335232b08de8a9794"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae3c641ff58638cd335232b08de8a9794">change_basis</a> (const ST2toST2Type &amp;, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; ST2toST2Type &gt;&gt; &amp;) noexcept</td></tr>
<tr class="separator:ae3c641ff58638cd335232b08de8a9794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac933af4151cde8f11748658ae0040ad3"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac933af4151cde8f11748658ae0040ad3">invert</a> (const <a class="el" href="namespacetfel_1_1math.html#aeca06c0ef953bcbf93189fa8513ce243">ST2toST2Concept</a> auto &amp;)</td></tr>
<tr class="separator:ac933af4151cde8f11748658ae0040ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74159a4e553ce5da86d92dceb22828e4"><td class="memTemplParams" colspan="2">template&lt;ST2toST2Concept ST2toST2Type, TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:a74159a4e553ce5da86d92dceb22828e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a74159a4e553ce5da86d92dceb22828e4">push_forward</a> (const ST2toST2Type &amp;, const TensorType &amp;) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; ST2toST2Type &gt;()</td></tr>
<tr class="separator:a74159a4e553ce5da86d92dceb22828e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a1a41f6cff6487ff0e0cdd29a91f49"><td class="memTemplParams" colspan="2">template&lt;ST2toST2Concept ST2toST2Type, TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:a73a1a41f6cff6487ff0e0cdd29a91f49"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a73a1a41f6cff6487ff0e0cdd29a91f49">pull_back</a> (const ST2toST2Type &amp;, const TensorType &amp;) requires(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; ST2toST2Type &gt;()</td></tr>
<tr class="separator:a73a1a41f6cff6487ff0e0cdd29a91f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612abc3b346374aec5b63a3e05d2e813"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a612abc3b346374aec5b63a3e05d2e813">computeDeterminantSecondDerivative</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="memdesc:a612abc3b346374aec5b63a3e05d2e813"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the second derivative of determinant of a  <a href="namespacetfel_1_1math.html#a612abc3b346374aec5b63a3e05d2e813">More...</a><br /></td></tr>
<tr class="separator:a612abc3b346374aec5b63a3e05d2e813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9e0a501fb2115a37992f395c2e76ad"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5e9e0a501fb2115a37992f395c2e76ad">computeDeviatorDeterminantSecondDerivative</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="memdesc:a5e9e0a501fb2115a37992f395c2e76ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the second derivative of the determinant of the deviator of symmetric tensor.  <a href="namespacetfel_1_1math.html#a5e9e0a501fb2115a37992f395c2e76ad">More...</a><br /></td></tr>
<tr class="separator:a5e9e0a501fb2115a37992f395c2e76ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2c458888bd2a446ac852a7b082c8d9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2a2c458888bd2a446ac852a7b082c8d9">abs</a> (const <a class="el" href="namespacetfel_1_1math.html#ab2e863c47f92cd44e5188f09efee68b6">ST2toT2Concept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:a2a2c458888bd2a446ac852a7b082c8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a56b75f3471b6ec1b3db6a8128066e3"><td class="memTemplParams" colspan="2">template&lt;typename ST2toT2Type &gt; </td></tr>
<tr class="memitem:a4a56b75f3471b6ec1b3db6a8128066e3"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4a56b75f3471b6ec1b3db6a8128066e3">implementsST2toT2Concept</a> ()</td></tr>
<tr class="memdesc:a4a56b75f3471b6ec1b3db6a8128066e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code>ST2toT2Concept</code>.  <a href="namespacetfel_1_1math.html#a4a56b75f3471b6ec1b3db6a8128066e3">More...</a><br /></td></tr>
<tr class="separator:a4a56b75f3471b6ec1b3db6a8128066e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdede986a623e384b04ad1d08dea851"><td class="memItemLeft" align="right" valign="top"><a id="aabdede986a623e384b04ad1d08dea851"></a>
TFEL_HOST std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="namespacetfel_1_1math.html#ab2e863c47f92cd44e5188f09efee68b6">ST2toT2Concept</a> auto &amp;t)</td></tr>
<tr class="separator:aabdede986a623e384b04ad1d08dea851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9727d9c54d4a4e55c68af7bfd8845971"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , std::size_t M, std::size_t... d&gt; </td></tr>
<tr class="memitem:a9727d9c54d4a4e55c68af7bfd8845971"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9727d9c54d4a4e55c68af7bfd8845971">st2tot2</a> (ValueType const (&amp;)[M], ValueType const (&amp;... arrays)[d]) -&gt; <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>&lt; <a class="el" href="class_tensor_size_to_dime.html">TensorSizeToDime</a>&lt; sizeof...(d)+1 &gt;::value, ValueType &gt;</td></tr>
<tr class="memdesc:a9727d9c54d4a4e55c68af7bfd8845971"><td class="mdescLeft">&#160;</td><td class="mdescRight">class template argument deduction  <a href="namespacetfel_1_1math.html#a9727d9c54d4a4e55c68af7bfd8845971">More...</a><br /></td></tr>
<tr class="separator:a9727d9c54d4a4e55c68af7bfd8845971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5880b16eb9457e86078c701264ef3fc8"><td class="memTemplParams" colspan="2">template&lt;ST2toST2Concept DPPType, StensorConcept PPType, StensorConcept StensorType&gt; </td></tr>
<tr class="memitem:a5880b16eb9457e86078c701264ef3fc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5880b16eb9457e86078c701264ef3fc8">computeStensorPositivePartAndDerivative</a> (DPPType &amp;, PPType &amp;, const StensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; StensorType &gt;) requires(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; DPPType &gt;()</td></tr>
<tr class="memdesc:a5880b16eb9457e86078c701264ef3fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part.  <a href="namespacetfel_1_1math.html#a5880b16eb9457e86078c701264ef3fc8">More...</a><br /></td></tr>
<tr class="separator:a5880b16eb9457e86078c701264ef3fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7d043020f38214a82327b2f8fe5dd3"><td class="memTemplParams" colspan="2">template&lt;ST2toST2Concept DPPType, ST2toST2Concept DNPType, StensorConcept PPType, StensorConcept NPType, StensorConcept StensorType&gt; </td></tr>
<tr class="memitem:a1f7d043020f38214a82327b2f8fe5dd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1f7d043020f38214a82327b2f8fe5dd3">computeStensorDecompositionInPositiveAndNegativeParts</a> (DPPType &amp;, DNPType &amp;, PPType &amp;, NPType &amp;, const StensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; StensorType &gt;) requires(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; DPPType &gt;()</td></tr>
<tr class="memdesc:a1f7d043020f38214a82327b2f8fe5dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives.  <a href="namespacetfel_1_1math.html#a1f7d043020f38214a82327b2f8fe5dd3">More...</a><br /></td></tr>
<tr class="separator:a1f7d043020f38214a82327b2f8fe5dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0436301407b4e819e03b50da3f787d9a"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0436301407b4e819e03b50da3f787d9a">abs</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:a0436301407b4e819e03b50da3f787d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a7ebc388352e7eec62fbc92a17fafb"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac6a7ebc388352e7eec62fbc92a17fafb">trace</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:ac6a7ebc388352e7eec62fbc92a17fafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2897a978d9d0c2022eac18e856ab83"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1f2897a978d9d0c2022eac18e856ab83">sigmaeq</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:a1f2897a978d9d0c2022eac18e856ab83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149e523d4030183ad7609d865ee65933"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a149e523d4030183ad7609d865ee65933">deviator</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:a149e523d4030183ad7609d865ee65933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c3072beed6e2460e43b95e1d5083e8"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a43c3072beed6e2460e43b95e1d5083e8">computeDeterminantDerivative</a> (<a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;, const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="memdesc:a43c3072beed6e2460e43b95e1d5083e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="namespacetfel_1_1math.html#a43c3072beed6e2460e43b95e1d5083e8">More...</a><br /></td></tr>
<tr class="separator:a43c3072beed6e2460e43b95e1d5083e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1203310979fbcc00e858e93186649548"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1203310979fbcc00e858e93186649548">computeDeviatorDeterminantDerivative</a> (<a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;, const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="memdesc:a1203310979fbcc00e858e93186649548"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="namespacetfel_1_1math.html#a1203310979fbcc00e858e93186649548">More...</a><br /></td></tr>
<tr class="separator:a1203310979fbcc00e858e93186649548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dac85eb9e4a0729f98d4307357a577f"><td class="memItemLeft" align="right" valign="top">TFEL_HOST TFELMATH_VISIBILITY_EXPORT unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1dac85eb9e4a0729f98d4307357a577f">getStensorSize</a> (const unsigned short)</td></tr>
<tr class="memdesc:a1dac85eb9e4a0729f98d4307357a577f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the size of a symmetric tensor for the given dimension  <a href="namespacetfel_1_1math.html#a1dac85eb9e4a0729f98d4307357a577f">More...</a><br /></td></tr>
<tr class="separator:a1dac85eb9e4a0729f98d4307357a577f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0db70dd547f34dae5cdbf86f996f5c"><td class="memTemplParams" colspan="2">template&lt;typename StensorType &gt; </td></tr>
<tr class="memitem:a9e0db70dd547f34dae5cdbf86f996f5c"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9e0db70dd547f34dae5cdbf86f996f5c">implementsStensorConcept</a> ()</td></tr>
<tr class="memdesc:a9e0db70dd547f34dae5cdbf86f996f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code>StensorConcept</code>.  <a href="namespacetfel_1_1math.html#a9e0db70dd547f34dae5cdbf86f996f5c">More...</a><br /></td></tr>
<tr class="separator:a9e0db70dd547f34dae5cdbf86f996f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bee7427a9c4d9a7a8d5d6ee1807da8b"><td class="memItemLeft" align="right" valign="top">TFEL_HOST std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a5bee7427a9c4d9a7a8d5d6ee1807da8b">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;s)</td></tr>
<tr class="memdesc:a5bee7427a9c4d9a7a8d5d6ee1807da8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialisation operator  <a href="namespacetfel_1_1math.html#a5bee7427a9c4d9a7a8d5d6ee1807da8b">More...</a><br /></td></tr>
<tr class="separator:a5bee7427a9c4d9a7a8d5d6ee1807da8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae007b0242acbc71d7ecc7878e83d56a5"><td class="memTemplParams" colspan="2">template&lt;StensorConcept T1, StensorConcept T2&gt; </td></tr>
<tr class="memitem:ae007b0242acbc71d7ecc7878e83d56a5"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="namespacetfel_1_1math.html#af36bc9045afd07925b2bfef0a00c27f7">BinaryOperationResult</a>&lt; T1, T2, OpDotProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae007b0242acbc71d7ecc7878e83d56a5">operator|</a> (const T1 &amp;, const T2 &amp;) noexcept requires((<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; T1 &gt;()</td></tr>
<tr class="separator:ae007b0242acbc71d7ecc7878e83d56a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce6890cd20537117b59f077200ec7a8"><td class="memTemplParams" colspan="2"><a id="afce6890cd20537117b59f077200ec7a8"></a>
template&lt;typename... T&gt; </td></tr>
<tr class="memitem:afce6890cd20537117b59f077200ec7a8"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>stensor</b> (T &amp;&amp;... t) -&gt; <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; <a class="el" href="class_stensor_size_to_dime.html">StensorSizeToDime</a>&lt; sizeof...(T)&gt;::value, std::common_type_t&lt; T... &gt;&gt;</td></tr>
<tr class="separator:afce6890cd20537117b59f077200ec7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf8b3a7a450c90fd17c668e72789a9c"><td class="memTemplParams" colspan="2"><a id="accf8b3a7a450c90fd17c668e72789a9c"></a>
template&lt;unsigned short N, typename T , typename OutputIterator &gt; </td></tr>
<tr class="memitem:accf8b3a7a450c90fd17c668e72789a9c"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#accf8b3a7a450c90fd17c668e72789a9c">exportToBaseTypeArray</a> (const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &amp;, OutputIterator) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T &gt;())</td></tr>
<tr class="memdesc:accf8b3a7a450c90fd17c668e72789a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">export the given vector to an array <br /></td></tr>
<tr class="separator:accf8b3a7a450c90fd17c668e72789a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6a818d3f33afa7e28e7b5791ee2f49"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a0a6a818d3f33afa7e28e7b5791ee2f49"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a0a6a818d3f33afa7e28e7b5791ee2f49">tresca</a> (const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &amp;, const bool=false)</td></tr>
<tr class="separator:a0a6a818d3f33afa7e28e7b5791ee2f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef63f7558d34da9a924006a4764aa372"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef63f7558d34da9a924006a4764aa372"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aef63f7558d34da9a924006a4764aa372">tresca</a> (const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; 1u, T &gt; &amp;, const bool=false)</td></tr>
<tr class="separator:aef63f7558d34da9a924006a4764aa372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ef56da14652c580893f90b165ae591"><td class="memItemLeft" align="right" valign="top">TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a14ef56da14652c580893f90b165ae591">square_root</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;)</td></tr>
<tr class="separator:a14ef56da14652c580893f90b165ae591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0500a481b56e6c1c0126186956c48a"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#afc0500a481b56e6c1c0126186956c48a">det</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:afc0500a481b56e6c1c0126186956c48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67f1e089683fb6b07ecf0e45000f789"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad67f1e089683fb6b07ecf0e45000f789">computeDeterminantDerivative</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:ad67f1e089683fb6b07ecf0e45000f789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fa16778a618c30ec0ed5747d78c3ff"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab5fa16778a618c30ec0ed5747d78c3ff">computeDeviatorDeterminantDerivative</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:ab5fa16778a618c30ec0ed5747d78c3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac56303ac7b6183f9a1ced0f9fce112"><td class="memTemplParams" colspan="2">template&lt;StensorConcept StensorType&gt; </td></tr>
<tr class="memitem:aaac56303ac7b6183f9a1ced0f9fce112"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aaac56303ac7b6183f9a1ced0f9fce112">change_basis</a> (const StensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; StensorType &gt;&gt; &amp;) noexcept</td></tr>
<tr class="memdesc:aaac56303ac7b6183f9a1ced0f9fce112"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotate a symmetric tensor using a rotation matrix  <a href="namespacetfel_1_1math.html#aaac56303ac7b6183f9a1ced0f9fce112">More...</a><br /></td></tr>
<tr class="separator:aaac56303ac7b6183f9a1ced0f9fce112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea6627e10b0e7c0205cac0033992669"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aeea6627e10b0e7c0205cac0033992669">invert</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:aeea6627e10b0e7c0205cac0033992669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e88c5dd0f3ecceb418c4d8e3d7491f"><td class="memTemplParams" colspan="2">template&lt;typename stensor_common::EigenSolver  = stensor_common::TFELEIGENSOLVER, typename Function , StensorConcept StensorType&gt; </td></tr>
<tr class="memitem:a00e88c5dd0f3ecceb418c4d8e3d7491f"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a00e88c5dd0f3ecceb418c4d8e3d7491f">computeIsotropicFunction</a> (const Function &amp;, const StensorType &amp;, const bool=false)</td></tr>
<tr class="separator:a00e88c5dd0f3ecceb418c4d8e3d7491f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe0609ad5a1c58be6199897773392d2"><td class="memTemplParams" colspan="2">template&lt;typename stensor_common::EigenSolver  = stensor_common::TFELEIGENSOLVER, typename Function , typename FunctionDerivative , StensorConcept StensorType&gt; </td></tr>
<tr class="memitem:a8fe0609ad5a1c58be6199897773392d2"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8fe0609ad5a1c58be6199897773392d2">computeIsotropicFunctionDerivative</a> (const Function &amp;, const FunctionDerivative &amp;, const StensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; StensorType &gt;, const bool=false)</td></tr>
<tr class="separator:a8fe0609ad5a1c58be6199897773392d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82cf2c8e7c4c1248681a6574d1542f7c"><td class="memTemplParams" colspan="2">template&lt;typename stensor_common::EigenSolver  = stensor_common::TFELEIGENSOLVER, typename Function , typename FunctionDerivative , StensorConcept StensorType&gt; </td></tr>
<tr class="memitem:a82cf2c8e7c4c1248681a6574d1542f7c"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a82cf2c8e7c4c1248681a6574d1542f7c">computeIsotropicFunctionAndDerivative</a> (const Function &amp;, const FunctionDerivative &amp;, const StensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; StensorType &gt;, const bool=false)</td></tr>
<tr class="separator:a82cf2c8e7c4c1248681a6574d1542f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e33815f244a68a37c7adfa09d24f7d"><td class="memTemplParams" colspan="2">template&lt;StensorConcept T, StensorConcept T2&gt; </td></tr>
<tr class="memitem:ab8e33815f244a68a37c7adfa09d24f7d"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab8e33815f244a68a37c7adfa09d24f7d">convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress</a> (const T &amp;, const T2 &amp;) noexcept requires((<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; T &gt;()</td></tr>
<tr class="memdesc:ab8e33815f244a68a37c7adfa09d24f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress  <a href="namespacetfel_1_1math.html#ab8e33815f244a68a37c7adfa09d24f7d">More...</a><br /></td></tr>
<tr class="separator:ab8e33815f244a68a37c7adfa09d24f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce53e8259a0b5d249bee1eba058bda5"><td class="memTemplParams" colspan="2">template&lt;StensorConcept T, StensorConcept T2&gt; </td></tr>
<tr class="memitem:a1ce53e8259a0b5d249bee1eba058bda5"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1ce53e8259a0b5d249bee1eba058bda5">convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress</a> (const T &amp;, const T2 &amp;) noexcept requires((<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; T &gt;()</td></tr>
<tr class="memdesc:a1ce53e8259a0b5d249bee1eba058bda5"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress:  <a href="namespacetfel_1_1math.html#a1ce53e8259a0b5d249bee1eba058bda5">More...</a><br /></td></tr>
<tr class="separator:a1ce53e8259a0b5d249bee1eba058bda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13652efb5c63e23bb677ad7bad071280"><td class="memTemplParams" colspan="2">template&lt;StensorConcept StensorType1, StensorConcept StensorType2&gt; </td></tr>
<tr class="memitem:a13652efb5c63e23bb677ad7bad071280"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a13652efb5c63e23bb677ad7bad071280">symmetric_product</a> (const StensorType1 &amp;, const StensorType2 &amp;) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; StensorType1 &gt;()</td></tr>
<tr class="memdesc:a13652efb5c63e23bb677ad7bad071280"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the symmetric product of two stensors as a symmetric tensor:  <a href="namespacetfel_1_1math.html#a13652efb5c63e23bb677ad7bad071280">More...</a><br /></td></tr>
<tr class="separator:a13652efb5c63e23bb677ad7bad071280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0fa3ccea2c695fef62f43df5400784"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#afc0fa3ccea2c695fef62f43df5400784">convertToT2toST2</a> (const <a class="el" href="namespacetfel_1_1math.html#a1cdbe69ac76f33f811132f6d7ad5ff04">T2toT2Concept</a> auto &amp;) noexcept</td></tr>
<tr class="memdesc:afc0fa3ccea2c695fef62f43df5400784"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a>  <a href="namespacetfel_1_1math.html#afc0fa3ccea2c695fef62f43df5400784">More...</a><br /></td></tr>
<tr class="separator:afc0fa3ccea2c695fef62f43df5400784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5737b11fa1415778870a498a33d3ca"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9a5737b11fa1415778870a498a33d3ca">computeRateOfDeformationDerivative</a> (const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;F) noexcept</td></tr>
<tr class="separator:a9a5737b11fa1415778870a498a33d3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ead0ca634dc6b0fb81961391e2d076"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab8ead0ca634dc6b0fb81961391e2d076">abs</a> (const <a class="el" href="namespacetfel_1_1math.html#a27e6aca4a83fd4f27fb85c9d5811478f">T2toST2Concept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:ab8ead0ca634dc6b0fb81961391e2d076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ebf12208afcb4a3e7887f84b5e3a9b"><td class="memTemplParams" colspan="2">template&lt;T2toST2Concept T2toST2ResultType, T2toST2Concept T2toST2Type, StensorConcept StensorType, TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:a99ebf12208afcb4a3e7887f84b5e3a9b"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a99ebf12208afcb4a3e7887f84b5e3a9b">computeKirchhoffStressDerivativeFromCauchyStressDerivative</a> (T2toST2ResultType &amp;, const T2toST2Type &amp;, const StensorType &amp;, const TensorType &amp;) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; T2toST2ResultType &gt;()</td></tr>
<tr class="memdesc:a99ebf12208afcb4a3e7887f84b5e3a9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Kirchhoff stress derivative from the Cauchy stress derivative with respect to the deformation gradient  <a href="namespacetfel_1_1math.html#a99ebf12208afcb4a3e7887f84b5e3a9b">More...</a><br /></td></tr>
<tr class="separator:a99ebf12208afcb4a3e7887f84b5e3a9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0091b9045d4df080ad289bb8bbf416"><td class="memTemplParams" colspan="2">template&lt;T2toST2Concept T2toST2Type&gt; </td></tr>
<tr class="memitem:afa0091b9045d4df080ad289bb8bbf416"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#afa0091b9045d4df080ad289bb8bbf416">implementsT2toST2Concept</a> ()</td></tr>
<tr class="memdesc:afa0091b9045d4df080ad289bb8bbf416"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code>T2toST2Concept</code>.  <a href="namespacetfel_1_1math.html#afa0091b9045d4df080ad289bb8bbf416">More...</a><br /></td></tr>
<tr class="separator:afa0091b9045d4df080ad289bb8bbf416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c20f68fceec0f1e5d92811de408c870"><td class="memTemplParams" colspan="2"><a id="a3c20f68fceec0f1e5d92811de408c870"></a>
template&lt;T2toST2Concept T2toST2ResultType, StensorConcept StensorType, TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:a3c20f68fceec0f1e5d92811de408c870"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>computePushForwardDerivativeWithRespectToDeformationGradient</b> (T2toST2ResultType &amp;dTdF, const StensorType &amp;S, const TensorType &amp;F) noexcept requires(tfel</td></tr>
<tr class="separator:a3c20f68fceec0f1e5d92811de408c870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443f32c771f1b7df3419ba96d4e70ad5"><td class="memItemLeft" align="right" valign="top"><a id="a443f32c771f1b7df3419ba96d4e70ad5"></a>
TFEL_HOST std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a443f32c771f1b7df3419ba96d4e70ad5">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespacetfel_1_1math.html#a27e6aca4a83fd4f27fb85c9d5811478f">T2toST2Concept</a> auto &amp;t)</td></tr>
<tr class="memdesc:a443f32c771f1b7df3419ba96d4e70ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialisation operator <br /></td></tr>
<tr class="separator:a443f32c771f1b7df3419ba96d4e70ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49dc934896190f7e457e19d2584e686c"><td class="memItemLeft" align="right" valign="top"><a id="a49dc934896190f7e457e19d2584e686c"></a>
constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><b>operator|</b> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;a, const <a class="el" href="namespacetfel_1_1math.html#a27e6aca4a83fd4f27fb85c9d5811478f">T2toST2Concept</a> auto &amp;b) noexcept requires(!<a class="el" href="namespacetfel_1_1math.html#ac32a69a130c0d7dfdd5860981401e860">isInvalid</a>&lt; <a class="el" href="namespacetfel_1_1math.html#af36bc9045afd07925b2bfef0a00c27f7">BinaryOperationResult</a>&lt; decltype(a)</td></tr>
<tr class="separator:a49dc934896190f7e457e19d2584e686c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb951995af31c548aefeee1571f460bd"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , std::size_t M, std::size_t... d&gt; </td></tr>
<tr class="memitem:aeb951995af31c548aefeee1571f460bd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aeb951995af31c548aefeee1571f460bd">t2tost2</a> (ValueType const (&amp;)[M], ValueType const (&amp;... arrays)[d]) -&gt; <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; <a class="el" href="class_stensor_size_to_dime.html">StensorSizeToDime</a>&lt; sizeof...(d)+1 &gt;::value, ValueType &gt;</td></tr>
<tr class="memdesc:aeb951995af31c548aefeee1571f460bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">class template argument deduction  <a href="namespacetfel_1_1math.html#aeb951995af31c548aefeee1571f460bd">More...</a><br /></td></tr>
<tr class="separator:aeb951995af31c548aefeee1571f460bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52adc5b5d15ad84afb2cb0e119848186"><td class="memTemplParams" colspan="2">template&lt;T2toST2Concept T2toST2Type&gt; </td></tr>
<tr class="memitem:a52adc5b5d15ad84afb2cb0e119848186"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a52adc5b5d15ad84afb2cb0e119848186">change_basis</a> (const T2toST2Type &amp;, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; T2toST2Type &gt;&gt; &amp;) noexcept</td></tr>
<tr class="separator:a52adc5b5d15ad84afb2cb0e119848186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76bbb1f302a9689d4e3d3ca700d5b1f"><td class="memTemplParams" colspan="2">template&lt;T2toST2Concept T2toST2Type, StensorConcept StensorType, TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:ad76bbb1f302a9689d4e3d3ca700d5b1f"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad76bbb1f302a9689d4e3d3ca700d5b1f">computeCauchyStressDerivativeFromKirchhoffStressDerivative</a> (const T2toST2Type &amp;, const StensorType &amp;, const TensorType &amp;) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; T2toST2Type &gt;()</td></tr>
<tr class="memdesc:ad76bbb1f302a9689d4e3d3ca700d5b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Cauchy stress derivative from the Kirchhoff stress derivative  <a href="namespacetfel_1_1math.html#ad76bbb1f302a9689d4e3d3ca700d5b1f">More...</a><br /></td></tr>
<tr class="separator:ad76bbb1f302a9689d4e3d3ca700d5b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af451306a6dd1a530f0ceb57d4847b4a2"><td class="memTemplParams" colspan="2">template&lt;T2toST2Concept T2toST2Type, StensorConcept StensorType, TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:af451306a6dd1a530f0ceb57d4847b4a2"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af451306a6dd1a530f0ceb57d4847b4a2">computeKirchhoffStressDerivativeFromCauchyStressDerivative</a> (const T2toST2Type &amp;, const StensorType &amp;, const TensorType &amp;) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; T2toST2Type &gt;()</td></tr>
<tr class="memdesc:af451306a6dd1a530f0ceb57d4847b4a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Cauchy stress derivative from the Kirchhoff stress derivative  <a href="namespacetfel_1_1math.html#af451306a6dd1a530f0ceb57d4847b4a2">More...</a><br /></td></tr>
<tr class="separator:af451306a6dd1a530f0ceb57d4847b4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59781abd3146ca9f755d9cd3e9a33e93"><td class="memTemplParams" colspan="2">template&lt;T2toST2Concept T2toST2Type, StensorConcept StensorType, TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:a59781abd3146ca9f755d9cd3e9a33e93"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a59781abd3146ca9f755d9cd3e9a33e93">computePushForwardDerivative</a> (const T2toST2Type &amp;, const StensorType &amp;, const TensorType &amp;) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; StensorType &gt;()</td></tr>
<tr class="separator:a59781abd3146ca9f755d9cd3e9a33e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b476210e3ab09b84191492dbd32ca31"><td class="memTemplParams" colspan="2"><a id="a1b476210e3ab09b84191492dbd32ca31"></a>
template&lt;unsigned short N, typename stress , typename real &gt; </td></tr>
<tr class="memitem:a1b476210e3ab09b84191492dbd32ca31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFirstPiolaKirchoffStressDerivativeToKirchhoffStressDerivative</b> (<a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt; &amp;dtau, const <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;dP, const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;F, const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;s)</td></tr>
<tr class="separator:a1b476210e3ab09b84191492dbd32ca31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d10c3f37889e17474cd908ca06dcd86"><td class="memTemplParams" colspan="2"><a id="a5d10c3f37889e17474cd908ca06dcd86"></a>
template&lt;unsigned short N, typename stress , typename real &gt; </td></tr>
<tr class="memitem:a5d10c3f37889e17474cd908ca06dcd86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convertFirstPiolaKirchoffStressDerivativeToKirchhoffStressDerivative</b> (const <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;dP, const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;F, const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;s)</td></tr>
<tr class="separator:a5d10c3f37889e17474cd908ca06dcd86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600d19fd973cd5038b585498516862dc"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename stress , typename real &gt; </td></tr>
<tr class="memitem:a600d19fd973cd5038b585498516862dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a600d19fd973cd5038b585498516862dc">convertCauchyStressDerivativeToFirstPiolaKirchoffStressDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;)</td></tr>
<tr class="memdesc:a600d19fd973cd5038b585498516862dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the derivative of the Cauchy stress with respect to the deformation gradient to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient.  <a href="namespacetfel_1_1math.html#a600d19fd973cd5038b585498516862dc">More...</a><br /></td></tr>
<tr class="separator:a600d19fd973cd5038b585498516862dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7008df38bf4fc3f8170249537b46190a"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename stress , typename real &gt; </td></tr>
<tr class="memitem:a7008df38bf4fc3f8170249537b46190a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7008df38bf4fc3f8170249537b46190a">convertCauchyStressDerivativeToFirstPiolaKirchoffStressDerivative</a> (<a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;)</td></tr>
<tr class="memdesc:a7008df38bf4fc3f8170249537b46190a"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the derivative of the Cauchy stress with respect to the deformation gradient to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient.  <a href="namespacetfel_1_1math.html#a7008df38bf4fc3f8170249537b46190a">More...</a><br /></td></tr>
<tr class="separator:a7008df38bf4fc3f8170249537b46190a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce7f75958777ea853a9b64d93d6a994"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename stress , typename real &gt; </td></tr>
<tr class="memitem:acce7f75958777ea853a9b64d93d6a994"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#acce7f75958777ea853a9b64d93d6a994">convertSecondPiolaKirchhoffStressDerivativeToFirstPiolaKirchoffStressDerivative</a> (const <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;)</td></tr>
<tr class="memdesc:acce7f75958777ea853a9b64d93d6a994"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the derivative of the second Piola-Kirchoff stress with respect to the Green-Lagrange strain to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient.  <a href="namespacetfel_1_1math.html#acce7f75958777ea853a9b64d93d6a994">More...</a><br /></td></tr>
<tr class="separator:acce7f75958777ea853a9b64d93d6a994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f42fbb8c13638c5a527d08c44ab55a"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename stress , typename real &gt; </td></tr>
<tr class="memitem:af2f42fbb8c13638c5a527d08c44ab55a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#af2f42fbb8c13638c5a527d08c44ab55a">convertSecondPiolaKirchhoffStressDerivativeToFirstPiolaKirchoffStressDerivative</a> (<a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, stress &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;)</td></tr>
<tr class="memdesc:af2f42fbb8c13638c5a527d08c44ab55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the derivative of the second Piola-Kirchoff stress with respect to the Green-Lagrange strain to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient.  <a href="namespacetfel_1_1math.html#af2f42fbb8c13638c5a527d08c44ab55a">More...</a><br /></td></tr>
<tr class="separator:af2f42fbb8c13638c5a527d08c44ab55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae218a6c03a2b01153f65df08d24725a5"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae218a6c03a2b01153f65df08d24725a5">abs</a> (const <a class="el" href="namespacetfel_1_1math.html#a1cdbe69ac76f33f811132f6d7ad5ff04">T2toT2Concept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:ae218a6c03a2b01153f65df08d24725a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e2d43520e6f3f4d9a22e70d895d12f"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a19e2d43520e6f3f4d9a22e70d895d12f">det</a> (const <a class="el" href="namespacetfel_1_1math.html#a1cdbe69ac76f33f811132f6d7ad5ff04">T2toT2Concept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:a19e2d43520e6f3f4d9a22e70d895d12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4779ca9f4de28e5be47542d5f90e554c"><td class="memTemplParams" colspan="2">template&lt;T2toT2Concept T2toT2Type&gt; </td></tr>
<tr class="memitem:a4779ca9f4de28e5be47542d5f90e554c"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a4779ca9f4de28e5be47542d5f90e554c">implementsT2toT2Concept</a> ()</td></tr>
<tr class="memdesc:a4779ca9f4de28e5be47542d5f90e554c"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code>T2toT2Concept</code>.  <a href="namespacetfel_1_1math.html#a4779ca9f4de28e5be47542d5f90e554c">More...</a><br /></td></tr>
<tr class="separator:a4779ca9f4de28e5be47542d5f90e554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d9b2a47591b17ff66c46eb94a5202e"><td class="memItemLeft" align="right" valign="top"><a id="a11d9b2a47591b17ff66c46eb94a5202e"></a>
TFEL_HOST std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a11d9b2a47591b17ff66c46eb94a5202e">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="namespacetfel_1_1math.html#a1cdbe69ac76f33f811132f6d7ad5ff04">T2toT2Concept</a> auto &amp;t)</td></tr>
<tr class="memdesc:a11d9b2a47591b17ff66c46eb94a5202e"><td class="mdescLeft">&#160;</td><td class="mdescRight">serialisation operator <br /></td></tr>
<tr class="separator:a11d9b2a47591b17ff66c46eb94a5202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e2f57164e56a19362a733f73db5124"><td class="memTemplParams" colspan="2">template&lt;TensorConcept T1, T2toT2Concept T2&gt; </td></tr>
<tr class="memitem:a80e2f57164e56a19362a733f73db5124"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a80e2f57164e56a19362a733f73db5124">operator|</a> (const T1 &amp;a, const T2 &amp;b) noexcept requires(!<a class="el" href="namespacetfel_1_1math.html#ac32a69a130c0d7dfdd5860981401e860">isInvalid</a>&lt; <a class="el" href="namespacetfel_1_1math.html#af36bc9045afd07925b2bfef0a00c27f7">BinaryOperationResult</a>&lt; T1</td></tr>
<tr class="separator:a80e2f57164e56a19362a733f73db5124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e250606767ed66972ec28cc8f9bc4e"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , std::size_t M, std::size_t... d&gt; </td></tr>
<tr class="memitem:a97e250606767ed66972ec28cc8f9bc4e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a97e250606767ed66972ec28cc8f9bc4e">t2tot2</a> (ValueType const (&amp;)[M], ValueType const (&amp;... arrays)[d]) -&gt; <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="class_tensor_size_to_dime.html">TensorSizeToDime</a>&lt; sizeof...(d)+1 &gt;::value, ValueType &gt;</td></tr>
<tr class="memdesc:a97e250606767ed66972ec28cc8f9bc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">class template argument deduction  <a href="namespacetfel_1_1math.html#a97e250606767ed66972ec28cc8f9bc4e">More...</a><br /></td></tr>
<tr class="separator:a97e250606767ed66972ec28cc8f9bc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9f9097d3b6f624dc6b7656f5e48b95"><td class="memTemplParams" colspan="2">template&lt;T2toT2Concept T2toT2Type&gt; </td></tr>
<tr class="memitem:aaa9f9097d3b6f624dc6b7656f5e48b95"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aaa9f9097d3b6f624dc6b7656f5e48b95">change_basis</a> (const T2toT2Type &amp;, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; T2toT2Type &gt;&gt; &amp;) noexcept</td></tr>
<tr class="separator:aaa9f9097d3b6f624dc6b7656f5e48b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf64b9dcf1afdfb6a48660e6e98cd461"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#adf64b9dcf1afdfb6a48660e6e98cd461">computeVelocityGradientDerivative</a> (const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:adf64b9dcf1afdfb6a48660e6e98cd461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dae14680e16598e16b2eb595ab36cbf"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a8dae14680e16598e16b2eb595ab36cbf">computeSpinRateDerivative</a> (const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:a8dae14680e16598e16b2eb595ab36cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d56ca42c3cdec6ec331092b5855391"><td class="memTemplParams" colspan="2">template&lt;TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:ab3d56ca42c3cdec6ec331092b5855391"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab3d56ca42c3cdec6ec331092b5855391">computeDeterminantSecondDerivative</a> (const TensorType &amp;) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; TensorType &gt;&gt;())</td></tr>
<tr class="memdesc:ab3d56ca42c3cdec6ec331092b5855391"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the second derivative of the determinant of a symmetric tensor  <a href="namespacetfel_1_1math.html#ab3d56ca42c3cdec6ec331092b5855391">More...</a><br /></td></tr>
<tr class="separator:ab3d56ca42c3cdec6ec331092b5855391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5cb81d357841c53c29462fe2f35da1"><td class="memTemplParams" colspan="2"><a id="a0f5cb81d357841c53c29462fe2f35da1"></a>
template&lt;typename T , T2toST2Concept T2toST2Type&gt; </td></tr>
<tr class="memitem:a0f5cb81d357841c53c29462fe2f35da1"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert</b> (<a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; T2toST2Type &gt;(), T &gt; &amp;, const T2toST2Type &amp;) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#aea2a48b5882876da6707ada2c302f4bd">isAssignableTo</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; T2toST2Type &gt;</td></tr>
<tr class="separator:a0f5cb81d357841c53c29462fe2f35da1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d002b538fd7c9672c51b6029739d9b"><td class="memItemLeft" align="right" valign="top"><a id="a03d002b538fd7c9672c51b6029739d9b"></a>
constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>T</b> ())</td></tr>
<tr class="separator:a03d002b538fd7c9672c51b6029739d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44182879363250acac8fba6e028d4280"><td class="memTemplParams" colspan="2"><a id="a44182879363250acac8fba6e028d4280"></a>
template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a44182879363250acac8fba6e028d4280"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exportToBaseTypeArray</b> (const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, T &gt; &amp;t, const auto p) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T &gt;())</td></tr>
<tr class="separator:a44182879363250acac8fba6e028d4280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ba3b459f1670e91a09e9dd96e6f274"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a52ba3b459f1670e91a09e9dd96e6f274">invert</a> (const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;t) noexcept</td></tr>
<tr class="separator:a52ba3b459f1670e91a09e9dd96e6f274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae29c553e64c6bcc1d941b87194f6014"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aae29c553e64c6bcc1d941b87194f6014">computeDeterminantDerivative</a> (const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;F) noexcept</td></tr>
<tr class="separator:aae29c553e64c6bcc1d941b87194f6014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8a111e7d18f010b629a418f1701016"><td class="memTemplParams" colspan="2">template&lt;TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:add8a111e7d18f010b629a418f1701016"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#add8a111e7d18f010b629a418f1701016">change_basis</a> (const TensorType &amp;, const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; TensorType &gt;&gt; &amp;) noexcept</td></tr>
<tr class="memdesc:add8a111e7d18f010b629a418f1701016"><td class="mdescLeft">&#160;</td><td class="mdescRight">rotate a tensor using a rotation matrix  <a href="namespacetfel_1_1math.html#add8a111e7d18f010b629a418f1701016">More...</a><br /></td></tr>
<tr class="separator:add8a111e7d18f010b629a418f1701016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d42c5379cbec7faa5e35f780c1451cb"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1d42c5379cbec7faa5e35f780c1451cb">unsyme</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;s) noexcept</td></tr>
<tr class="separator:a1d42c5379cbec7faa5e35f780c1451cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add97ec4538ae3252f1f2d3dc122aec35"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#add97ec4538ae3252f1f2d3dc122aec35">convertCauchyStressToFirstPiolaKirchhoffStress</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="memdesc:add97ec4538ae3252f1f2d3dc122aec35"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the Cauchy stress to the first Piola-Kirchhoff stress.  <a href="namespacetfel_1_1math.html#add97ec4538ae3252f1f2d3dc122aec35">More...</a><br /></td></tr>
<tr class="separator:add97ec4538ae3252f1f2d3dc122aec35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79dd742a1986cd03a99d3259d9b190eb"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a79dd742a1986cd03a99d3259d9b190eb">convertFirstPiolaKirchhoffStressToCauchyStress</a> (const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="memdesc:a79dd742a1986cd03a99d3259d9b190eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the first Piola-Kirchhoff stress to the Cauchy stress  <a href="namespacetfel_1_1math.html#a79dd742a1986cd03a99d3259d9b190eb">More...</a><br /></td></tr>
<tr class="separator:a79dd742a1986cd03a99d3259d9b190eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d941b376105841dfccd3f6831fa616"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a91d941b376105841dfccd3f6831fa616">abs</a> (const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:a91d941b376105841dfccd3f6831fa616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f892f7f49207008189f30e3d7344ec"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a40f892f7f49207008189f30e3d7344ec">trace</a> (const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:a40f892f7f49207008189f30e3d7344ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10370291140fbcc701193930ddfe04d"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab10370291140fbcc701193930ddfe04d">syme</a> (const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:ab10370291140fbcc701193930ddfe04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081cb54ae3c02e1b775ad2d77936fd40"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a081cb54ae3c02e1b775ad2d77936fd40">computeRightCauchyGreenTensor</a> (const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:a081cb54ae3c02e1b775ad2d77936fd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229ac783dcc1fe8ccb33e1f0863d25c4"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a229ac783dcc1fe8ccb33e1f0863d25c4">computeLeftCauchyGreenTensor</a> (const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:a229ac783dcc1fe8ccb33e1f0863d25c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62dd946d8c03830d57f9f1dbe37cba1"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae62dd946d8c03830d57f9f1dbe37cba1">computeGreenLagrangeTensor</a> (const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:ae62dd946d8c03830d57f9f1dbe37cba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab334987571493a2fef52471dfacb35db"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab334987571493a2fef52471dfacb35db">pushForward</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:ab334987571493a2fef52471dfacb35db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39daae537bddf4501a51859debdb860e"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a39daae537bddf4501a51859debdb860e">push_forward</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:a39daae537bddf4501a51859debdb860e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c8c06e61c8a679d8997c71bd297813"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a21c8c06e61c8a679d8997c71bd297813">convertCauchyStressToSecondPiolaKirchhoffStress</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="memdesc:a21c8c06e61c8a679d8997c71bd297813"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the Cauchy stress to the second Piola-Kirchhoff stress  <a href="namespacetfel_1_1math.html#a21c8c06e61c8a679d8997c71bd297813">More...</a><br /></td></tr>
<tr class="separator:a21c8c06e61c8a679d8997c71bd297813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ad6b9eb6830047f45d4d5dfe839c76"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a21ad6b9eb6830047f45d4d5dfe839c76">convertSecondPiolaKirchhoffStressToCauchyStress</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="memdesc:a21ad6b9eb6830047f45d4d5dfe839c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert the second Piola-Kirchhoff stress to the Cauchy stress  <a href="namespacetfel_1_1math.html#a21ad6b9eb6830047f45d4d5dfe839c76">More...</a><br /></td></tr>
<tr class="separator:a21ad6b9eb6830047f45d4d5dfe839c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fd1c98651efcd79b6a7af293e47b1d"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ac2fd1c98651efcd79b6a7af293e47b1d">det</a> (const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="separator:ac2fd1c98651efcd79b6a7af293e47b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9fc0413cf4f8d060c46fb7324ac9af"><td class="memItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a3f9fc0413cf4f8d060c46fb7324ac9af">computeDeterminantDerivative</a> (<a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;) noexcept</td></tr>
<tr class="memdesc:a3f9fc0413cf4f8d060c46fb7324ac9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the derivative of the determinant with respect to its argument.  <a href="namespacetfel_1_1math.html#a3f9fc0413cf4f8d060c46fb7324ac9af">More...</a><br /></td></tr>
<tr class="separator:a3f9fc0413cf4f8d060c46fb7324ac9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348eeef65b9f9104eb9db425f3f29127"><td class="memItemLeft" align="right" valign="top">TFEL_HOST <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a348eeef65b9f9104eb9db425f3f29127">polar_decomposition</a> (<a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;, <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;, const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;)</td></tr>
<tr class="memdesc:a348eeef65b9f9104eb9db425f3f29127"><td class="mdescLeft">&#160;</td><td class="mdescRight">provide the polar decomposition of a tensor  <a href="namespacetfel_1_1math.html#a348eeef65b9f9104eb9db425f3f29127">More...</a><br /></td></tr>
<tr class="separator:a348eeef65b9f9104eb9db425f3f29127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b218c7bb3f7700ac54a9878340cf38"><td class="memTemplParams" colspan="2">template&lt;TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:a70b218c7bb3f7700ac54a9878340cf38"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a70b218c7bb3f7700ac54a9878340cf38">matrix_view</a> (TensorType &amp;&amp;t) noexcept</td></tr>
<tr class="separator:a70b218c7bb3f7700ac54a9878340cf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e541ea20d7ac9d3cea6c06b473a083"><td class="memTemplParams" colspan="2">template&lt;TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:a02e541ea20d7ac9d3cea6c06b473a083"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a02e541ea20d7ac9d3cea6c06b473a083">transpose</a> (TensorType &amp;&amp;) noexcept</td></tr>
<tr class="separator:a02e541ea20d7ac9d3cea6c06b473a083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa182da9de40e1aa645d5e36d733de510"><td class="memTemplParams" colspan="2">template&lt;typename TensorType &gt; </td></tr>
<tr class="memitem:aa182da9de40e1aa645d5e36d733de510"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa182da9de40e1aa645d5e36d733de510">implementsTensorConcept</a> ()</td></tr>
<tr class="memdesc:aa182da9de40e1aa645d5e36d733de510"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code>TensorConcept</code>.  <a href="namespacetfel_1_1math.html#aa182da9de40e1aa645d5e36d733de510">More...</a><br /></td></tr>
<tr class="separator:aa182da9de40e1aa645d5e36d733de510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc415d6d70ed9fd58123a7ef35384711"><td class="memTemplParams" colspan="2"><a id="acc415d6d70ed9fd58123a7ef35384711"></a>
template&lt;TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:acc415d6d70ed9fd58123a7ef35384711"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const TensorType &amp;s)</td></tr>
<tr class="separator:acc415d6d70ed9fd58123a7ef35384711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa686a6dc0aa4370f0c2665b2a5e689fc"><td class="memTemplParams" colspan="2">template&lt;TensorConcept TensorType1, TensorConcept TensorType2&gt; </td></tr>
<tr class="memitem:aa686a6dc0aa4370f0c2665b2a5e689fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa686a6dc0aa4370f0c2665b2a5e689fc">operator|</a> (const TensorType1 &amp;, const TensorType2 &amp;) noexcept requires(!<a class="el" href="namespacetfel_1_1math.html#ac32a69a130c0d7dfdd5860981401e860">isInvalid</a>&lt; <a class="el" href="namespacetfel_1_1math.html#af36bc9045afd07925b2bfef0a00c27f7">BinaryOperationResult</a>&lt; TensorType1</td></tr>
<tr class="separator:aa686a6dc0aa4370f0c2665b2a5e689fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d13e1d7c841c1578bb03a8495ae4855"><td class="memItemLeft" align="right" valign="top"><a id="a4d13e1d7c841c1578bb03a8495ae4855"></a>
constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><b>OpDotProduct</b> ())</td></tr>
<tr class="separator:a4d13e1d7c841c1578bb03a8495ae4855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a8f6b08022aaa74509829aebf5d2eb"><td class="memTemplParams" colspan="2"><a id="ac5a8f6b08022aaa74509829aebf5d2eb"></a>
template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ac5a8f6b08022aaa74509829aebf5d2eb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tensor</b> (T &amp;&amp;... t) -&gt; <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; <a class="el" href="class_tensor_size_to_dime.html">TensorSizeToDime</a>&lt; sizeof...(T)&gt;::value, std::common_type_t&lt; T... &gt;&gt;</td></tr>
<tr class="separator:ac5a8f6b08022aaa74509829aebf5d2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba6ea982aec09dec9c7adf3960603a0"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , std::size_t M, std::size_t... d&gt; </td></tr>
<tr class="memitem:aaba6ea982aec09dec9c7adf3960603a0"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aaba6ea982aec09dec9c7adf3960603a0">tmatrix</a> (ValueType const (&amp;)[M], ValueType const (&amp;... arrays)[d]) -&gt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 1u+sizeof...(d), M, ValueType &gt;</td></tr>
<tr class="memdesc:aaba6ea982aec09dec9c7adf3960603a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">class template argument deduction  <a href="namespacetfel_1_1math.html#aaba6ea982aec09dec9c7adf3960603a0">More...</a><br /></td></tr>
<tr class="separator:aaba6ea982aec09dec9c7adf3960603a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fcd5e35d761ba61d17a2b0183f545b"><td class="memTemplParams" colspan="2"><a id="ae0fcd5e35d761ba61d17a2b0183f545b"></a>
template&lt;unsigned short N, unsigned short M, typename T &gt; </td></tr>
<tr class="memitem:ae0fcd5e35d761ba61d17a2b0183f545b"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; M, N, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transpose</b> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, T &gt; &amp;)</td></tr>
<tr class="separator:ae0fcd5e35d761ba61d17a2b0183f545b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d78b4d6efa27750dc1cd45b53cac8a3"><td class="memTemplParams" colspan="2"><a id="a9d78b4d6efa27750dc1cd45b53cac8a3"></a>
template&lt;typename T , typename Operation &gt; </td></tr>
<tr class="memitem:a9d78b4d6efa27750dc1cd45b53cac8a3"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 2, 2, T &gt;, Operation &gt; &amp;)</td></tr>
<tr class="separator:a9d78b4d6efa27750dc1cd45b53cac8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422c7450f546d0f31be9f90306d38889"><td class="memTemplParams" colspan="2"><a id="a422c7450f546d0f31be9f90306d38889"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a422c7450f546d0f31be9f90306d38889"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 2, 2, T &gt; &amp;)</td></tr>
<tr class="separator:a422c7450f546d0f31be9f90306d38889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2021ce3ccc82bd9444919ae89e392d99"><td class="memTemplParams" colspan="2"><a id="a2021ce3ccc82bd9444919ae89e392d99"></a>
template&lt;typename T , typename Operation &gt; </td></tr>
<tr class="memitem:a2021ce3ccc82bd9444919ae89e392d99"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3, 3, T &gt;, Operation &gt; &amp;)</td></tr>
<tr class="separator:a2021ce3ccc82bd9444919ae89e392d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eee9ab6399011ca7a77707ce7a5758d"><td class="memTemplParams" colspan="2"><a id="a1eee9ab6399011ca7a77707ce7a5758d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1eee9ab6399011ca7a77707ce7a5758d"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>det</b> (const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 3, 3, T &gt; &amp;)</td></tr>
<tr class="separator:a1eee9ab6399011ca7a77707ce7a5758d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e4c5b5b1e7b9566c97a32f4b31b40d"><td class="memTemplParams" colspan="2">template&lt;unsigned short I, unsigned short J, typename FunctionType , typename VariableType , unsigned short N, unsigned short M&gt; </td></tr>
<tr class="memitem:ae4e4c5b5b1e7b9566c97a32f4b31b40d"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="namespacetfel_1_1math.html#a01ca08095dda1754ec1294f599a9e042">derivative_view_from_tiny_matrix</a>&lt; M, FunctionType, VariableType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae4e4c5b5b1e7b9566c97a32f4b31b40d">map_derivative</a> (<a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a8a8691d8234e536cdd0d357a2bc5d10c">derivative_type</a>&lt; FunctionType, VariableType &gt;&gt;&gt;&gt; &amp;)</td></tr>
<tr class="memdesc:ae4e4c5b5b1e7b9566c97a32f4b31b40d"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function to create a derivative view from a tiny matrix  <a href="namespacetfel_1_1math.html#ae4e4c5b5b1e7b9566c97a32f4b31b40d">More...</a><br /></td></tr>
<tr class="separator:ae4e4c5b5b1e7b9566c97a32f4b31b40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56102d4207cb6f4c5cb69b2408a0b3cd"><td class="memTemplParams" colspan="2">template&lt;typename FunctionType , typename VariableType , unsigned short N, unsigned short M&gt; </td></tr>
<tr class="memitem:a56102d4207cb6f4c5cb69b2408a0b3cd"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="namespacetfel_1_1math.html#a01ca08095dda1754ec1294f599a9e042">derivative_view_from_tiny_matrix</a>&lt; M, FunctionType, VariableType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a56102d4207cb6f4c5cb69b2408a0b3cd">map_derivative</a> (<a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a8a8691d8234e536cdd0d357a2bc5d10c">derivative_type</a>&lt; FunctionType, VariableType &gt;&gt;&gt;&gt; &amp;, const unsigned short, const unsigned short)</td></tr>
<tr class="memdesc:a56102d4207cb6f4c5cb69b2408a0b3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function to create a derivative view from a tiny matrix  <a href="namespacetfel_1_1math.html#a56102d4207cb6f4c5cb69b2408a0b3cd">More...</a><br /></td></tr>
<tr class="separator:a56102d4207cb6f4c5cb69b2408a0b3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab974e937e9c60d3c1f32d5a2eaa7018b"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , unsigned short N&gt; </td></tr>
<tr class="memitem:ab974e937e9c60d3c1f32d5a2eaa7018b"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, std::invoke_result_t&lt; F, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab974e937e9c60d3c1f32d5a2eaa7018b">map</a> (F, const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="memdesc:ab974e937e9c60d3c1f32d5a2eaa7018b"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new tvector by applying a functor  <a href="namespacetfel_1_1math.html#ab974e937e9c60d3c1f32d5a2eaa7018b">More...</a><br /></td></tr>
<tr class="separator:ab974e937e9c60d3c1f32d5a2eaa7018b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916f1ef97fcae6df02e9283dac8e0e6d"><td class="memTemplParams" colspan="2">template&lt;unsigned short N, typename T , typename OutputIterator &gt; </td></tr>
<tr class="memitem:a916f1ef97fcae6df02e9283dac8e0e6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a916f1ef97fcae6df02e9283dac8e0e6d">exportToBaseTypeArray</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;, OutputIterator) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T &gt;())</td></tr>
<tr class="separator:a916f1ef97fcae6df02e9283dac8e0e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b33b8cc9722bc96fa26aeb79200fdaa"><td class="memTemplParams" colspan="2"><a id="a5b33b8cc9722bc96fa26aeb79200fdaa"></a>
template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a5b33b8cc9722bc96fa26aeb79200fdaa"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>norm</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; T &gt;())</td></tr>
<tr class="separator:a5b33b8cc9722bc96fa26aeb79200fdaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa474d6740ec1e0b601009bbdf593540c"><td class="memTemplParams" colspan="2"><a id="aa474d6740ec1e0b601009bbdf593540c"></a>
template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:aa474d6740ec1e0b601009bbdf593540c"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>abs</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;v) noexcept</td></tr>
<tr class="separator:aa474d6740ec1e0b601009bbdf593540c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f474feddc62627fb2afb4bbdf3f218e"><td class="memTemplParams" colspan="2"><a id="a1f474feddc62627fb2afb4bbdf3f218e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f474feddc62627fb2afb4bbdf3f218e"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 1u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeTVector1D</b> (const T) noexcept</td></tr>
<tr class="separator:a1f474feddc62627fb2afb4bbdf3f218e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2a06e06d26c95cf35c133c2973916a"><td class="memTemplParams" colspan="2"><a id="a8f2a06e06d26c95cf35c133c2973916a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f2a06e06d26c95cf35c133c2973916a"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 2u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeTVector2D</b> (const T, const T) noexcept</td></tr>
<tr class="separator:a8f2a06e06d26c95cf35c133c2973916a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d071458b5a071e8cd7a766e68e52263"><td class="memTemplParams" colspan="2"><a id="a2d071458b5a071e8cd7a766e68e52263"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d071458b5a071e8cd7a766e68e52263"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>makeTVector3D</b> (const T, const T, const T) noexcept</td></tr>
<tr class="separator:a2d071458b5a071e8cd7a766e68e52263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e6c5c07bb0a1a8caca7e599acdbaf5"><td class="memTemplParams" colspan="2"><a id="ad9e6c5c07bb0a1a8caca7e599acdbaf5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9e6c5c07bb0a1a8caca7e599acdbaf5"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cross_product</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 2u, T &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 2u, T &gt; &amp;) noexcept</td></tr>
<tr class="separator:ad9e6c5c07bb0a1a8caca7e599acdbaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1253d9932f52481b43b325338f5f37"><td class="memTemplParams" colspan="2"><a id="a5b1253d9932f52481b43b325338f5f37"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b1253d9932f52481b43b325338f5f37"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cross_product</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;) noexcept</td></tr>
<tr class="separator:a5b1253d9932f52481b43b325338f5f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb1c275475cdc149dbfd54af468c885"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbb1c275475cdc149dbfd54af468c885"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#acbb1c275475cdc149dbfd54af468c885">find_perpendicular_vector</a> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;, const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;) noexcept</td></tr>
<tr class="separator:acbb1c275475cdc149dbfd54af468c885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9520961dd0ea8c4252f944b826474298"><td class="memTemplParams" colspan="2">template&lt;unsigned short I, unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a9520961dd0ea8c4252f944b826474298"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a9520961dd0ea8c4252f944b826474298">slice</a> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;) noexcept</td></tr>
<tr class="memdesc:a9520961dd0ea8c4252f944b826474298"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a slice from a tiny vector  <a href="namespacetfel_1_1math.html#a9520961dd0ea8c4252f944b826474298">More...</a><br /></td></tr>
<tr class="separator:a9520961dd0ea8c4252f944b826474298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20b4e53906f43f7b4b66d5ec7c788ac"><td class="memTemplParams" colspan="2">template&lt;unsigned short I, unsigned short J, unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:ab20b4e53906f43f7b4b66d5ec7c788ac"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab20b4e53906f43f7b4b66d5ec7c788ac">slice</a> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;) noexcept</td></tr>
<tr class="memdesc:ab20b4e53906f43f7b4b66d5ec7c788ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a slice from a tiny vector  <a href="namespacetfel_1_1math.html#ab20b4e53906f43f7b4b66d5ec7c788ac">More...</a><br /></td></tr>
<tr class="separator:ab20b4e53906f43f7b4b66d5ec7c788ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80facbdfa24a55c2c733e091e3c40399"><td class="memTemplParams" colspan="2">template&lt;unsigned short I, unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a80facbdfa24a55c2c733e091e3c40399"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a80facbdfa24a55c2c733e091e3c40399">slice</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;) noexcept</td></tr>
<tr class="memdesc:a80facbdfa24a55c2c733e091e3c40399"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a slice from a tiny vector  <a href="namespacetfel_1_1math.html#a80facbdfa24a55c2c733e091e3c40399">More...</a><br /></td></tr>
<tr class="separator:a80facbdfa24a55c2c733e091e3c40399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6944194fdfaeb9bb457af4aec059d1"><td class="memTemplParams" colspan="2">template&lt;unsigned short I, unsigned short J, unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:aef6944194fdfaeb9bb457af4aec059d1"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aef6944194fdfaeb9bb457af4aec059d1">slice</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;) noexcept</td></tr>
<tr class="memdesc:aef6944194fdfaeb9bb457af4aec059d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a slice from a tiny vector (const version)  <a href="namespacetfel_1_1math.html#aef6944194fdfaeb9bb457af4aec059d1">More...</a><br /></td></tr>
<tr class="separator:aef6944194fdfaeb9bb457af4aec059d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639280d1be1af9a9c3b9a40b3679fb38"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, unsigned short N, typename ValueType &gt; </td></tr>
<tr class="memitem:a639280d1be1af9a9c3b9a40b3679fb38"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE std::tuple_element_t&lt; i, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, ValueType &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a639280d1be1af9a9c3b9a40b3679fb38">get</a> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, ValueType &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:a639280d1be1af9a9c3b9a40b3679fb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <code>std::get</code> for <code><a class="el" href="structtfel_1_1math_1_1tvector.html" title="a class representing tiny vectors of fixed size.">tfel::math::tvector</a></code>  <a href="namespacetfel_1_1math.html#a639280d1be1af9a9c3b9a40b3679fb38">More...</a><br /></td></tr>
<tr class="separator:a639280d1be1af9a9c3b9a40b3679fb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54e3abc2f8d8b0fdea29c5bd00dce7f"><td class="memTemplParams" colspan="2">template&lt;std::size_t i, unsigned short N, typename ValueType &gt; </td></tr>
<tr class="memitem:ae54e3abc2f8d8b0fdea29c5bd00dce7f"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE const std::tuple_element_t&lt; i, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, ValueType &gt; &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae54e3abc2f8d8b0fdea29c5bd00dce7f">get</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, ValueType &gt; &amp;v) noexcept</td></tr>
<tr class="memdesc:ae54e3abc2f8d8b0fdea29c5bd00dce7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">partial specialisation of <code>std::get</code> for <code><a class="el" href="structtfel_1_1math_1_1tvector.html" title="a class representing tiny vectors of fixed size.">tfel::math::tvector</a></code>  <a href="namespacetfel_1_1math.html#ae54e3abc2f8d8b0fdea29c5bd00dce7f">More...</a><br /></td></tr>
<tr class="separator:ae54e3abc2f8d8b0fdea29c5bd00dce7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad01d3173166445818429e3129c36e52"><td class="memTemplParams" colspan="2"><a id="aad01d3173166445818429e3129c36e52"></a>
template&lt;typename... T&gt; </td></tr>
<tr class="memitem:aad01d3173166445818429e3129c36e52"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tvector</b> (T &amp;&amp;... t) -&gt; <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; sizeof...(T), std::common_type_t&lt; T... &gt;&gt;</td></tr>
<tr class="separator:aad01d3173166445818429e3129c36e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ae5c814d83e805aaed9163ee9b5ed5"><td class="memTemplParams" colspan="2"><a id="a64ae5c814d83e805aaed9163ee9b5ed5"></a>
template&lt;typename MappedType , typename IndexingPolicyType , unsigned short N&gt; </td></tr>
<tr class="memitem:a64ae5c814d83e805aaed9163ee9b5ed5"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; MappedType &gt;&gt;&gt; &amp;v) noexcept requires((!<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; MappedType &gt;()) &amp;&amp;(IndexingPolicyType</td></tr>
<tr class="separator:a64ae5c814d83e805aaed9163ee9b5ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67443ab3c440543a8eb1803b1ea63c91"><td class="memTemplParams" colspan="2"><a id="a67443ab3c440543a8eb1803b1ea63c91"></a>
template&lt;typename MappedType , typename IndexingPolicyType , unsigned short N&gt; </td></tr>
<tr class="memitem:a67443ab3c440543a8eb1803b1ea63c91"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; MappedType &gt;&gt;&gt; &amp;v) noexcept requires((!<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; MappedType &gt;()) &amp;&amp;(IndexingPolicyType</td></tr>
<tr class="separator:a67443ab3c440543a8eb1803b1ea63c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59bdafc8a25f13bb1574a9cc28e755e"><td class="memTemplParams" colspan="2"><a id="ad59bdafc8a25f13bb1574a9cc28e755e"></a>
template&lt;typename MappedType , unsigned short offset, typename IndexingPolicyType , unsigned short N, typename real &gt; </td></tr>
<tr class="memitem:ad59bdafc8a25f13bb1574a9cc28e755e"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, real &gt; &amp;v) noexcept requires((!std</td></tr>
<tr class="separator:ad59bdafc8a25f13bb1574a9cc28e755e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86ae4c61c06bb7b8bd8f8bbe57d6e1a"><td class="memTemplParams" colspan="2"><a id="aa86ae4c61c06bb7b8bd8f8bbe57d6e1a"></a>
template&lt;typename MappedType , unsigned short offset, typename IndexingPolicyType , unsigned short N, typename real &gt; </td></tr>
<tr class="memitem:aa86ae4c61c06bb7b8bd8f8bbe57d6e1a"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, real &gt; &amp;v) noexcept requires((IndexingPolicyType</td></tr>
<tr class="separator:aa86ae4c61c06bb7b8bd8f8bbe57d6e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77201e7d219c17eb7e11bf78501d780"><td class="memTemplParams" colspan="2"><a id="ac77201e7d219c17eb7e11bf78501d780"></a>
template&lt;unsigned short M, typename MappedType , unsigned short offset, unsigned short stride, unsigned short N&gt; </td></tr>
<tr class="memitem:ac77201e7d219c17eb7e11bf78501d780"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, <a class="el" href="namespacetfel_1_1math.html#afe1e469d35bbeb45d57faa77680c8a4e">ViewsArrayNumericType</a>&lt; MappedType &gt;&gt; &amp;v) noexcept requires(!std</td></tr>
<tr class="separator:ac77201e7d219c17eb7e11bf78501d780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6721f58e0603ed7f22ed03552f2fff"><td class="memTemplParams" colspan="2"><a id="aaf6721f58e0603ed7f22ed03552f2fff"></a>
template&lt;unsigned short M, typename MappedType , unsigned short offset, unsigned short stride, unsigned short N&gt; </td></tr>
<tr class="memitem:aaf6721f58e0603ed7f22ed03552f2fff"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, <a class="el" href="namespacetfel_1_1math.html#afe1e469d35bbeb45d57faa77680c8a4e">ViewsArrayNumericType</a>&lt; MappedType &gt;&gt; &amp;v)</td></tr>
<tr class="separator:aaf6721f58e0603ed7f22ed03552f2fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8170997bd1d8dec188c9438e592ae222"><td class="memTemplParams" colspan="2"><a id="a8170997bd1d8dec188c9438e592ae222"></a>
template&lt;unsigned short N, typename T &gt; </td></tr>
<tr class="memitem:a8170997bd1d8dec188c9438e592ae222"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;, const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;)</td></tr>
<tr class="separator:a8170997bd1d8dec188c9438e592ae222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a12f301f2334113a7c95869d9b92fb7"><td class="memTemplParams" colspan="2"><a id="a5a12f301f2334113a7c95869d9b92fb7"></a>
template&lt;ScalarConcept ValueType&gt; </td></tr>
<tr class="memitem:a5a12f301f2334113a7c95869d9b92fb7"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>norm</b> (const <a class="el" href="structtfel_1_1math_1_1vector.html">vector</a>&lt; ValueType &gt; &amp;vec) noexcept</td></tr>
<tr class="separator:a5a12f301f2334113a7c95869d9b92fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cc70145c4ac0752e4a1a743415c0d0"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a87cc70145c4ac0752e4a1a743415c0d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a87cc70145c4ac0752e4a1a743415c0d0">implementsVectorConcept</a> ()</td></tr>
<tr class="memdesc:a87cc70145c4ac0752e4a1a743415c0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">an helper function which returns if the given type implements the <code>VectorConcept</code>.  <a href="namespacetfel_1_1math.html#a87cc70145c4ac0752e4a1a743415c0d0">More...</a><br /></td></tr>
<tr class="separator:a87cc70145c4ac0752e4a1a743415c0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f01a74283def48311d3b026e87d7cc1"><td class="memTemplParams" colspan="2">template&lt;VectorConcept T1&gt; </td></tr>
<tr class="memitem:a6f01a74283def48311d3b026e87d7cc1"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a6f01a74283def48311d3b026e87d7cc1">norm</a> (const T1 &amp;v) requires(!<a class="el" href="namespacetfel_1_1math.html#ac32a69a130c0d7dfdd5860981401e860">isInvalid</a>&lt; <a class="el" href="namespacetfel_1_1math.html#af36bc9045afd07925b2bfef0a00c27f7">BinaryOperationResult</a>&lt; T1</td></tr>
<tr class="memdesc:a6f01a74283def48311d3b026e87d7cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the euclidian norm of a tvector  <a href="namespacetfel_1_1math.html#a6f01a74283def48311d3b026e87d7cc1">More...</a><br /></td></tr>
<tr class="separator:a6f01a74283def48311d3b026e87d7cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdf42c97874d235642829914abc09db"><td class="memTemplParams" colspan="2">template&lt;ScalarConcept T&gt; </td></tr>
<tr class="memitem:aefdf42c97874d235642829914abc09db"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aefdf42c97874d235642829914abc09db">norm</a> (const <a class="el" href="structtfel_1_1math_1_1vector.html">vector</a>&lt; T &gt; &amp;) noexcept</td></tr>
<tr class="separator:aefdf42c97874d235642829914abc09db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5fd3599f56864f41c155ebe48e4b1adb"><td class="memItemLeft" align="right" valign="top"><a id="a5fd3599f56864f41c155ebe48e4b1adb"></a>
constexpr <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memItemRight" valign="bottom"><b>OpMult</b></td></tr>
<tr class="separator:a5fd3599f56864f41c155ebe48e4b1adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad164223e414ca0700f6a4ee410598f4c"><td class="memTemplParams" colspan="2">template&lt;typename ArrayType &gt; </td></tr>
<tr class="memitem:ad164223e414ca0700f6a4ee410598f4c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ad164223e414ca0700f6a4ee410598f4c">ArrayConcept</a></td></tr>
<tr class="memdesc:ad164223e414ca0700f6a4ee410598f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">definition of the ArrayConcept concept a class matching the array concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_array_tag.html" title="Helper class to characterise arrays.">ArrayTag</a></code> and have access operators.  <a href="namespacetfel_1_1math.html#ad164223e414ca0700f6a4ee410598f4c">More...</a><br /></td></tr>
<tr class="separator:ad164223e414ca0700f6a4ee410598f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f2450a044655f4be28d2f57e24ff7b"><td class="memItemLeft" align="right" valign="top"><a id="aa5f2450a044655f4be28d2f57e24ff7b"></a>
constexpr TFEL_HOST_DEVICE Child&#160;</td><td class="memItemRight" valign="bottom"><b>ArrayPolicy</b></td></tr>
<tr class="separator:aa5f2450a044655f4be28d2f57e24ff7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4218adc35feb44f1b2417d87539f1f"><td class="memItemLeft" align="right" valign="top"><a id="a1a4218adc35feb44f1b2417d87539f1f"></a>
constexpr TFEL_HOST_DEVICE Child N&#160;</td><td class="memItemRight" valign="bottom"><b>ValueType2</b></td></tr>
<tr class="separator:a1a4218adc35feb44f1b2417d87539f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fb420624a71df659d6d8b31c73eb88"><td class="memItemLeft" align="right" valign="top"><a id="a77fb420624a71df659d6d8b31c73eb88"></a>
constexpr TFEL_HOST_DEVICE Child N&#160;</td><td class="memItemRight" valign="bottom"><b>OpDiv</b></td></tr>
<tr class="separator:a77fb420624a71df659d6d8b31c73eb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b67457d0514bf53b732e9c67beb004c"><td class="memTemplParams" colspan="2"><a id="a3b67457d0514bf53b732e9c67beb004c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3b67457d0514bf53b732e9c67beb004c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ScalarConcept</b> = <a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html">tfel::typetraits::IsScalar</a>&lt;std::decay_t&lt;T&gt;&gt;::cond</td></tr>
<tr class="separator:a3b67457d0514bf53b732e9c67beb004c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8d25663e528e0efda821b8ec6decef"><td class="memTemplParams" colspan="2"><a id="adb8d25663e528e0efda821b8ec6decef"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb8d25663e528e0efda821b8ec6decef"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MathObjectConcept</b> = <a class="el" href="structtfel_1_1math_1_1_math_object_traits.html">MathObjectTraits</a>&lt;T&gt;::is_specialized</td></tr>
<tr class="separator:adb8d25663e528e0efda821b8ec6decef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383101542c9ac60f276aa9516e798a5c"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a383101542c9ac60f276aa9516e798a5c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a383101542c9ac60f276aa9516e798a5c">MatrixConcept</a></td></tr>
<tr class="memdesc:a383101542c9ac60f276aa9516e798a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">definition of the MatrixConcept concept a class matching the matrix concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_matrix_tag.html" title="Helper class to characterise matrices.">MatrixTag</a></code> and have access operators.  <a href="namespacetfel_1_1math.html#a383101542c9ac60f276aa9516e798a5c">More...</a><br /></td></tr>
<tr class="separator:a383101542c9ac60f276aa9516e798a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6431b0b5cd1f3c080568fa12d72cb828"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>Power&lt; N, D &gt;</b></td></tr>
<tr class="separator:a6431b0b5cd1f3c080568fa12d72cb828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca06c0ef953bcbf93189fa8513ce243"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeca06c0ef953bcbf93189fa8513ce243"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aeca06c0ef953bcbf93189fa8513ce243">ST2toST2Concept</a></td></tr>
<tr class="memdesc:aeca06c0ef953bcbf93189fa8513ce243"><td class="mdescLeft">&#160;</td><td class="mdescRight">definition of the ST2toST2Concept a class matching the stensor concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_tag.html" title="Helper class to characterise st2tost2.">ST2toST2Tag</a></code> and have access operators.  <a href="namespacetfel_1_1math.html#aeca06c0ef953bcbf93189fa8513ce243">More...</a><br /></td></tr>
<tr class="separator:aeca06c0ef953bcbf93189fa8513ce243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b1ee32a0cd9dce3fb2d1be70b97f62"><td class="memTemplParams" colspan="2">template&lt;ST2toST2Concept ST2toST2Type, ST2toST2Concept ST2toST2Type2, TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:a49b1ee32a0cd9dce3fb2d1be70b97f62"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> computePushForwardDerivative(ST2toST2ResultType &amp;, const TensorType &amp;) noexcept requires(tfel constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a49b1ee32a0cd9dce3fb2d1be70b97f62">push_forward</a> (ST2toST2Type &amp;, const ST2toST2Type2 &amp;, const TensorType &amp;) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; ST2toST2Type &gt;()</td></tr>
<tr class="memdesc:a49b1ee32a0cd9dce3fb2d1be70b97f62"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient, i.e. it computes the derivative of F . S . transpose(F) with respect to S assuming that F is constant  <a href="namespacetfel_1_1math.html#a49b1ee32a0cd9dce3fb2d1be70b97f62">More...</a><br /></td></tr>
<tr class="separator:a49b1ee32a0cd9dce3fb2d1be70b97f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e863c47f92cd44e5188f09efee68b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab2e863c47f92cd44e5188f09efee68b6"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ab2e863c47f92cd44e5188f09efee68b6">ST2toT2Concept</a></td></tr>
<tr class="memdesc:ab2e863c47f92cd44e5188f09efee68b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">definition of the ST2toT2Concept  <a href="namespacetfel_1_1math.html#ab2e863c47f92cd44e5188f09efee68b6">More...</a><br /></td></tr>
<tr class="separator:ab2e863c47f92cd44e5188f09efee68b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3d7bfda9e3039508251235fb30fc56"><td class="memItemLeft" align="right" valign="top"><a id="a6f3d7bfda9e3039508251235fb30fc56"></a>
constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><b>T2</b></td></tr>
<tr class="separator:a6f3d7bfda9e3039508251235fb30fc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5faa7fb4e6dea09c6c50a80d73cfb0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5faa7fb4e6dea09c6c50a80d73cfb0c"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a></td></tr>
<tr class="memdesc:ae5faa7fb4e6dea09c6c50a80d73cfb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">definition of the StensorConcept a class matching the stensor concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_stensor_tag.html" title="Helper class to characterise stensors.">StensorTag</a></code> and have access operators.  <a href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">More...</a><br /></td></tr>
<tr class="separator:ae5faa7fb4e6dea09c6c50a80d73cfb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359e482446b8f5efdbf67c3f7706621b"><td class="memTemplParams" colspan="2">template&lt;StensorConcept StensorType&gt; </td></tr>
<tr class="memitem:a359e482446b8f5efdbf67c3f7706621b"><td class="memTemplItemLeft" align="right" valign="top">TFEL_HOST_DEVICE auto logarithm(const StensorType &amp;, const bool=false) requires(tfel TFEL_HOST_DEVICE auto absolute_value(const StensorType &amp;, const bool=false) requires(tfel TFEL_HOST_DEVICE auto positive_part(const StensorType &amp;, const bool=false) requires(tfel TFEL_HOST_DEVICE auto negative_part(const StensorType &amp;, const bool=false) requires(tfel TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a359e482446b8f5efdbf67c3f7706621b">square</a> (const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;)</td></tr>
<tr class="memdesc:a359e482446b8f5efdbf67c3f7706621b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the logarithm of a symmetric tensor  <a href="namespacetfel_1_1math.html#a359e482446b8f5efdbf67c3f7706621b">More...</a><br /></td></tr>
<tr class="separator:a359e482446b8f5efdbf67c3f7706621b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e6aca4a83fd4f27fb85c9d5811478f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27e6aca4a83fd4f27fb85c9d5811478f"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a27e6aca4a83fd4f27fb85c9d5811478f">T2toST2Concept</a></td></tr>
<tr class="memdesc:a27e6aca4a83fd4f27fb85c9d5811478f"><td class="mdescLeft">&#160;</td><td class="mdescRight">definition of the T2toST2Concept a class matching the stensor concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_tag.html" title="Helper class to characterise t2tost2.">T2toST2Tag</a></code> and have access operators.  <a href="namespacetfel_1_1math.html#a27e6aca4a83fd4f27fb85c9d5811478f">More...</a><br /></td></tr>
<tr class="separator:a27e6aca4a83fd4f27fb85c9d5811478f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6a5c545e9dec23c53c80c017574f3c"><td class="memTemplParams" colspan="2">template&lt;T2toST2Concept T2toST2ResultType, T2toST2Concept T2toST2Type, StensorConcept StensorType, TensorConcept TensorType&gt; </td></tr>
<tr class="memitem:a7d6a5c545e9dec23c53c80c017574f3c"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> computePushForwardDerivativeWithRespectToDeformationGradient(T2toST2ResultType &amp;, const StensorType &amp;, const TensorType &amp;) noexcept requires(tfel constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a7d6a5c545e9dec23c53c80c017574f3c">computeCauchyStressDerivativeFromKirchhoffStressDerivative</a> (T2toST2ResultType &amp;, const T2toST2Type &amp;, const StensorType &amp;, const TensorType &amp;) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; T2toST2ResultType &gt;()</td></tr>
<tr class="memdesc:a7d6a5c545e9dec23c53c80c017574f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient, i.e. it computes the derivative of F . S . transpose(F) with respect to F assuming that S is constant  <a href="namespacetfel_1_1math.html#a7d6a5c545e9dec23c53c80c017574f3c">More...</a><br /></td></tr>
<tr class="separator:a7d6a5c545e9dec23c53c80c017574f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cdbe69ac76f33f811132f6d7ad5ff04"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1cdbe69ac76f33f811132f6d7ad5ff04"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1cdbe69ac76f33f811132f6d7ad5ff04">T2toT2Concept</a></td></tr>
<tr class="memdesc:a1cdbe69ac76f33f811132f6d7ad5ff04"><td class="mdescLeft">&#160;</td><td class="mdescRight">definition of the T2toT2Concept  <a href="namespacetfel_1_1math.html#a1cdbe69ac76f33f811132f6d7ad5ff04">More...</a><br /></td></tr>
<tr class="separator:a1cdbe69ac76f33f811132f6d7ad5ff04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a145427c716c04c1fa4fbfacf43a80"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3a145427c716c04c1fa4fbfacf43a80"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a></td></tr>
<tr class="memdesc:aa3a145427c716c04c1fa4fbfacf43a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">definition of the StensorConcept a class matching the stensor concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_stensor_tag.html" title="Helper class to characterise stensors.">StensorTag</a></code> and have access operators.  <a href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">More...</a><br /></td></tr>
<tr class="separator:aa3a145427c716c04c1fa4fbfacf43a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b2a04be997da00e9b20939d96053ad"><td class="memItemLeft" align="right" valign="top"><a id="aa9b2a04be997da00e9b20939d96053ad"></a>
constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><b>TensorType2</b></td></tr>
<tr class="separator:aa9b2a04be997da00e9b20939d96053ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa539be8131b309e2ced4f8f2b190b0"><td class="memTemplParams" colspan="2">template&lt;unsigned short M, typename MappedType , unsigned short offset = 0u, unsigned short stride = getViewsArrayMinimalStride&lt;MappedType&gt;(), unsigned short N&gt; </td></tr>
<tr class="memitem:a1aa539be8131b309e2ced4f8f2b190b0"><td class="memTemplItemLeft" align="right" valign="top">constexpr TFEL_HOST_DEVICE auto map(<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; MappedType &gt;&gt;&gt; &amp;) noexcept requires((!<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; MappedType &gt;()) &amp;&amp;(IndexingPolicyType constexpr TFEL_HOST_DEVICE auto map(const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; MappedType &gt;&gt;&gt; &amp;) noexcept requires((!<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt; MappedType &gt;()) &amp;&amp;(IndexingPolicyType constexpr TFEL_HOST_DEVICE auto map(<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, real &gt; &amp;) noexcept requires((!std constexpr TFEL_HOST_DEVICE auto map(const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, real &gt; &amp;) noexcept requires((IndexingPolicyType constexpr TFEL_HOST_DEVICE auto map(<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, <a class="el" href="namespacetfel_1_1math.html#afe1e469d35bbeb45d57faa77680c8a4e">ViewsArrayNumericType</a>&lt; MappedType &gt;&gt; &amp;) noexcept requires(!std constexpr TFEL_HOST_DEVICE auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a1aa539be8131b309e2ced4f8f2b190b0">map</a> (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, <a class="el" href="namespacetfel_1_1math.html#afe1e469d35bbeb45d57faa77680c8a4e">ViewsArrayNumericType</a>&lt; MappedType &gt;&gt; &amp;)</td></tr>
<tr class="memdesc:a1aa539be8131b309e2ced4f8f2b190b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a view of a math object from a tiny vector  <a href="namespacetfel_1_1math.html#a1aa539be8131b309e2ced4f8f2b190b0">More...</a><br /></td></tr>
<tr class="separator:a1aa539be8131b309e2ced4f8f2b190b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2573a7378fc579582e8c2c07042efbde"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a2573a7378fc579582e8c2c07042efbde"><td class="memTemplItemLeft" align="right" valign="top">concept&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetfel_1_1math.html#a2573a7378fc579582e8c2c07042efbde">VectorConcept</a></td></tr>
<tr class="memdesc:a2573a7378fc579582e8c2c07042efbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">definition of the VectorConcept concept a class matching the vector concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_vector_tag.html" title="Helper class to characterise vectors.">VectorTag</a></code> and have access operators.  <a href="namespacetfel_1_1math.html#a2573a7378fc579582e8c2c07042efbde">More...</a><br /></td></tr>
<tr class="separator:a2573a7378fc579582e8c2c07042efbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aa7f29a9dfe7b016234ecf0f64ca54"><td class="memItemLeft" align="right" valign="top"><a id="a50aa7f29a9dfe7b016234ecf0f64ca54"></a>
TFEL_HOST_DEVICE auto&#160;</td><td class="memItemRight" valign="bottom"><b>T1</b></td></tr>
<tr class="separator:a50aa7f29a9dfe7b016234ecf0f64ca54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace contains various classes and functions défining mathematical objects and numerical algorithms. </p>
<h1><a class="anchor" id="Tensorial"></a>
Tensorial objects</h1>
<p>The <code>TFEL/Math</code> library provides two classes for second order tensors:</p><ul>
<li>The <code>stensor</code> class which describes <em>symmetric</em> second order tensors.</li>
<li>The <code>tensor</code> class which describes general second order (symmetric and unsymmetric) tensors.</li>
</ul>
<p>Fourth order tensors are linear transformations of second order tensors. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aa416b0f269aa81f1431967a34e32cfb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa416b0f269aa81f1431967a34e32cfb6">&#9670;&nbsp;</a></span>Acceleration</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0, 1, -2, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#aa416b0f269aa81f1431967a34e32cfb6">tfel::math::Acceleration</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Acceleration unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="aa788e6a053ffcfd3383c326608623621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa788e6a053ffcfd3383c326608623621">&#9670;&nbsp;</a></span>Ampere</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0, 0, 0, 1, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#aa788e6a053ffcfd3383c326608623621">tfel::math::Ampere</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Ampere unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a20c377618f94581e9b3f896d98df7cec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20c377618f94581e9b3f896d98df7cec">&#9670;&nbsp;</a></span>Candela</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0, 0, 0, 0, 0, 1, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a20c377618f94581e9b3f896d98df7cec">tfel::math::Candela</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Candela unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a037360e732078b2d8b6bee5f80a0c819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037360e732078b2d8b6bee5f80a0c819">&#9670;&nbsp;</a></span>Complex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">tfel::math::Complex</a> = typedef <a class="el" href="structstd_1_1complex.html">std::complex</a>&lt;ValueType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>an alias <a class="el" href="structstd_1_1complex.html">std::complex</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ValueType,underlying</td><td>type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structstd_1_1complex.html">std::complex</a>. </dd></dl>

</div>
</div>
<a id="a13d90727381ad7dd3c40f65da28d0dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d90727381ad7dd3c40f65da28d0dd7">&#9670;&nbsp;</a></span>ConstST2toST2View</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a13d90727381ad7dd3c40f65da28d0dd7">tfel::math::ConstST2toST2View</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt;<a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>space dimension </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7cd32e2bd3bebecba89520218da81b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd32e2bd3bebecba89520218da81b04">&#9670;&nbsp;</a></span>ConstST2toT2View</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a7cd32e2bd3bebecba89520218da81b04">tfel::math::ConstST2toT2View</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt;<a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>space dimension </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46e78b48e464dd3f9fbc9a266debb220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e78b48e464dd3f9fbc9a266debb220">&#9670;&nbsp;</a></span>ConstStensorView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a46e78b48e464dd3f9fbc9a266debb220">tfel::math::ConstStensorView</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt;<a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>space dimension </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65137e5a4d1faf3bb149a32f75dacd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65137e5a4d1faf3bb149a32f75dacd13">&#9670;&nbsp;</a></span>ConstT2toST2View</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a65137e5a4d1faf3bb149a32f75dacd13">tfel::math::ConstT2toST2View</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt;<a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>space dimension </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee9066340849fcd2c843a24466303e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9066340849fcd2c843a24466303e29">&#9670;&nbsp;</a></span>ConstT2toT2View</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#aee9066340849fcd2c843a24466303e29">tfel::math::ConstT2toT2View</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt;<a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>space dimension </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1ce1aa255cf403472e8322e818498ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ce1aa255cf403472e8322e818498ac">&#9670;&nbsp;</a></span>ConstTensorView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#aa1ce1aa255cf403472e8322e818498ac">tfel::math::ConstTensorView</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt;<a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>space dimension </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac621530311d1973cea9f57df51dc5f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac621530311d1973cea9f57df51dc5f90">&#9670;&nbsp;</a></span>ConstTMatrixView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, unsigned short M, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#ac621530311d1973cea9f57df51dc5f90">tfel::math::ConstTMatrixView</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt;<a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt;N, M, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>number of rows </td></tr>
    <tr><td class="paramname">M</td><td>number of columns </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d41659e1167f77d7b5f9d9774158ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d41659e1167f77d7b5f9d9774158ee9">&#9670;&nbsp;</a></span>ConstTVectorView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a0d41659e1167f77d7b5f9d9774158ee9">tfel::math::ConstTVectorView</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">ConstView</a>&lt;<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>number of values </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4899498fd64cfacfc0f16c2ac5ca545c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4899498fd64cfacfc0f16c2ac5ca545c">&#9670;&nbsp;</a></span>Density</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1, -3, 0, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a4899498fd64cfacfc0f16c2ac5ca545c">tfel::math::Density</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Density unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a8a8691d8234e536cdd0d357a2bc5d10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a8691d8234e536cdd0d357a2bc5d10c">&#9670;&nbsp;</a></span>derivative_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionType , typename... VariableTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a8a8691d8234e536cdd0d357a2bc5d10c">tfel::math::derivative_type</a> = typedef typename <a class="el" href="structtfel_1_1math_1_1_derivative_type_meta_function.html">DerivativeTypeMetaFunction</a>&lt;FunctionType, VariableTypes...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias giving the type representing the derivative of an object of type <code>FunctionType</code> with respect to objects of the type given by the template argument pack <code>VariableTypes</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">FunctionType</td><td>function type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">VariableTypes</td><td>variable types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01ca08095dda1754ec1294f599a9e042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ca08095dda1754ec1294f599a9e042">&#9670;&nbsp;</a></span>derivative_view_from_tiny_matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short M, typename FunctionType , typename VariableType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a01ca08095dda1754ec1294f599a9e042">tfel::math::derivative_view_from_tiny_matrix</a> = typedef typename tfel::math::internals:: BuildDerivativeViewFromTinyMatrix&lt;M, FunctionType, VariableType&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias to a view type on a derivative in tiny matrix of M columns. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>number of columns of the matrix. </td></tr>
    <tr><td class="paramname">FunctionType</td><td>function type. </td></tr>
    <tr><td class="paramname">VariableType</td><td>variable type.</td></tr>
  </table>
  </dd>
</dl>
<p>a simple alias </p>

</div>
</div>
<a id="ab352b475ea35e1dd9c987bfc53b9f5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab352b475ea35e1dd9c987bfc53b9f5b8">&#9670;&nbsp;</a></span>Energy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1, 2, -2, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#ab352b475ea35e1dd9c987bfc53b9f5b8">tfel::math::Energy</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Energy unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a479db7d0cfb4a65822b9b9838cc64f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a479db7d0cfb4a65822b9b9838cc64f81">&#9670;&nbsp;</a></span>EnergyDensity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1, -1, -2, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a479db7d0cfb4a65822b9b9838cc64f81">tfel::math::EnergyDensity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the EnergyDensity unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a8de9a5807f32274781605d88cbb90ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de9a5807f32274781605d88cbb90ecc">&#9670;&nbsp;</a></span>Force</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1, 1, -2, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a8de9a5807f32274781605d88cbb90ecc">tfel::math::Force</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Momentum unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="af313c4c99c0c972905f4ea4664d37d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af313c4c99c0c972905f4ea4664d37d7a">&#9670;&nbsp;</a></span>Frequency</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0, 0, -1, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#af313c4c99c0c972905f4ea4664d37d7a">tfel::math::Frequency</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Frequency unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a8956b31691945e6ad86c9b35a9cc9449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8956b31691945e6ad86c9b35a9cc9449">&#9670;&nbsp;</a></span>InvLength</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0, -1, 0, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a8956b31691945e6ad86c9b35a9cc9449">tfel::math::InvLength</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the InvLength unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a1f942447bae7c61931c33048337111cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f942447bae7c61931c33048337111cf">&#9670;&nbsp;</a></span>InvTemperature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0, 0, 0, 0, -1, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a1f942447bae7c61931c33048337111cf">tfel::math::InvTemperature</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the InvTemperature unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="af9e302646eb52f224860ed116b2d2460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9e302646eb52f224860ed116b2d2460">&#9670;&nbsp;</a></span>Kelvin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0, 0, 0, 0, 1, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#af9e302646eb52f224860ed116b2d2460">tfel::math::Kelvin</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Kelvin unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a3a2b52b863e01ed4c1e86a87c5e42633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2b52b863e01ed4c1e86a87c5e42633">&#9670;&nbsp;</a></span>Length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0, 1, 0, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a3a2b52b863e01ed4c1e86a87c5e42633">tfel::math::Length</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Length unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a7cd56523febfd59ddb740d38a686a4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd56523febfd59ddb740d38a686a4a8">&#9670;&nbsp;</a></span>Mass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1, 0, 0, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a7cd56523febfd59ddb740d38a686a4a8">tfel::math::Mass</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Mass unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a1b083381360ba74dcdef115ee9802b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b083381360ba74dcdef115ee9802b16">&#9670;&nbsp;</a></span>Mole</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0, 0, 0, 0, 0, 0, 1&gt;::type <a class="el" href="namespacetfel_1_1math.html#a1b083381360ba74dcdef115ee9802b16">tfel::math::Mole</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Mole unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="af6ada2a52f9c1af346d8b736ade08e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6ada2a52f9c1af346d8b736ade08e2d">&#9670;&nbsp;</a></span>Momentum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1, 1, -1, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#af6ada2a52f9c1af346d8b736ade08e2d">tfel::math::Momentum</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Momentum unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="ab60129cc8e9010447033707d46d41816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60129cc8e9010447033707d46d41816">&#9670;&nbsp;</a></span>Newton</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1, 1, -2, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#ab60129cc8e9010447033707d46d41816">tfel::math::Newton</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Newton unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a7681121858bfa43509d51b045e59004a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7681121858bfa43509d51b045e59004a">&#9670;&nbsp;</a></span>Pressure</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1, -1, -2, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a7681121858bfa43509d51b045e59004a">tfel::math::Pressure</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Pressure unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a098b63954160182ad3703acebc91eded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098b63954160182ad3703acebc91eded">&#9670;&nbsp;</a></span>Speed</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0, 1, -1, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a098b63954160182ad3703acebc91eded">tfel::math::Speed</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Speed unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a45ae7aa43dae3d234a33b4b03be38a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ae7aa43dae3d234a33b4b03be38a88">&#9670;&nbsp;</a></span>ST2toST2View</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a45ae7aa43dae3d234a33b4b03be38a88">tfel::math::ST2toST2View</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt;<a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>space dimension </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8afdd1bf012f99cec4f4c4b1813e10d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afdd1bf012f99cec4f4c4b1813e10d4">&#9670;&nbsp;</a></span>ST2toT2View</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a8afdd1bf012f99cec4f4c4b1813e10d4">tfel::math::ST2toT2View</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt;<a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>space dimension </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bb4470bb96bdbf94c7ef5c2fbef6050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb4470bb96bdbf94c7ef5c2fbef6050">&#9670;&nbsp;</a></span>StensorView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a6bb4470bb96bdbf94c7ef5c2fbef6050">tfel::math::StensorView</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt;<a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>space dimension </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aafa2a425a67055d9bd9f3698ccb36f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa2a425a67055d9bd9f3698ccb36f80">&#9670;&nbsp;</a></span>Stress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1, -1, -2, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#aafa2a425a67055d9bd9f3698ccb36f80">tfel::math::Stress</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Stress unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="ab41bb413e30c83ae508ba80aedb1278c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41bb413e30c83ae508ba80aedb1278c">&#9670;&nbsp;</a></span>StressRate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;1, -1, -3, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#ab41bb413e30c83ae508ba80aedb1278c">tfel::math::StressRate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the StressRate unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a7f02c3b952ac9d506fd9e7679beaa054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f02c3b952ac9d506fd9e7679beaa054">&#9670;&nbsp;</a></span>T2toST2View</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a7f02c3b952ac9d506fd9e7679beaa054">tfel::math::T2toST2View</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt;<a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>space dimension </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9206e7674fc5908164cf22cd9fb4e5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9206e7674fc5908164cf22cd9fb4e5fc">&#9670;&nbsp;</a></span>T2toT2View</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a9206e7674fc5908164cf22cd9fb4e5fc">tfel::math::T2toT2View</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt;<a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>space dimension </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11dca8ad371d67538aeb06fcb76d052a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dca8ad371d67538aeb06fcb76d052a">&#9670;&nbsp;</a></span>Temperature</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0, 0, 0, 0, 1, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a11dca8ad371d67538aeb06fcb76d052a">tfel::math::Temperature</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Temperature unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="ad6cfcd2301de3a90e440082f059b68f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6cfcd2301de3a90e440082f059b68f5">&#9670;&nbsp;</a></span>TensorView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#ad6cfcd2301de3a90e440082f059b68f5">tfel::math::TensorView</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt;<a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>space dimension </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00c743e2591ae63c3e4ee54465ea14aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c743e2591ae63c3e4ee54465ea14aa">&#9670;&nbsp;</a></span>Time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a>&lt;0, 0, 1, 0, 0, 0, 0&gt;::type <a class="el" href="namespacetfel_1_1math.html#a00c743e2591ae63c3e4ee54465ea14aa">tfel::math::Time</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declares the Time unit. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structtfel_1_1math_1_1_generate_unit.html">GenerateUnit</a> </dd></dl>

</div>
</div>
<a id="a51c29e208b8ef2c33c0a187401120ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51c29e208b8ef2c33c0a187401120ff0">&#9670;&nbsp;</a></span>TMatrixView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, unsigned short M, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a51c29e208b8ef2c33c0a187401120ff0">tfel::math::TMatrixView</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt;<a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt;N, M, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>number of rows </td></tr>
    <tr><td class="paramname">M</td><td>number of columns </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19439c10da11eeacfe7af93ddcf6df36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19439c10da11eeacfe7af93ddcf6df36">&#9670;&nbsp;</a></span>TVectorView</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetfel_1_1math.html#a19439c10da11eeacfe7af93ddcf6df36">tfel::math::TVectorView</a> = typedef <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt;<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt;N, T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a simple alias for backward compatibility </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>number of values </td></tr>
    <tr><td class="paramname">T</td><td>value type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aafaebb8e828aea419a069041a08c72af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafaebb8e828aea419a069041a08c72af">&#9670;&nbsp;</a></span>abs() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a037360e732078b2d8b6bee5f80a0c819">Complex</a>&lt; NumericType &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the norm of a complex </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a499519d35b23a2d0a8565c69fcfc0593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499519d35b23a2d0a8565c69fcfc0593">&#9670;&nbsp;</a></span>abs() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::abs </td>
          <td>(</td>
          <td class="paramtype">const NumericType &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the absolute value of a scalar </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad8fbe364d7b6e778d7823d65fc23f434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8fbe364d7b6e778d7823d65fc23f434">&#9670;&nbsp;</a></span>abs() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aeca06c0ef953bcbf93189fa8513ce243">ST2toST2Concept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of the absolute values of all components of an linear application transforming a symmetric tensor in a symmetric tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>linear application transforming a symmetric tensor in a symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a2c458888bd2a446ac852a7b082c8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2c458888bd2a446ac852a7b082c8d9">&#9670;&nbsp;</a></span>abs() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ab2e863c47f92cd44e5188f09efee68b6">ST2toT2Concept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of the absolute values of all components of an linear application transforming a tensor in a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>fourth order tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0436301407b4e819e03b50da3f787d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0436301407b4e819e03b50da3f787d9a">&#9670;&nbsp;</a></span>abs() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of the absolute values of all components of a symmetric tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8ead0ca634dc6b0fb81961391e2d076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ead0ca634dc6b0fb81961391e2d076">&#9670;&nbsp;</a></span>abs() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a27e6aca4a83fd4f27fb85c9d5811478f">T2toST2Concept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of the absolute values of all components of an linear application transforming a symmetric tensor in an unsymmetric tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>linear application transforming a symmetric tensor in an unsymmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae218a6c03a2b01153f65df08d24725a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae218a6c03a2b01153f65df08d24725a5">&#9670;&nbsp;</a></span>abs() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a1cdbe69ac76f33f811132f6d7ad5ff04">T2toT2Concept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of the absolute values of all components of an linear application transforming a tensor in a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>fourth order tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91d941b376105841dfccd3f6831fa616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d941b376105841dfccd3f6831fa616">&#9670;&nbsp;</a></span>abs() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the sum of the absolute value of the components of a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2af6a76863040300a210e557ebd47fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af6a76863040300a210e557ebd47fd9">&#9670;&nbsp;</a></span>applyPowellDogLegAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename NumericType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::applyPowellDogLegAlgorithm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, NumericType &gt; &amp;&#160;</td>
          <td class="paramname"><em>delta_zeros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, NumericType &gt; &amp;&#160;</td>
          <td class="paramname"><em>jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, NumericType &gt; &amp;&#160;</td>
          <td class="paramname"><em>fzeros</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NumericType&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>apply Powell' dog leg algorithm </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>size of the system of non linear equations </td></tr>
    <tr><td class="paramname">NumericType</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">delta_zeros</td><td>current correction to the solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">jacobian</td><td>current estimate of the jacobian matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fzeros</td><td>current residual </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">radius</td><td>trust region size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f62f75674bfb14650e599b39b242ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f62f75674bfb14650e599b39b242ee1">&#9670;&nbsp;</a></span>areIndexingPoliciesCompatibleAtRunTime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::areIndexingPoliciesCompatibleAtRunTime </td>
          <td>(</td>
          <td class="paramtype">const IndexingPolicy1 &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexingPolicy2 &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if two indexing policies are compatible at runtime. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy1</td><td>first indexing policy </td></tr>
    <tr><td class="paramname">IndexingPolicy2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>first indexing policy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function is a simple wrapper around <code>IndexingPoliciesCompatiblityCheck::runtimeTimeCheck</code>. </dd></dl>

</div>
</div>
<a id="a0f2a5bfed11bc018f14af36d6bfdd82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2a5bfed11bc018f14af36d6bfdd82b">&#9670;&nbsp;</a></span>areIndexingPoliciesCompatibleAtRunTime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::areIndexingPoliciesCompatibleAtRunTime </td>
          <td>(</td>
          <td class="paramtype">const IndexingPolicy1 &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexingPolicy2 &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if two indexing policies are compatible at runtime. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy1</td><td>first indexing policy </td></tr>
    <tr><td class="paramname">IndexingPolicy2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>first indexing policy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function is a simple wrapper around <code>IndexingPoliciesCompatiblityCheck::runtimeTimeCheck</code>. </dd></dl>

</div>
</div>
<a id="a380c8452ec4b01ff8ed3096ae8e229a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380c8452ec4b01ff8ed3096ae8e229a4">&#9670;&nbsp;</a></span>broyden() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt; tfel::math::broyden </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root of a function using the first Broyden algorithm. The jacobian is initially approximated by the identity matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>: size of the unknown </td></tr>
    <tr><td class="paramname">T</td><td>: numerical type </td></tr>
    <tr><td class="paramname">f</td><td>: function which root is sought after </td></tr>
    <tr><td class="paramname">x0</td><td>: initial guess </td></tr>
    <tr><td class="paramname">e</td><td>: convergence criterium </td></tr>
    <tr><td class="paramname">n</td><td>: maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair whose first member is true is the algorithm converged and whose second member contains the solution </dd></dl>

</div>
</div>
<a id="aa578f04d6447731cf0f1172b63b81d71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa578f04d6447731cf0f1172b63b81d71">&#9670;&nbsp;</a></span>broyden() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt; tfel::math::broyden </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root of a function using the first Broyden algorithm</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>: size of the unknown </td></tr>
    <tr><td class="paramname">T</td><td>: numerical type </td></tr>
    <tr><td class="paramname">f</td><td>: function which root is sought after </td></tr>
    <tr><td class="paramname">x0</td><td>: initial guess </td></tr>
    <tr><td class="paramname">A</td><td>: initial approximation of the jacobian </td></tr>
    <tr><td class="paramname">e</td><td>: convergence criterium </td></tr>
    <tr><td class="paramname">n</td><td>: maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair whose first member is true is the algorithm converged and whose second member contains the solution </dd></dl>

</div>
</div>
<a id="a0955c3da239e6c30ad743a8d5f320e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0955c3da239e6c30ad743a8d5f320e10">&#9670;&nbsp;</a></span>broyden2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt; tfel::math::broyden2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root of a function using the first Broyden algorithm. The jacobian is initially approximated by the identity matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>: size of the unknown </td></tr>
    <tr><td class="paramname">T</td><td>: numerical type </td></tr>
    <tr><td class="paramname">f</td><td>: function which root is sought after </td></tr>
    <tr><td class="paramname">x0</td><td>: initial guess </td></tr>
    <tr><td class="paramname">e</td><td>: convergence criterium </td></tr>
    <tr><td class="paramname">n</td><td>: maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair whose first member is true is the algorithm converged and whose second member contains the solution </dd></dl>

</div>
</div>
<a id="ab96bcf9320cc0ea1527878c464eaa1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96bcf9320cc0ea1527878c464eaa1e8">&#9670;&nbsp;</a></span>broyden2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , const tvector&lt; N, T &gt;(*)(const tvector&lt; N, T &gt; &amp;) f&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; bool, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &gt; tfel::math::broyden2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>iJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the root of a function using the second Broyden algorithm</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>: size of the unknown </td></tr>
    <tr><td class="paramname">T</td><td>: numerical type </td></tr>
    <tr><td class="paramname">f</td><td>: function which root is sought after </td></tr>
    <tr><td class="paramname">x0</td><td>: initial guess </td></tr>
    <tr><td class="paramname">A</td><td>: initial approximation of the jacobian </td></tr>
    <tr><td class="paramname">e</td><td>: convergence criterium </td></tr>
    <tr><td class="paramname">n</td><td>: maximum number of iterations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair whose first member is true is the algorithm converged and whose second member contains the solution </dd></dl>

</div>
</div>
<a id="ae3c641ff58638cd335232b08de8a9794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c641ff58638cd335232b08de8a9794">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ST2toST2Concept ST2toST2Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const ST2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; ST2toST2Type &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>change the basis of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>: rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaac56303ac7b6183f9a1ced0f9fce112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac56303ac7b6183f9a1ced0f9fce112">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StensorConcept StensorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; StensorType &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>rotate a symmetric tensor using a rotation matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor to be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated symmetric tensor </dd></dl>

</div>
</div>
<a id="a52adc5b5d15ad84afb2cb0e119848186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52adc5b5d15ad84afb2cb0e119848186">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;T2toST2Concept T2toST2Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; T2toST2Type &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>change the basis of a <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td><a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa9f9097d3b6f624dc6b7656f5e48b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9f9097d3b6f624dc6b7656f5e48b95">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;T2toT2Concept T2toT2Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const T2toT2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; T2toT2Type &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>change the basis of a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>: rotation matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add8a111e7d18f010b629a418f1701016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8a111e7d18f010b629a418f1701016">&#9670;&nbsp;</a></span>change_basis() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TensorConcept TensorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::change_basis </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a373af1865a931dd29d7ff54ed4ea7b86">rotation_matrix</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; TensorType &gt;&gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>rotate a tensor using a rotation matrix </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor to be rotated </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r</td><td>rotation matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rotated tensor </dd></dl>

</div>
</div>
<a id="a88b14ccb6f9ba60d621b977572293ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b14ccb6f9ba60d621b977572293ad9">&#9670;&nbsp;</a></span>checkIndexingPoliciesCompatiblity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::checkIndexingPoliciesCompatiblity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if two indexing policies can be compatible. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy1</td><td>first indexing policy </td></tr>
    <tr><td class="paramname">IndexingPolicy2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function is a simple wrapper around <code>IndexingPoliciesCompatiblityCheck::checkIndexingPoliciesCompatiblity</code>. </dd></dl>

</div>
</div>
<a id="a331c0a1318f53ec008ca94d6576d179a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331c0a1318f53ec008ca94d6576d179a">&#9670;&nbsp;</a></span>checkIndexingPoliciesCompatiblity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::checkIndexingPoliciesCompatiblity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if two indexing policies can be compatible. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy1</td><td>first indexing policy </td></tr>
    <tr><td class="paramname">IndexingPolicy2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function is a simple wrapper around <code>IndexingPoliciesCompatiblityCheck::checkIndexingPoliciesCompatiblity</code>. </dd></dl>

</div>
</div>
<a id="ac6a1978aaac3db5b83d137766c816e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a1978aaac3db5b83d137766c816e17">&#9670;&nbsp;</a></span>checkIndexingPoliciesRuntimeCompatiblity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::checkIndexingPoliciesRuntimeCompatiblity </td>
          <td>(</td>
          <td class="paramtype">const IndexingPolicy1 &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexingPolicy2 &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if two indexing policies are compatible at runtime. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy1</td><td>first indexing policy </td></tr>
    <tr><td class="paramname">IndexingPolicy2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>first indexing policy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function simply calls <code>areIndexingPoliciesCompatibleAtRunTime</code> and reports a contract violation if the two indexing policies are not compatible. </dd></dl>

</div>
</div>
<a id="ada78dd532490845171f78ffb4aa07641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada78dd532490845171f78ffb4aa07641">&#9670;&nbsp;</a></span>checkIndexingPoliciesRuntimeCompatiblity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::checkIndexingPoliciesRuntimeCompatiblity </td>
          <td>(</td>
          <td class="paramtype">const IndexingPolicy1 &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexingPolicy2 &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if two indexing policies are compatible at runtime. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy1</td><td>first indexing policy </td></tr>
    <tr><td class="paramname">IndexingPolicy2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p1</td><td>first indexing policy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function simply calls <code>areIndexingPoliciesCompatibleAtRunTime</code> and reports a contract violation if the two indexing policies are not compatible. </dd></dl>

</div>
</div>
<a id="aae467b6055157e814590865cd45c95d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae467b6055157e814590865cd45c95d4">&#9670;&nbsp;</a></span>checkIndicesValiditity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy , typename... Indices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::checkIndicesValiditity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a simple function to check that the type of the indices are compatible with the given indexing policy </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy</td><td>the indexing policy </td></tr>
    <tr><td class="paramname">Indices</td><td>list of indices types </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad76bbb1f302a9689d4e3d3ca700d5b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76bbb1f302a9689d4e3d3ca700d5b1f">&#9670;&nbsp;</a></span>computeCauchyStressDerivativeFromKirchhoffStressDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;T2toST2Concept T2toST2Type, StensorConcept StensorType, TensorConcept TensorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeCauchyStressDerivativeFromKirchhoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the Cauchy stress derivative from the Kirchhoff stress derivative </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Kirchhoff stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8a6bf76a5c223f4b3d832d7cbb19840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a6bf76a5c223f4b3d832d7cbb19840">&#9670;&nbsp;</a></span>computeCubicSplineInterpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool extrapolate, typename CollocationPointContainer , typename AbscissaType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tfel::math::computeCubicSplineInterpolation </td>
          <td>(</td>
          <td class="paramtype">const CollocationPointContainer &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AbscissaType&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the interpolation of a set of collocation points at the given abscissa </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>collocation points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>abscissa</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">extrapolate</td><td>boolean stating if extrapolation must be performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the points are assumed ordered from lower to greater values. </dd></dl>

</div>
</div>
<a id="a2ec33c3e7b08d2989259a952cb0f588f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec33c3e7b08d2989259a952cb0f588f">&#9670;&nbsp;</a></span>computeCubicSplineInterpolationAndDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool extrapolate, typename CollocationPointContainer , typename AbscissaType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tfel::math::computeCubicSplineInterpolationAndDerivative </td>
          <td>(</td>
          <td class="paramtype">const CollocationPointContainer &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AbscissaType&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the interpolation of a set of collocation points at the given abscissa and the derivative at this point </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">points</td><td>collocation points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>abscissa</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">extrapolate</td><td>boolean stating if extrapolation must be performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the points are assumed ordered from lower to greater values. </dd></dl>

</div>
</div>
<a id="ad67f1e089683fb6b07ecf0e45000f789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67f1e089683fb6b07ecf0e45000f789">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of the determinant </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor where the the determinant is evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae29c553e64c6bcc1d941b87194f6014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae29c553e64c6bcc1d941b87194f6014">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of the determinant </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>tensor where the the determinant is evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43c3072beed6e2460e43b95e1d5083e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c3072beed6e2460e43b95e1d5083e8">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dJ</td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f9fc0413cf4f8d060c46fb7324ac9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9fc0413cf4f8d060c46fb7324ac9af">&#9670;&nbsp;</a></span>computeDeterminantDerivative() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a612abc3b346374aec5b63a3e05d2e813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612abc3b346374aec5b63a3e05d2e813">&#9670;&nbsp;</a></span>computeDeterminantSecondDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeDeterminantSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the second derivative of determinant of a </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3d56ca42c3cdec6ec331092b5855391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d56ca42c3cdec6ec331092b5855391">&#9670;&nbsp;</a></span>computeDeterminantSecondDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TensorConcept TensorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeDeterminantSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the second derivative of the determinant of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab5fa16778a618c30ec0ed5747d78c3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5fa16778a618c30ec0ed5747d78c3ff">&#9670;&nbsp;</a></span>computeDeviatorDeterminantDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeDeviatorDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of the determinant of the deviator of symmetric tensor.</dd></dl>
<p>Let \(\underline{s}\) be a symmetric tensor and \(J_{3}\) be the determinant of \(\underline{s}&#39;\) the deviator of \(\underline{s}\): </p><p class="formulaDsp">
\[ J_{3} = \mathrm{det}\left(\underline{s}&#39;\right) = \mathrm{det}\left(\underline{s}-\mathrm{tr}\left(\underline{s}&#39;\right)\,\underline{I}\right) \]
</p>
<p>This function computes \(\displaystyle\frac{\partial J_{3}}{\partial \underline{\sigma}}\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor where the the determinant is evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1203310979fbcc00e858e93186649548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1203310979fbcc00e858e93186649548">&#9670;&nbsp;</a></span>computeDeviatorDeterminantDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeDeviatorDeterminantDerivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>dJ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the derivative of the determinant with respect to its argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dJ</td><td>determinant derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e9e0a501fb2115a37992f395c2e76ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9e0a501fb2115a37992f395c2e76ad">&#9670;&nbsp;</a></span>computeDeviatorDeterminantSecondDerivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeDeviatorDeterminantSecondDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the second derivative of the determinant of the deviator of symmetric tensor. </p>
<p>Let \(\underline{s}\) be a symmetric tensor and \(J_{3}\) be the determinant of \(\underline{s}&#39;\) the deviator of \(\underline{s}\): </p><p class="formulaDsp">
\[ J_{3} = \mathrm{det}\left(\underline{s}&#39;\right) = \mathrm{det}\left(\underline{s}-\mathrm{tr}\left(\underline{s}&#39;\right)\,\underline{I}\right) \]
</p>
<p>This function computes \(\displaystyle\frac{\partial^{2} J_{3}}{\partial \underline{\sigma}^{2}}\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae62dd946d8c03830d57f9f1dbe37cba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62dd946d8c03830d57f9f1dbe37cba1">&#9670;&nbsp;</a></span>computeGreenLagrangeTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeGreenLagrangeTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the left Green-Lagrange tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00e88c5dd0f3ecceb418c4d8e3d7491f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00e88c5dd0f3ecceb418c4d8e3d7491f">&#9670;&nbsp;</a></span>computeIsotropicFunction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename stensor_common::EigenSolver  = stensor_common::TFELEIGENSOLVER, typename Function , StensorConcept StensorType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE auto tfel::math::computeIsotropicFunction </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the value of an isotropic function </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82cf2c8e7c4c1248681a6574d1542f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82cf2c8e7c4c1248681a6574d1542f7c">&#9670;&nbsp;</a></span>computeIsotropicFunctionAndDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename stensor_common::EigenSolver  = stensor_common::TFELEIGENSOLVER, typename Function , typename FunctionDerivative , StensorConcept StensorType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE auto tfel::math::computeIsotropicFunctionAndDerivative </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctionDerivative &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the value and the derivative of an isotropic function </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">df</td><td>derivative of the function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>criterion value used to judge if two eigenvalues are equals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fe0609ad5a1c58be6199897773392d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fe0609ad5a1c58be6199897773392d2">&#9670;&nbsp;</a></span>computeIsotropicFunctionDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename stensor_common::EigenSolver  = stensor_common::TFELEIGENSOLVER, typename Function , typename FunctionDerivative , StensorConcept StensorType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE auto tfel::math::computeIsotropicFunctionDerivative </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FunctionDerivative &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of an isotropic function </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">df</td><td>derivative of the function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>criterion value used to judge if two eigenvalues are equals </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>if true, refinement of eigen values is performed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af451306a6dd1a530f0ceb57d4847b4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af451306a6dd1a530f0ceb57d4847b4a2">&#9670;&nbsp;</a></span>computeKirchhoffStressDerivativeFromCauchyStressDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;T2toST2Concept T2toST2Type, StensorConcept StensorType, TensorConcept TensorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeKirchhoffStressDerivativeFromCauchyStressDerivative </td>
          <td>(</td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the Cauchy stress derivative from the Kirchhoff stress derivative </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dt</td><td>Kirchhoff stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99ebf12208afcb4a3e7887f84b5e3a9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ebf12208afcb4a3e7887f84b5e3a9b">&#9670;&nbsp;</a></span>computeKirchhoffStressDerivativeFromCauchyStressDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;T2toST2Concept T2toST2ResultType, T2toST2Concept T2toST2Type, StensorConcept StensorType, TensorConcept TensorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::computeKirchhoffStressDerivativeFromCauchyStressDerivative </td>
          <td>(</td>
          <td class="paramtype">T2toST2ResultType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the Kirchhoff stress derivative from the Cauchy stress derivative with respect to the deformation gradient </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dt_K</td><td>: Kirchhoff stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>: Cauchy stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a229ac783dcc1fe8ccb33e1f0863d25c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229ac783dcc1fe8ccb33e1f0863d25c4">&#9670;&nbsp;</a></span>computeLeftCauchyGreenTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeLeftCauchyGreenTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the left Cauchy-Green tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69bca031867ff6567faaa6009ebb6d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69bca031867ff6567faaa6009ebb6d17">&#9670;&nbsp;</a></span>computeLinearInterpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool extrapolate, typename AbscissaContainer , typename ValueContainer , typename AbscissaType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tfel::math::computeLinearInterpolation </td>
          <td>(</td>
          <td class="paramtype">const AbscissaContainer &amp;&#160;</td>
          <td class="paramname"><em>abscissae</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueContainer &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AbscissaType&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute a linear interpolation based on the given abscissae and values </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">abscissae</td><td>container containing the abscissae </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>container containing the values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>point where the interpolation is computed</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">extrapolate</td><td>boolean stating if extrapolation must be performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the abscissae are assumed ordered from lower to greater values. </dd></dl>

</div>
</div>
<a id="a5d12e566c669ea3d38ed9f0c5a90d869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d12e566c669ea3d38ed9f0c5a90d869">&#9670;&nbsp;</a></span>computeLinearInterpolationAndDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool extrapolate, typename AbscissaContainer , typename ValueContainer , typename AbscissaType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tfel::math::computeLinearInterpolationAndDerivative </td>
          <td>(</td>
          <td class="paramtype">const AbscissaContainer &amp;&#160;</td>
          <td class="paramname"><em>abscissae</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueContainer &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AbscissaType&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute a linear interpolation based on the given abscissae and values and the associated derivative </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">abscissae</td><td>container containing the abscissae </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>container containing the values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>point where the interpolation is computed</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">extrapolate</td><td>boolean stating if extrapolation must be performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the abscissae are assumed ordered from lower to greater values. </dd></dl>

</div>
</div>
<a id="a9ce5052f3be1ed8aafc46864ee173477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce5052f3be1ed8aafc46864ee173477">&#9670;&nbsp;</a></span>computeNumericalDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionType , typename VariableType , typename ScalarType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetfel_1_1math.html#a8a8691d8234e536cdd0d357a2bc5d10c">derivative_type</a>&lt; std::invoke_result_t&lt; FunctionType, VariableType &gt;, VariableType &gt; tfel::math::computeNumericalDerivative </td>
          <td>(</td>
          <td class="paramtype">const FunctionType &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VariableType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ScalarType &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute a numerical approximation of the derivative a a function with respect to a variable with a centered finite difference scheme. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctionType</td><td>type of the function to be differentiated. </td></tr>
    <tr><td class="paramname">VariableType</td><td>type of the variable. </td></tr>
    <tr><td class="paramname">ScalarType</td><td>type of the perturbation value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>variable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>perturbation value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a59781abd3146ca9f755d9cd3e9a33e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59781abd3146ca9f755d9cd3e9a33e93">&#9670;&nbsp;</a></span>computePushForwardDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;T2toST2Concept T2toST2Type, StensorConcept StensorType, TensorConcept TensorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computePushForwardDerivative </td>
          <td>(</td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient knowing the value of this derivative in the initial configuration.</dd></dl>
<p>This function is typically used to compute the derivative of the Kirchhoff stress tensor knowing the derivative of the second Piola-Kirschoff stress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>derivative of the orginal tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>orginal tensor (second Piola-Kirschoff stress) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a5737b11fa1415778870a498a33d3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5737b11fa1415778870a498a33d3ca">&#9670;&nbsp;</a></span>computeRateOfDeformationDerivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeRateOfDeformationDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the "derivative" of the rate of deformation \delta D = dD_dF:\delta F with \delta D = ((delta F).F^{-1}+F^{-T}.(delta F)^{T})/2 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a081cb54ae3c02e1b775ad2d77936fd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a081cb54ae3c02e1b775ad2d77936fd40">&#9670;&nbsp;</a></span>computeRightCauchyGreenTensor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeRightCauchyGreenTensor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the right Cauchy-Green tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dae14680e16598e16b2eb595ab36cbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dae14680e16598e16b2eb595ab36cbf">&#9670;&nbsp;</a></span>computeSpinRateDerivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeSpinRateDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the spin rate </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f7d043020f38214a82327b2f8fe5dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7d043020f38214a82327b2f8fe5dd3">&#9670;&nbsp;</a></span>computeStensorDecompositionInPositiveAndNegativeParts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ST2toST2Concept DPPType, ST2toST2Concept DNPType, StensorConcept PPType, StensorConcept NPType, StensorConcept StensorType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::computeStensorDecompositionInPositiveAndNegativeParts </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DNPType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NPType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">== getSpaceDimension&lt;StensorType&gt;() &amp;&amp;</div>
<div class="line">        getSpaceDimension&lt;DNPType&gt;() == getSpaceDimension&lt;StensorType&gt;() &amp;&amp;</div>
<div class="line">        getSpaceDimension&lt;PPType&gt;() == getSpaceDimension&lt;StensorType&gt;() &amp;&amp;</div>
<div class="line">        getSpaceDimension&lt;NPType&gt;() == getSpaceDimension&lt;StensorType&gt;() &amp;&amp;</div>
<div class="line">        getSpaceDimension&lt;StensorType&gt;() == 2u &amp;&amp;</div>
<div class="line">        isAssignableTo&lt;numeric_type&lt;StensorType&gt;, numeric_type&lt;PPType&gt;&gt;() &amp;&amp;</div>
<div class="line">        <a class="code" href="namespacetfel_1_1math.html#aea2a48b5882876da6707ada2c302f4bd">isAssignableTo</a>&lt;numeric_type&lt;StensorType&gt;, numeric_type&lt;NPType&gt;&gt;() &amp;&amp;</div>
<div class="line">        isAssignableTo&lt;base_type&lt;numeric_type&lt;StensorType&gt;&gt;,</div>
<div class="line">                       numeric_type&lt;DPPType&gt;&gt;() &amp;&amp;</div>
<div class="line">        <a class="code" href="namespacetfel_1_1math.html#aea2a48b5882876da6707ada2c302f4bd">isAssignableTo</a>&lt;<a class="code" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt;numeric_type&lt;StensorType&gt;&gt;,</div>
<div class="line">                       numeric_type&lt;DNPType&gt;&gt;())</div>
<div class="ttc" id="anamespacetfel_1_1math_html_aea2a48b5882876da6707ada2c302f4bd"><div class="ttname"><a href="namespacetfel_1_1math.html#aea2a48b5882876da6707ada2c302f4bd">tfel::math::isAssignableTo</a></div><div class="ttdeci">constexpr TFEL_HOST_DEVICE bool isAssignableTo()</div><div class="ttdoc">an helper function around isAssignableTo</div><div class="ttdef"><b>Definition:</b> MathObjectTraits.hxx:122</div></div>
<div class="ttc" id="anamespacetfel_1_1math_html_aee110500aba43bd0fc73c7a5ecd510e9"><div class="ttname"><a href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">tfel::math::base_type</a></div><div class="ttdeci">std::conditional_t&lt; tfel::typetraits::isScalar&lt; T &gt;(), tfel::typetraits::base_type&lt; T &gt;, tfel::typetraits::base_type&lt; numeric_type&lt; T &gt; &gt;&gt; base_type</div><div class="ttdoc">a simple alias</div><div class="ttdef"><b>Definition:</b> MathObjectTraits.hxx:91</div></div>
</div><!-- fragment -->
<p>compute the decomposition of a symmetric tensor in a positive and negative parts and their derivatives. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">DNPType</td><td>: type in which derivative of the negative part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname">NPType</td><td>: type of negative part of the symmetric tensor </td></tr>
    <tr><td class="paramname">StensorType</td><td>: type of the symmetric tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dnp</td><td>: derivative of the negative part of the symmetric tensor</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">np</td><td>: positive part of the symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the ST2toST2Concept </dd>
<dd>
DNPType must implement the ST2toST2Concept </dd>
<dd>
PPType must implement the StensorConcept </dd>
<dd>
NPType must implement the StensorConcept </dd>
<dd>
StensorType must implement the StensorConcept </dd></dl>

</div>
</div>
<a id="a5880b16eb9457e86078c701264ef3fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5880b16eb9457e86078c701264ef3fc8">&#9670;&nbsp;</a></span>computeStensorPositivePartAndDerivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ST2toST2Concept DPPType, StensorConcept PPType, StensorConcept StensorType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::computeStensorPositivePartAndDerivative </td>
          <td>(</td>
          <td class="paramtype">DPPType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PPType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; StensorType &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">== getSpaceDimension&lt;StensorType&gt;() &amp;&amp;</div>
<div class="line">        getSpaceDimension&lt;PPType&gt;() == getSpaceDimension&lt;StensorType&gt;() &amp;&amp;</div>
<div class="line">        getSpaceDimension&lt;StensorType&gt;() == 2u &amp;&amp;</div>
<div class="line">        isAssignableTo&lt;numeric_type&lt;StensorType&gt;, numeric_type&lt;PPType&gt;&gt;() &amp;&amp;</div>
<div class="line">        <a class="code" href="namespacetfel_1_1math.html#aea2a48b5882876da6707ada2c302f4bd">isAssignableTo</a>&lt;<a class="code" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt;numeric_type&lt;StensorType&gt;&gt;,</div>
<div class="line">                       numeric_type&lt;DPPType&gt;&gt;())</div>
</div><!-- fragment -->
<p>compute the decomposition of a symmetric tensor in its positive part and the derivative of this positive part. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DPPType</td><td>: type in which derivative of the positive part is stored </td></tr>
    <tr><td class="paramname">PPType</td><td>: type of positive part of the symmetric tensor </td></tr>
    <tr><td class="paramname">StensorType</td><td>: type of the symmetric tensor</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dpp</td><td>: derivative of the positive part of the symmetric tensor</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp</td><td>: positive part of the symmetric tensor</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: symmetric tensor</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>: numerical precision used to decipher if two eigenvalues are equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>DPPType must implement the ST2toST2Concept </dd>
<dd>
PPType must implement the StensorConcept </dd>
<dd>
StensorType must implement the StensorConcept </dd></dl>

</div>
</div>
<a id="adf64b9dcf1afdfb6a48660e6e98cd461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf64b9dcf1afdfb6a48660e6e98cd461">&#9670;&nbsp;</a></span>computeVelocityGradientDerivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::computeVelocityGradientDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>compute the derivative of the velocity gradient </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a600d19fd973cd5038b585498516862dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600d19fd973cd5038b585498516862dc">&#9670;&nbsp;</a></span>convertCauchyStressDerivativeToFirstPiolaKirchoffStressDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename stress , typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; tfel::math::convertCauchyStressDerivativeToFirstPiolaKirchoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the derivative of the Cauchy stress with respect to the deformation gradient to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>spatial dimension </td></tr>
    <tr><td class="paramname">stress</td><td>stress type </td></tr>
    <tr><td class="paramname">real</td><td>numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>derivative of the Cauchy stress with respect to the deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient. </dd></dl>

</div>
</div>
<a id="a7008df38bf4fc3f8170249537b46190a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7008df38bf4fc3f8170249537b46190a">&#9670;&nbsp;</a></span>convertCauchyStressDerivativeToFirstPiolaKirchoffStressDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename stress , typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::convertCauchyStressDerivativeToFirstPiolaKirchoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>dP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>ds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the derivative of the Cauchy stress with respect to the deformation gradient to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>spatial dimension </td></tr>
    <tr><td class="paramname">stress</td><td>stress type </td></tr>
    <tr><td class="paramname">real</td><td>numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dP</td><td>derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ds</td><td>derivative of the Cauchy stress with respect to the deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add97ec4538ae3252f1f2d3dc122aec35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add97ec4538ae3252f1f2d3dc122aec35">&#9670;&nbsp;</a></span>convertCauchyStressToFirstPiolaKirchhoffStress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::convertCauchyStressToFirstPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert the Cauchy stress to the first Piola-Kirchhoff stress. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StensorType</td><td>type of the Cauchy stress </td></tr>
    <tr><td class="paramname">TensorType</td><td>type of the deformation gradient</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the first Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a21c8c06e61c8a679d8997c71bd297813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c8c06e61c8a679d8997c71bd297813">&#9670;&nbsp;</a></span>convertCauchyStressToSecondPiolaKirchhoffStress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::convertCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert the Cauchy stress to the second Piola-Kirchhoff stress </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8e33815f244a68a37c7adfa09d24f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e33815f244a68a37c7adfa09d24f7d">&#9670;&nbsp;</a></span>convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StensorConcept T, StensorConcept T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::convertCorotationnalCauchyStressToSecondPiolaKirchhoffStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert the corotationnal cauchy stress to the second Piola-Kirchhoff stress </p>
<p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>corotationnal cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the second Piola-Kirchhoff stress </dd></dl>

</div>
</div>
<a id="a79dd742a1986cd03a99d3259d9b190eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79dd742a1986cd03a99d3259d9b190eb">&#9670;&nbsp;</a></span>convertFirstPiolaKirchhoffStressToCauchyStress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::convertFirstPiolaKirchhoffStressToCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert the first Piola-Kirchhoff stress to the Cauchy stress </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorType</td><td>type of the first Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramname">TensorType2</td><td>type of the deformation gradient</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Cauchy stress </dd></dl>

</div>
</div>
<a id="acce7f75958777ea853a9b64d93d6a994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acce7f75958777ea853a9b64d93d6a994">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressDerivativeToFirstPiolaKirchoffStressDerivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename stress , typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; tfel::math::convertSecondPiolaKirchhoffStressDerivativeToFirstPiolaKirchoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>dS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the derivative of the second Piola-Kirchoff stress with respect to the Green-Lagrange strain to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>spatial dimension </td></tr>
    <tr><td class="paramname">stress</td><td>stress type </td></tr>
    <tr><td class="paramname">real</td><td>numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dS</td><td>derivative of the second Piola-Kirchoff stress with respect to the Green-Lagrange strain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient. </dd></dl>

</div>
</div>
<a id="af2f42fbb8c13638c5a527d08c44ab55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f42fbb8c13638c5a527d08c44ab55a">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressDerivativeToFirstPiolaKirchoffStressDerivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename stress , typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::convertSecondPiolaKirchhoffStressDerivativeToFirstPiolaKirchoffStressDerivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>dP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>dS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tensor.html">tensor</a>&lt; N, real &gt; &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, stress &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert the derivative of the second Piola-Kirchoff stress with respect to the Green-Lagrange strain to the derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>spatial dimension </td></tr>
    <tr><td class="paramname">stress</td><td>stress type </td></tr>
    <tr><td class="paramname">real</td><td>numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dP</td><td>derivative of the first Piola-Kirchhoff stress with respect to the deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dS</td><td>derivative of the second Piola-Kirchoff stress with respect to the Green-Lagrange strain </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>Cauchy stress </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21ad6b9eb6830047f45d4d5dfe839c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ad6b9eb6830047f45d4d5dfe839c76">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCauchyStress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::convertSecondPiolaKirchhoffStressToCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the Cauchy stress </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ce53e8259a0b5d249bee1eba058bda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce53e8259a0b5d249bee1eba058bda5">&#9670;&nbsp;</a></span>convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StensorConcept T, StensorConcept T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::convertSecondPiolaKirchhoffStressToCorotationnalCauchyStress </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert the second Piola-Kirchhoff stress to the corotationnal cauchy stress: </p>
<p class="formulaDsp">
\[ \underline{S} = J\,\underline{U}^{-1}\,.\,\underline{\sigma}\,.\,\underline{U}^{-1} \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">S</td><td>the second Piola-Kirchhoff stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corotationnal cauchy stress </dd></dl>

</div>
</div>
<a id="afc0fa3ccea2c695fef62f43df5400784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0fa3ccea2c695fef62f43df5400784">&#9670;&nbsp;</a></span>convertToT2toST2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::convertToT2toST2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a1cdbe69ac76f33f811132f6d7ad5ff04">T2toT2Concept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a> tensor to a <a class="el" href="structtfel_1_1math_1_1t2tost2.html" title="linear operator which turns an unsymmetric tensor to symmetric tensor.">t2tost2</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>fourth order tensor to be converted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b7b0f7a8b8d414307c63a08e0e6bffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7b0f7a8b8d414307c63a08e0e6bffe">&#9670;&nbsp;</a></span>det() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::det </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aeca06c0ef953bcbf93189fa8513ce243">ST2toST2Concept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the determinant of a <code><a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a></code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>fourth order tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc0500a481b56e6c1c0126186956c48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0500a481b56e6c1c0126186956c48a">&#9670;&nbsp;</a></span>det() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::det </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the determinant of a symmetric tensor </dd></dl>

</div>
</div>
<a id="a19e2d43520e6f3f4d9a22e70d895d12f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19e2d43520e6f3f4d9a22e70d895d12f">&#9670;&nbsp;</a></span>det() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::det </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#a1cdbe69ac76f33f811132f6d7ad5ff04">T2toT2Concept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the determinant of a <code><a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a></code> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>fourth order tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2fd1c98651efcd79b6a7af293e47b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fd1c98651efcd79b6a7af293e47b1d">&#9670;&nbsp;</a></span>det() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::det </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the determinant of a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a149e523d4030183ad7609d865ee65933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a149e523d4030183ad7609d865ee65933">&#9670;&nbsp;</a></span>deviator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::deviator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the deviator of a symmetric tensor </dd></dl>

</div>
</div>
<a id="a5ce654ea4324ea12243df2df8283582e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce654ea4324ea12243df2df8283582e">&#9670;&nbsp;</a></span>eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType , typename Operation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a> tfel::math::eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_expr.html">Expr</a>&lt; <a class="el" href="structtfel_1_1math_1_1_result_type.html">ResultType</a>, Operation &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate an expression </p>
<dl class="section return"><dt>Returns</dt><dd>the computed value </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a916f1ef97fcae6df02e9283dac8e0e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916f1ef97fcae6df02e9283dac8e0e6d">&#9670;&nbsp;</a></span>exportToBaseTypeArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T , typename OutputIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::exportToBaseTypeArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>export the given vector to an array of the </p>

</div>
</div>
<a id="acbb1c275475cdc149dbfd54af468c885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb1c275475cdc149dbfd54af468c885">&#9670;&nbsp;</a></span>find_perpendicular_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::find_perpendicular_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; 3u, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>find a vector perpendicular to the second one </p>

</div>
</div>
<a id="add78759d62a38f9554085c8ecf781d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add78759d62a38f9554085c8ecf781d4d">&#9670;&nbsp;</a></span>geometricDiscretization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::geometricDiscretization </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::value_type&#160;</td>
          <td class="paramname"><em>xb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::value_type&#160;</td>
          <td class="paramname"><em>xe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::value_type&#160;</td>
          <td class="paramname"><em>db</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::value_type&#160;</td>
          <td class="paramname"><em>de</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename T::size_type&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>discretize a segment into a fixed number of elements trying to satisfy as much as possible given discretization densities at the beginning and the end of the segment. Elements size grows according to a geometric progression. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>: a "stl vector like" container </td></tr>
    <tr><td class="paramname">xb</td><td>: starting point </td></tr>
    <tr><td class="paramname">xe</td><td>: last point </td></tr>
    <tr><td class="paramname">db</td><td>: density of the discretization at the starting point </td></tr>
    <tr><td class="paramname">db</td><td>: density of the discretization at the last point </td></tr>
    <tr><td class="paramname">n</td><td>: number of elements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adec5b54890dbf67e6ee860f547b5836e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec5b54890dbf67e6ee860f547b5836e">&#9670;&nbsp;</a></span>get() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t i, unsigned short N, typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE const std::tuple_element_t&lt;i, <a class="el" href="structtfel_1_1math_1_1fsarray.html">fsarray</a>&lt;N, ValueType&gt; &gt;&amp; tfel::math::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1fsarray.html">fsarray</a>&lt; N, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>partial specialisation of <code>std::get</code> for <code><a class="el" href="structtfel_1_1math_1_1fsarray.html" title="a class representing tiny vectors of fixed size.">tfel::math::fsarray</a></code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">i</td><td>index of the element to be retrieved </td></tr>
    <tr><td class="paramname">N</td><td>size of the tiny vector </td></tr>
    <tr><td class="paramname">ValueType</td><td>type hold by the tiny vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae54e3abc2f8d8b0fdea29c5bd00dce7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54e3abc2f8d8b0fdea29c5bd00dce7f">&#9670;&nbsp;</a></span>get() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t i, unsigned short N, typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE const std::tuple_element_t&lt;i, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt;N, ValueType&gt; &gt;&amp; tfel::math::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>partial specialisation of <code>std::get</code> for <code><a class="el" href="structtfel_1_1math_1_1tvector.html" title="a class representing tiny vectors of fixed size.">tfel::math::tvector</a></code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">i</td><td>index of the element to be retrieved </td></tr>
    <tr><td class="paramname">N</td><td>size of the tiny vector </td></tr>
    <tr><td class="paramname">ValueType</td><td>type hold by the tiny vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac413ecff66eaa8acb2cbff09b693c5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac413ecff66eaa8acb2cbff09b693c5fa">&#9670;&nbsp;</a></span>get() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t i, unsigned short N, typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE std::tuple_element_t&lt;i, <a class="el" href="structtfel_1_1math_1_1fsarray.html">fsarray</a>&lt;N, ValueType&gt; &gt;&amp; tfel::math::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1fsarray.html">fsarray</a>&lt; N, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>partial specialisation of <code>std::get</code> for <code><a class="el" href="structtfel_1_1math_1_1fsarray.html" title="a class representing tiny vectors of fixed size.">tfel::math::fsarray</a></code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">i</td><td>index of the element to be retrieved </td></tr>
    <tr><td class="paramname">N</td><td>size of the tiny vector </td></tr>
    <tr><td class="paramname">ValueType</td><td>type hold by the tiny vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a639280d1be1af9a9c3b9a40b3679fb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a639280d1be1af9a9c3b9a40b3679fb38">&#9670;&nbsp;</a></span>get() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t i, unsigned short N, typename ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE std::tuple_element_t&lt;i, <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt;N, ValueType&gt; &gt;&amp; tfel::math::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, ValueType &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>partial specialisation of <code>std::get</code> for <code><a class="el" href="structtfel_1_1math_1_1tvector.html" title="a class representing tiny vectors of fixed size.">tfel::math::tvector</a></code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">i</td><td>index of the element to be retrieved </td></tr>
    <tr><td class="paramname">N</td><td>size of the tiny vector </td></tr>
    <tr><td class="paramname">ValueType</td><td>type hold by the tiny vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a295dd7bbf51747fb8f571773e1df3937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295dd7bbf51747fb8f571773e1df3937">&#9670;&nbsp;</a></span>getArrayPolicyMinimalDataSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayPolicyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tfel::math::getArrayPolicyMinimalDataSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the minimal number of values required to stored the given array policy </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayPolicyType</td><td>the array policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the array policy must have fixed sizes. </dd></dl>

</div>
</div>
<a id="a2c59691d17f54f06a7c695d50a334153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c59691d17f54f06a7c695d50a334153">&#9670;&nbsp;</a></span>getArrayPolicySize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayPolicyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tfel::math::getArrayPolicySize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the logical size of the given array policy, i.e. the number of values that can be accessed by the given policy. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayPolicyType</td><td>the array policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the array policy must have fixed sizes. </dd></dl>

</div>
</div>
<a id="a9a771d27759ba3cd62bfb1b3ad06a0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a771d27759ba3cd62bfb1b3ad06a0fa">&#9670;&nbsp;</a></span>getSpaceDimension()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MathObjectType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE unsigned short tfel::math::getSpaceDimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an helper function to retrieve the space dimension associated with a math object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MathObjectType</td><td>math object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dac85eb9e4a0729f98d4307357a577f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dac85eb9e4a0729f98d4307357a577f">&#9670;&nbsp;</a></span>getStensorSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST TFELMATH_VISIBILITY_EXPORT unsigned short tfel::math::getStensorSize </td>
          <td>(</td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the size of a symmetric tensor for the given dimension </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>space dimension </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa526bbcc59e298b1248eb27bcd7bcc68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa526bbcc59e298b1248eb27bcd7bcc68">&#9670;&nbsp;</a></span>hasArrayPolicyFixedSizes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayPolicyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::hasArrayPolicyFixedSizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if the given array policy has fixed sizes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayPolicyType</td><td>the array policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e847d1c24567cea3f45361f8daf4fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e847d1c24567cea3f45361f8daf4fba">&#9670;&nbsp;</a></span>hasArrayPolicyFixedSizes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayPolicyType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::hasArrayPolicyFixedSizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if the given array policy has fixed sizes. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayPolicyType</td><td>the array policy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb1368ebe96ba564610a80ae69a67170"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb1368ebe96ba564610a80ae69a67170">&#9670;&nbsp;</a></span>hasConceptTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::hasConceptTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>metafunction returning of the given type defines a type called <code>ConceptTag</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>type checked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8aa1154d827c15dafe8a2ac0b01c461b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa1154d827c15dafe8a2ac0b01c461b">&#9670;&nbsp;</a></span>hasConceptTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::hasConceptTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>metafunction returning of the given type defines a type called <code>ConceptTag</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>type checked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a6666876b2276f2ee69e574f0d53371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6666876b2276f2ee69e574f0d53371">&#9670;&nbsp;</a></span>hasIndexingPolicy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::hasIndexingPolicy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a simple metafunction which looks if the given type provides an internal type called <code>indexing_policy</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>type checked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4415c9d4b3406ee33b6b544ba53b5217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4415c9d4b3406ee33b6b544ba53b5217">&#9670;&nbsp;</a></span>hasIndexingPolicy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::hasIndexingPolicy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a simple metafunction which looks if the given type provides an internal type called <code>indexing_policy</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">T</td><td>type checked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb2482dac276fb6d101662603b4a95ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2482dac276fb6d101662603b4a95ea">&#9670;&nbsp;</a></span>haveIndexingPoliciesTheSameMemoryLayout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::haveIndexingPoliciesTheSameMemoryLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if two indexing policies have the same memory layout. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy1</td><td>first indexing policy </td></tr>
    <tr><td class="paramname">IndexingPolicy2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function is a simple wrapper around <code><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_base.html#a5df559393e5d2030bee39722b60a0afd">IndexingPoliciesCompatiblityCheck::haveTheSameMemoryLayout</a></code>. </dd></dl>

</div>
</div>
<a id="a6978e9e809a086d009ee40a12b87d169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6978e9e809a086d009ee40a12b87d169">&#9670;&nbsp;</a></span>haveIndexingPoliciesTheSameMemoryLayout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexingPolicy1 , typename IndexingPolicy2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool tfel::math::haveIndexingPoliciesTheSameMemoryLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if two indexing policies have the same memory layout. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IndexingPolicy1</td><td>first indexing policy </td></tr>
    <tr><td class="paramname">IndexingPolicy2</td><td>second indexing policy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this function is a simple wrapper around <code><a class="el" href="structtfel_1_1math_1_1_indexing_policies_compatiblity_check_base.html#a5df559393e5d2030bee39722b60a0afd">IndexingPoliciesCompatiblityCheck::haveTheSameMemoryLayout</a></code>. </dd></dl>

</div>
</div>
<a id="aa4580b97ec337d1b3bf293803dcc8acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4580b97ec337d1b3bf293803dcc8acb">&#9670;&nbsp;</a></span>implementsArrayConcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::implementsArrayConcept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code>ArrayConcept</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ArrayType</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a379784cc00b5a95031a679ef75bc6f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a379784cc00b5a95031a679ef75bc6f2d">&#9670;&nbsp;</a></span>implementsMatrixConcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::implementsMatrixConcept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code>MatrixConcept</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>function given for backward compatibility with versions prior to 5.0 </dd></dl>

</div>
</div>
<a id="a676f1e0cadeefce5385dbdece2e7ed5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676f1e0cadeefce5385dbdece2e7ed5c">&#9670;&nbsp;</a></span>implementsST2toST2Concept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toST2Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::implementsST2toST2Concept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code>ST2toST2Concept</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ST2toST2Type</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>function given for backward compatibility with versions prior to 5.0 </dd></dl>

</div>
</div>
<a id="a4a56b75f3471b6ec1b3db6a8128066e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a56b75f3471b6ec1b3db6a8128066e3">&#9670;&nbsp;</a></span>implementsST2toT2Concept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ST2toT2Type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::implementsST2toT2Concept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code>ST2toT2Concept</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ST2toT2Type</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>function given for backward compatibility with versions prior to 5.0 </dd></dl>

</div>
</div>
<a id="a9e0db70dd547f34dae5cdbf86f996f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0db70dd547f34dae5cdbf86f996f5c">&#9670;&nbsp;</a></span>implementsStensorConcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StensorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::implementsStensorConcept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code>StensorConcept</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">StensorType</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>function given for backward compatibility with versions prior to 5.0 </dd></dl>

</div>
</div>
<a id="afa0091b9045d4df080ad289bb8bbf416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0091b9045d4df080ad289bb8bbf416">&#9670;&nbsp;</a></span>implementsT2toST2Concept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;T2toST2Concept T2toST2Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::implementsT2toST2Concept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code>T2toST2Concept</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2toST2Type</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4779ca9f4de28e5be47542d5f90e554c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4779ca9f4de28e5be47542d5f90e554c">&#9670;&nbsp;</a></span>implementsT2toT2Concept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;T2toT2Concept T2toT2Type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::implementsT2toT2Concept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code>T2toT2Concept</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T2toT2Type</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>function given for backward compatibility with versions prior to 5.0 </dd></dl>

</div>
</div>
<a id="aa182da9de40e1aa645d5e36d733de510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa182da9de40e1aa645d5e36d733de510">&#9670;&nbsp;</a></span>implementsTensorConcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TensorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::implementsTensorConcept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code>TensorConcept</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorType</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>function given for backward compatibility with versions prior to 5.0 </dd></dl>

</div>
</div>
<a id="a87cc70145c4ac0752e4a1a743415c0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87cc70145c4ac0752e4a1a743415c0d0">&#9670;&nbsp;</a></span>implementsVectorConcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::implementsVectorConcept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an helper function which returns if the given type implements the <code>VectorConcept</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">VectorType</td><td>type tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>function given for backward compatibility with versions prior to 5.0 </dd></dl>

</div>
</div>
<a id="a44d8364a7cc6de24932f2d1f677a78fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d8364a7cc6de24932f2d1f677a78fb">&#9670;&nbsp;</a></span>init_floating_point_exceptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::init_floating_point_exceptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>this function enables C99 floating point rounding and exception handling:</p><ul>
<li>FE_DIVBYZERO: the DivideByZero exception occurs when an operation on finite numbers produces infinity as exact answer.</li>
<li>FE_UNDERFLOW: the Overflow exception occurs when a result has to be represented as a floating point number, but has (much) larger absolute value than the largest (finite) floating point number that is representable.</li>
<li>FE_OVERFLOW: the Underflow exception occurs when a result has to be represented as a floating point number, but has smaller absolute value than the smallest positive normalized floating point number (and would lose much accuracy when represented as a denormalized number).</li>
<li>FE_INEXACT: the Inexact exception occurs when the rounded result of an operation is not equal to the infinite precision result. It may occur whenever Overflow or Underflow occurs. </li>
</ul>

</div>
</div>
<a id="ac933af4151cde8f11748658ae0040ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac933af4151cde8f11748658ae0040ad3">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST auto tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aeca06c0ef953bcbf93189fa8513ce243">ST2toST2Concept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the invert of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a> to be inverted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeea6627e10b0e7c0205cac0033992669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea6627e10b0e7c0205cac0033992669">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inverse of a symmetric tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52ba3b459f1670e91a09e9dd96e6f274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52ba3b459f1670e91a09e9dd96e6f274">&#9670;&nbsp;</a></span>invert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the invert of a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>: tensor to be inverted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea2a48b5882876da6707ada2c302f4bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2a48b5882876da6707ada2c302f4bd">&#9670;&nbsp;</a></span>isAssignableTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE bool tfel::math::isAssignableTo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an helper function around <code>isAssignableTo</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">A,first</td><td>type </td></tr>
    <tr><td class="paramname">B,second</td><td>type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac32a69a130c0d7dfdd5860981401e860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32a69a130c0d7dfdd5860981401e860">&#9670;&nbsp;</a></span>isInvalid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::isInvalid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a simple wrapper around <code><a class="el" href="structtfel_1_1typetraits_1_1_is_invalid.html" title="Traits class which says if its argument is invalid.">tfel::typetraits::IsInvalid</a></code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>tested type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43abf99e1b4a3f6efa986124a21ccbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43abf99e1b4a3f6efa986124a21ccbd4">&#9670;&nbsp;</a></span>isScalar()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::isScalar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>a simple wrapper around <code><a class="el" href="structtfel_1_1typetraits_1_1_is_scalar.html" title="Traits class which says if its argument stands for a scalar.">tfel::typetraits::IsScalar</a></code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>tested type </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96c3d10e6170c55da38ecef0d529d915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c3d10e6170c55da38ecef0d529d915">&#9670;&nbsp;</a></span>map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MappedType , typename IndexingPolicyType  = typename MappedType::indexing_policy&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1_view.html">View</a>&lt;MappedType, IndexingPolicyType&gt; tfel::math::map </td>
          <td>(</td>
          <td class="paramtype">const ViewDataPointerType&lt; MappedType &gt;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return a view from a memory area </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MappedType</td><td>object mapped </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>pointer to the mapped memory area </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab974e937e9c60d3c1f32d5a2eaa7018b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab974e937e9c60d3c1f32d5a2eaa7018b">&#9670;&nbsp;</a></span>map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename T , unsigned short N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, std::invoke_result_t&lt; F, T &gt; &gt; tfel::math::map </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a new tvector by applying a functor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>functor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>inital value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4e4c5b5b1e7b9566c97a32f4b31b40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e4c5b5b1e7b9566c97a32f4b31b40d">&#9670;&nbsp;</a></span>map_derivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short I, unsigned short J, typename FunctionType , typename VariableType , unsigned short N, unsigned short M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE <a class="el" href="namespacetfel_1_1math.html#a01ca08095dda1754ec1294f599a9e042">derivative_view_from_tiny_matrix</a>&lt;M, FunctionType, VariableType&gt; tfel::math::map_derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a8a8691d8234e536cdd0d357a2bc5d10c">derivative_type</a>&lt; FunctionType, VariableType &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an helper function to create a derivative view from a tiny matrix </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>row index. </td></tr>
    <tr><td class="paramname">J</td><td>column index. </td></tr>
    <tr><td class="paramname">FunctionType</td><td>function type. </td></tr>
    <tr><td class="paramname">VariableType</td><td>variable type. </td></tr>
    <tr><td class="paramname">N</td><td>number of rows of the matrix. </td></tr>
    <tr><td class="paramname">M</td><td>number of columns of the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56102d4207cb6f4c5cb69b2408a0b3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56102d4207cb6f4c5cb69b2408a0b3cd">&#9670;&nbsp;</a></span>map_derivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctionType , typename VariableType , unsigned short N, unsigned short M&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE <a class="el" href="namespacetfel_1_1math.html#a01ca08095dda1754ec1294f599a9e042">derivative_view_from_tiny_matrix</a>&lt;M, FunctionType, VariableType&gt; tfel::math::map_derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; N, M, <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt; <a class="el" href="namespacetfel_1_1math.html#a8a8691d8234e536cdd0d357a2bc5d10c">derivative_type</a>&lt; FunctionType, VariableType &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>an helper function to create a derivative view from a tiny matrix </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FunctionType</td><td>function type. </td></tr>
    <tr><td class="paramname">VariableType</td><td>variable type. </td></tr>
    <tr><td class="paramname">N</td><td>number of rows of the matrix. </td></tr>
    <tr><td class="paramname">M</td><td>number of columns of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">I</td><td>row index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>column index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2051d610c24beaab4c3405ad25e80b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2051d610c24beaab4c3405ad25e80b1e">&#9670;&nbsp;</a></span>matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1matrix.html">tfel::math::matrix</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::initializer_list&lt; ValueType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="structtfel_1_1math_1_1matrix.html">matrix</a>&lt; ValueType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>class template argument deduction </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>numeric type </td></tr>
    <tr><td class="paramname">M</td><td>number of columns </td></tr>
    <tr><td class="paramname">d</td><td>sizes of the arrays, that must be all equal to M </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70b218c7bb3f7700ac54a9878340cf38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b218c7bb3f7700ac54a9878340cf38">&#9670;&nbsp;</a></span>matrix_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TensorConcept TensorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::matrix_view </td>
          <td>(</td>
          <td class="paramtype">TensorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression representing a matrix view from a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f01a74283def48311d3b026e87d7cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f01a74283def48311d3b026e87d7cc1">&#9670;&nbsp;</a></span>norm() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;VectorConcept T1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE auto tfel::math::norm </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the euclidian norm of a tvector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>: the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const typename tfel::typetraits::RealPartType&lt;T&gt;::type, the result </dd></dl>

</div>
</div>
<a id="aefdf42c97874d235642829914abc09db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdf42c97874d235642829914abc09db">&#9670;&nbsp;</a></span>norm() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ScalarConcept T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE auto tfel::math::norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1vector.html">vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the euclidian norm of a vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7beb69fa9bc7ed13e98051cf5bab1621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7beb69fa9bc7ed13e98051cf5bab1621">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::operator* </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacetfel_1_1math.html#a21f46866ed03b641861851d837909263">BinaryOperationHandler</a>&lt;decltype(a), decltype(b), OpMult&gt;
    requires((<a class="el" href="namespacetfel_1_1math.html#aaae1241d6d75bc14b37305447a79256a">isBinaryOperationResultTypeValid</a>&lt;decltype(a),
                                               decltype(b),
                                               OpMult&gt;()) &amp;&amp;
             (!((<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt;T1&gt;()) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt;T2&gt;()))))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>multiply to mathematical object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpMult&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="a83c9780f20804d1173f52cd2ed109e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c9780f20804d1173f52cd2ed109e23">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::operator+ </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacetfel_1_1math.html#a21f46866ed03b641861851d837909263">BinaryOperationHandler</a>&lt;decltype(a), decltype(b), OpPlus&gt;
    requires((<a class="el" href="namespacetfel_1_1math.html#aaae1241d6d75bc14b37305447a79256a">isBinaryOperationResultTypeValid</a>&lt;decltype(a),
                                               decltype(b),
                                               OpPlus&gt;()) &amp;&amp;
             (!((<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt;T1&gt;()) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt;T2&gt;()))))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add to mathematical object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpPlus&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="a721334a6647265d30ab99fe497973966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721334a6647265d30ab99fe497973966">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> -&gt; <a class="el" href="namespacetfel_1_1math.html#a223f10977fb55f4581bbe021800bcf4c">UnaryOperationHandler</a>&lt;decltype(a), OpNeg&gt;
    requires((!<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt;T1&gt;()) &amp;&amp;
             (<a class="el" href="namespacetfel_1_1math.html#a6292a7c384f0948638525b508e213de7">isUnaryOperationResultTypeValid</a>&lt;decltype(a), OpNeg&gt;()) &amp;&amp;
             (!<a class="el" href="namespacetfel_1_1math.html#ac32a69a130c0d7dfdd5860981401e860">isInvalid</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a223f10977fb55f4581bbe021800bcf4c">UnaryOperationHandler</a>&lt;decltype(a), OpNeg&gt;&gt;()))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>negate a mathematical object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation.</dd></dl>
<p>This operator is defined if the ComputeUnaryResult&lt;T1,T2,OpPlus&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="ad810d64b41d9017c7640ae221a7266ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad810d64b41d9017c7640ae221a7266ae">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::operator- </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacetfel_1_1math.html#a21f46866ed03b641861851d837909263">BinaryOperationHandler</a>&lt;decltype(a), decltype(b), OpMinus&gt;
    requires((<a class="el" href="namespacetfel_1_1math.html#aaae1241d6d75bc14b37305447a79256a">isBinaryOperationResultTypeValid</a>&lt;decltype(a),
                                               decltype(b),
                                               OpMinus&gt;()) &amp;&amp;
             (!((<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt;T1&gt;()) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt;T2&gt;()))))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>substract to mathematical object </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpMinus&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="aef0b901feaedc6089cfc4c3790627751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0b901feaedc6089cfc4c3790627751">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::operator/ </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacetfel_1_1math.html#a21f46866ed03b641861851d837909263">BinaryOperationHandler</a>&lt;decltype(a), decltype(b), OpDiv&gt;
    requires(
        (<a class="el" href="namespacetfel_1_1math.html#aaae1241d6d75bc14b37305447a79256a">isBinaryOperationResultTypeValid</a>&lt;decltype(a), decltype(b), OpDiv&gt;()) &amp;&amp;
        (!((<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt;T1&gt;()) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt;T2&gt;()))))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>divide a mathematical object by another </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpDiv&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="a2b759ee7f33caa991286726bb496361a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b759ee7f33caa991286726bb496361a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericType , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; tfel::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_aitken_acceleration_algorithm.html">AitkenAccelerationAlgorithm</a>&lt; NumericType, IndexType &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>output stream operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>output operator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a150aa17b4b9b5abbb5f87489adaf663f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150aa17b4b9b5abbb5f87489adaf663f">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; tfel::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_bissection_algorithm_base.html">BissectionAlgorithmBase</a>&lt; NumericType &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>output stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">a</td><td>acceleration algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2a2fc98dcdf453463e8a57d050ad943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a2fc98dcdf453463e8a57d050ad943">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumericType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; tfel::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_bissection_algorithm_data.html">BissectionAlgorithmData</a>&lt; NumericType &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>output stream </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d</td><td>data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bee7427a9c4d9a7a8d5d6ee1807da8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bee7427a9c4d9a7a8d5d6ee1807da8b">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST std::ostream&amp; tfel::math::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>serialisation operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">os</td><td>output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acedfea91e71a020b1c8c3b7b5b824dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acedfea91e71a020b1c8c3b7b5b824dfd">&#9670;&nbsp;</a></span>operator^()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::operator^ </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespacetfel_1_1math.html#a21f46866ed03b641861851d837909263">BinaryOperationHandler</a>&lt;decltype(a), decltype(b), OpDiadicProduct&gt;
    requires((<a class="el" href="namespacetfel_1_1math.html#aaae1241d6d75bc14b37305447a79256a">isBinaryOperationResultTypeValid</a>&lt;decltype(a),
                                               decltype(b),
                                               OpDiadicProduct&gt;()) &amp;&amp;
             (!((<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt;T1&gt;()) &amp;&amp; (<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt;T2&gt;()))))
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>diadic product between two mathematical objects </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>type of the left hand side argument </td></tr>
    <tr><td class="paramname">T2</td><td>type of the right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>: left hand side argument </td></tr>
    <tr><td class="paramname">b</td><td>: right hand side argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an handle which allow delayed evaluation of the operation</dd></dl>
<p>This operator is defined if the ComputeBinaryResult&lt;T1,T2,OpDiadicProduct&gt; metafunctions returns valid Result and Handle. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classtfel_1_1math_1_1_compute_binary_result.html">ComputeBinaryResult</a> </dd>
<dd>
IsInvalidType </dd></dl>

</div>
</div>
<a id="ae007b0242acbc71d7ecc7878e83d56a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae007b0242acbc71d7ecc7878e83d56a5">&#9670;&nbsp;</a></span>operator|() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StensorConcept T1, StensorConcept T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE <a class="el" href="namespacetfel_1_1math.html#af36bc9045afd07925b2bfef0a00c27f7">BinaryOperationResult</a>&lt;T1, T2, OpDotProduct&gt; tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left stensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right stensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the inner product of a vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left vector. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="aa4c8ad5490ca7330cd53a187b9ab8d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c8ad5490ca7330cd53a187b9ab8d4b">&#9670;&nbsp;</a></span>operator|() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StensorConcept T1, ST2toST2Concept T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left vector. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="a80e2f57164e56a19362a733f73db5124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e2f57164e56a19362a733f73db5124">&#9670;&nbsp;</a></span>operator|() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TensorConcept T1, T2toT2Concept T2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left stensor. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right stensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the inner product of a vector </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const</td><td>T1&amp;, the left vector. </td></tr>
    <tr><td class="paramname">const</td><td>T2&amp;, the right vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="aa686a6dc0aa4370f0c2665b2a5e689fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa686a6dc0aa4370f0c2665b2a5e689fc">&#9670;&nbsp;</a></span>operator|() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TensorConcept TensorType1, TensorConcept TensorType2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::operator| </td>
          <td>(</td>
          <td class="paramtype">const TensorType1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the inner product of a tensor </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TensorType1,type</td><td>of the left tensor. </td></tr>
    <tr><td class="paramname">TensorType2,type</td><td>of the right tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>the left tensor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>the right tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const result_type&lt;T,T2,OpMult&gt;, the result. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>the operator| has not the priority expected for such an operation : use of parenthesis is required. </dd></dl>

</div>
</div>
<a id="a348eeef65b9f9104eb9db425f3f29127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348eeef65b9f9104eb9db425f3f29127">&#9670;&nbsp;</a></span>polar_decomposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::polar_decomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>provide the polar decomposition of a tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>rotation tensor </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>stretch tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53620ecd1d9302ea6742d3a47a576bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53620ecd1d9302ea6742d3a47a576bb8">&#9670;&nbsp;</a></span>power() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, unsigned int D&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE auto tfel::math::power </td>
          <td>(</td>
          <td class="paramtype">const std::floating_point auto&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes x to the power N/D </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>exponent numerator </td></tr>
    <tr><td class="paramname">M</td><td>exponent denumerator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value</td></tr>
  </table>
  </dd>
</dl>
<p>computes x to the power N/D</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>exponent </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b1508fec9c3e7e4bbe85e720ba19456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1508fec9c3e7e4bbe85e720ba19456">&#9670;&nbsp;</a></span>power() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE auto tfel::math::power </td>
          <td>(</td>
          <td class="paramtype">const std::floating_point auto&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes x to the power N </p>
<p>computes x to the power N/D</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>exponent </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a514b41b0e229b71e1eafecba4931bd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514b41b0e229b71e1eafecba4931bd25">&#9670;&nbsp;</a></span>power() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, unsigned int D, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE auto tfel::math::power </td>
          <td>(</td>
          <td class="paramtype">const std::floating_point auto auto&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes x to the power N/D </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>exponent numerator </td></tr>
    <tr><td class="paramname">M</td><td>exponent denumerator </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value</td></tr>
  </table>
  </dd>
</dl>
<p>computes x to the power N/D</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>exponent </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73a1a41f6cff6487ff0e0cdd29a91f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73a1a41f6cff6487ff0e0cdd29a91f49">&#9670;&nbsp;</a></span>pull_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ST2toST2Concept ST2toST2Type, TensorConcept TensorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST auto tfel::math::pull_back </td>
          <td>(</td>
          <td class="paramtype">const ST2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the pull-back of a fourth order tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74159a4e553ce5da86d92dceb22828e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74159a4e553ce5da86d92dceb22828e4">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ST2toST2Concept ST2toST2Type, TensorConcept TensorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">const ST2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the push-forward of a fourth order tensor: <p class="formulaDsp">
\[ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} \]
</p>
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39daae537bddf4501a51859debdb860e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39daae537bddf4501a51859debdb860e">&#9670;&nbsp;</a></span>push_forward() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>compute the product: [F.s.F^{T}] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>a tensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>the same as pushForward </dd></dl>

</div>
</div>
<a id="ab334987571493a2fef52471dfacb35db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab334987571493a2fef52471dfacb35db">&#9670;&nbsp;</a></span>pushForward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::pushForward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>compute the product: [F.s.F^{T}] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>a symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>a tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae39472ec66a29e42a7851d566a5304f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39472ec66a29e42a7851d566a5304f2">&#9670;&nbsp;</a></span>regularisedFischerBurmeisterFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE real tfel::math::regularisedFischerBurmeisterFunction </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>e</em> = <code>real{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a regularised version of the Fischer-Burmeister function defined by: [ f\left(x,y)=x+y-\sqrt{x^{2}+y^{2}+\varepsilon^{2}} ] This function is such that: [ f\left(x,y)=0 \RighatArrow x\leq 0, y\leq 0 and \sqrt{2\,x\,y}=\varepsilon^{2} ] </p>
<blockquote class="doxtable">
<p>A Regularized and Smoothed Fischer-Burmeister Method for Quadratic Programming with Applications to Model Predictive Control. Dominic Liao-McPherson, Mike Huang, and Ilya Kolmanovsky </p>
</blockquote>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>regularisation parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the Fischer-Burmeister function </dd></dl>

</div>
</div>
<a id="af944b60fb53c166c7f8f18f25fc2f702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af944b60fb53c166c7f8f18f25fc2f702">&#9670;&nbsp;</a></span>regularisedFischerBurmeisterFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real tfel::math::regularisedFischerBurmeisterFunction </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>e</em> = <code>real{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a regularised version of the Fischer-Burmeister function defined by: [ f\left(x,y)=x+y-\sqrt{x^{2}+y^{2}+\varepsilon^{2}} ] This function is such that: [ f\left(x,y)=0 \RighatArrow x\leq 0, y\leq 0 and \sqrt{2\,x\,y}=\varepsilon^{2} ] </p>
<blockquote class="doxtable">
<p>A Regularized and Smoothed Fischer-Burmeister Method for Quadratic Programming with Applications to Model Predictive Control. Dominic Liao-McPherson, Mike Huang, and Ilya Kolmanovsky </p>
</blockquote>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>regularisation parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value of the Fischer-Burmeister function </dd></dl>

</div>
</div>
<a id="ae6b44a8d886f9e1a6748429141a4bb99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b44a8d886f9e1a6748429141a4bb99">&#9670;&nbsp;</a></span>regularisedFischerBurmeisterFunctionFirstDerivatives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::tuple&lt;real, real&gt; tfel::math::regularisedFischerBurmeisterFunctionFirstDerivatives </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivatives of the regularised version of the Fischer-Burmeister function </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>regularisation parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1eeb7dd9cc4a53a955127f9b48dfe6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eeb7dd9cc4a53a955127f9b48dfe6ea">&#9670;&nbsp;</a></span>regularisedFischerBurmeisterFunctionFirstDerivatives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;real, real&gt; tfel::math::regularisedFischerBurmeisterFunctionFirstDerivatives </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivatives of the regularised version of the Fischer-Burmeister function </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>regularisation parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ea0cf1f95cd7c6591d7377e70c934b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea0cf1f95cd7c6591d7377e70c934b8">&#9670;&nbsp;</a></span>requires()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, unsigned int D&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">tfel::math::requires </td>
          <td>(</td>
          <td class="paramtype">D !&#160;</td>
          <td class="paramname"> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>partial specialisation for the <a class="el" href="classtfel_1_1math_1_1_unary_result_type.html">UnaryResultType</a> class for exponentation of floating point number using rational exponent </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td></td></tr>
    <tr><td class="paramname">D</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a736687b37815fcec1211737cf6f0d7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736687b37815fcec1211737cf6f0d7d0">&#9670;&nbsp;</a></span>scalarNewtonRaphson() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename Criterion , typename NumericType , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE std::tuple&lt;bool, NumericType, IndexType&gt; tfel::math::scalarNewtonRaphson </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Criterion &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>NumericType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>IndexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the root of the given function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>type of a generalised function returning the value of the objective function and its derivative </td></tr>
    <tr><td class="paramname">Criterion</td><td>type of a function which computes the stopping criterion </td></tr>
    <tr><td class="paramname">NumericType</td><td>type of the root </td></tr>
    <tr><td class="paramname">IndexType</td><td>type of the iteration counter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>generalised function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>criterion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>initial guess </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">im</td><td>maximum number of iterations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple whose first field is a boolean giving the convergence status and the second field the last estimate of the solution. </dd></dl>

</div>
</div>
<a id="a8462ce00da4cf90d92ac67ce7bd8199c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8462ce00da4cf90d92ac67ce7bd8199c">&#9670;&nbsp;</a></span>scalarNewtonRaphson() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename Criterion , typename NumericType , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE std::tuple&lt;bool, NumericType, IndexType&gt; tfel::math::scalarNewtonRaphson </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Criterion &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_scalar_newton_raphson_parameters.html">ScalarNewtonRaphsonParameters</a>&lt; NumericType, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the root of the given function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>type of a generalised function returning the value of the objective function and its derivative </td></tr>
    <tr><td class="paramname">Criterion</td><td>type of a function which computes the stopping criterion </td></tr>
    <tr><td class="paramname">NumericType</td><td>type of the root </td></tr>
    <tr><td class="paramname">IndexType</td><td>type of the iteration counter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>generalised function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>criterion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>newton parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple whose first field is a boolean giving the convergence status and the second field the last estimate of the solution. </dd></dl>

</div>
</div>
<a id="a4acecfed63f80323d4d1f3a13da6b9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acecfed63f80323d4d1f3a13da6b9e0">&#9670;&nbsp;</a></span>scalarNewtonRaphson() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename Criterion , typename NumericType , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;bool, NumericType, IndexType&gt; tfel::math::scalarNewtonRaphson </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Criterion &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>NumericType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const&#160;</td>
          <td class="paramname"><em>IndexType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the root of the given function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>type of a generalised function returning the value of the objective function and its derivative </td></tr>
    <tr><td class="paramname">Criterion</td><td>type of a function which computes the stopping criterion </td></tr>
    <tr><td class="paramname">NumericType</td><td>type of the root </td></tr>
    <tr><td class="paramname">IndexType</td><td>type of the iteration counter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>generalised function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>criterion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x0</td><td>initial guess </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">im</td><td>maximum number of iterations </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple whose first field is a boolean giving the convergence status and the second field the last estimate of the solution. </dd></dl>

</div>
</div>
<a id="ad8f0b6160cbd1f54871cb5ef925b936e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f0b6160cbd1f54871cb5ef925b936e">&#9670;&nbsp;</a></span>scalarNewtonRaphson() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Function , typename Criterion , typename NumericType , typename IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;bool, NumericType, IndexType&gt; tfel::math::scalarNewtonRaphson </td>
          <td>(</td>
          <td class="paramtype">const Function &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Criterion &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1_scalar_newton_raphson_parameters.html">ScalarNewtonRaphsonParameters</a>&lt; NumericType, IndexType &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find the root of the given function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Function</td><td>type of a generalised function returning the value of the objective function and its derivative </td></tr>
    <tr><td class="paramname">Criterion</td><td>type of a function which computes the stopping criterion </td></tr>
    <tr><td class="paramname">NumericType</td><td>type of the root </td></tr>
    <tr><td class="paramname">IndexType</td><td>type of the iteration counter </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>generalised function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>criterion </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>newton parameters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple whose first field is a boolean giving the convergence status and the second field the last estimate of the solution. </dd></dl>

</div>
</div>
<a id="a1f2897a978d9d0c2022eac18e856ab83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2897a978d9d0c2022eac18e856ab83">&#9670;&nbsp;</a></span>sigmaeq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::sigmaeq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the von Mises stress of a symmetric tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80facbdfa24a55c2c733e091e3c40399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80facbdfa24a55c2c733e091e3c40399">&#9670;&nbsp;</a></span>slice() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short I, unsigned short N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a slice from a tiny vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the slice object contains a reference to the source vector, so this vector shall not be destroyed before the slice </dd></dl>

</div>
</div>
<a id="aef6944194fdfaeb9bb457af4aec059d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6944194fdfaeb9bb457af4aec059d1">&#9670;&nbsp;</a></span>slice() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short I, unsigned short J, unsigned short N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::slice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a slice from a tiny vector (const version) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the slice object contains a reference to the source vector, so this vector shall not be destroyed before the slice </dd></dl>

</div>
</div>
<a id="a9520961dd0ea8c4252f944b826474298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9520961dd0ea8c4252f944b826474298">&#9670;&nbsp;</a></span>slice() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short I, unsigned short N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a slice from a tiny vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the slice object contains a reference to the source vector, so this vector shall not be destroyed before the slice </dd></dl>

</div>
</div>
<a id="ab20b4e53906f43f7b4b66d5ec7c788ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20b4e53906f43f7b4b66d5ec7c788ac">&#9670;&nbsp;</a></span>slice() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short I, unsigned short J, unsigned short N, typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a slice from a tiny vector </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td>: vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the slice object contains a reference to the source vector, so this vector shall not be destroyed before the slice </dd></dl>

</div>
</div>
<a id="a14ef56da14652c580893f90b165ae591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ef56da14652c580893f90b165ae591">&#9670;&nbsp;</a></span>square_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE auto tfel::math::square_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the square root of a symmetric tensor </dd></dl>

</div>
</div>
<a id="a6373c72a52fe938120ffcfb6a6952789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6373c72a52fe938120ffcfb6a6952789">&#9670;&nbsp;</a></span>squaredFischerBurmeisterFunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE real tfel::math::squaredFischerBurmeisterFunction </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the square of the Fischer-Burmeister function </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af28368afe179eb2a167faa54d1b75af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af28368afe179eb2a167faa54d1b75af3">&#9670;&nbsp;</a></span>squaredFischerBurmeisterFunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">real tfel::math::squaredFischerBurmeisterFunction </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the square of the Fischer-Burmeister function </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae946a12af0950352569b2d4961fac39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae946a12af0950352569b2d4961fac39f">&#9670;&nbsp;</a></span>squaredFischerBurmeisterFunctionFirstDerivatives() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_MATH_INLINE std::tuple&lt;real, real&gt; tfel::math::squaredFischerBurmeisterFunctionFirstDerivatives </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivatives of the square of the Fischer-Burmeister function </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45c5ce8ac8f93979d28714d681c302f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c5ce8ac8f93979d28714d681c302f5">&#9670;&nbsp;</a></span>squaredFischerBurmeisterFunctionFirstDerivatives() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename real &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;real, real&gt; tfel::math::squaredFischerBurmeisterFunctionFirstDerivatives </td>
          <td>(</td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const real &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the derivatives of the square of the Fischer-Burmeister function </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">real</td><td>numeric type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>first argument </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>second argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf53f435672deac6c3cdcb05a3f5929d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf53f435672deac6c3cdcb05a3f5929d">&#9670;&nbsp;</a></span>st2tost2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , std::size_t M, std::size_t... d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1st2tost2.html">tfel::math::st2tost2</a> </td>
          <td>(</td>
          <td class="paramtype">ValueType &#160;</td>
          <td class="paramname"><em>const</em>(&amp;)[M], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &#160;</td>
          <td class="paramname"><em>const</em>(&amp;... arrays)[d]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structtfel_1_1math_1_1st2tost2.html">st2tost2</a>&lt; <a class="el" href="class_stensor_size_to_dime.html">StensorSizeToDime</a>&lt; sizeof...(d)+1 &gt;::value, ValueType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>class template argument deduction </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>numeric type </td></tr>
    <tr><td class="paramname">M</td><td>number of columns </td></tr>
    <tr><td class="paramname">d</td><td>sizes of the arrays, that must be all equal to M </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9727d9c54d4a4e55c68af7bfd8845971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9727d9c54d4a4e55c68af7bfd8845971">&#9670;&nbsp;</a></span>st2tot2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , std::size_t M, std::size_t... d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1st2tot2.html">tfel::math::st2tot2</a> </td>
          <td>(</td>
          <td class="paramtype">ValueType &#160;</td>
          <td class="paramname"><em>const</em>(&amp;)[M], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &#160;</td>
          <td class="paramname"><em>const</em>(&amp;... arrays)[d]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structtfel_1_1math_1_1st2tot2.html">st2tot2</a>&lt; <a class="el" href="class_tensor_size_to_dime.html">TensorSizeToDime</a>&lt; sizeof...(d)+1 &gt;::value, ValueType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>class template argument deduction </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>numeric type </td></tr>
    <tr><td class="paramname">M</td><td>number of columns </td></tr>
    <tr><td class="paramname">d</td><td>sizes of the arrays, that must be all equal to M </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab10370291140fbcc701193930ddfe04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10370291140fbcc701193930ddfe04d">&#9670;&nbsp;</a></span>syme()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::syme </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the symmetric part of a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13652efb5c63e23bb677ad7bad071280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13652efb5c63e23bb677ad7bad071280">&#9670;&nbsp;</a></span>symmetric_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StensorConcept StensorType1, StensorConcept StensorType2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::symmetric_product </td>
          <td>(</td>
          <td class="paramtype">const StensorType1 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType2 &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the symmetric product of two stensors as a symmetric tensor: </p>
<p class="formulaDsp">
\[ s1 * s2 + s2 * s1 \]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s1</td><td>first tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s2</td><td>second tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb951995af31c548aefeee1571f460bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb951995af31c548aefeee1571f460bd">&#9670;&nbsp;</a></span>t2tost2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , std::size_t M, std::size_t... d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1t2tost2.html">tfel::math::t2tost2</a> </td>
          <td>(</td>
          <td class="paramtype">ValueType &#160;</td>
          <td class="paramname"><em>const</em>(&amp;)[M], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &#160;</td>
          <td class="paramname"><em>const</em>(&amp;... arrays)[d]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structtfel_1_1math_1_1t2tost2.html">t2tost2</a>&lt; <a class="el" href="class_stensor_size_to_dime.html">StensorSizeToDime</a>&lt; sizeof...(d)+1 &gt;::value, ValueType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>class template argument deduction </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>numeric type </td></tr>
    <tr><td class="paramname">M</td><td>number of columns </td></tr>
    <tr><td class="paramname">d</td><td>sizes of the arrays, that must be all equal to M </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97e250606767ed66972ec28cc8f9bc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e250606767ed66972ec28cc8f9bc4e">&#9670;&nbsp;</a></span>t2tot2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , std::size_t M, std::size_t... d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1t2tot2.html">tfel::math::t2tot2</a> </td>
          <td>(</td>
          <td class="paramtype">ValueType &#160;</td>
          <td class="paramname"><em>const</em>(&amp;)[M], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &#160;</td>
          <td class="paramname"><em>const</em>(&amp;... arrays)[d]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structtfel_1_1math_1_1t2tot2.html">t2tot2</a>&lt; <a class="el" href="class_tensor_size_to_dime.html">TensorSizeToDime</a>&lt; sizeof...(d)+1 &gt;::value, ValueType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>class template argument deduction </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>numeric type </td></tr>
    <tr><td class="paramname">M</td><td>number of columns </td></tr>
    <tr><td class="paramname">d</td><td>sizes of the arrays, that must be all equal to M </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaba6ea982aec09dec9c7adf3960603a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba6ea982aec09dec9c7adf3960603a0">&#9670;&nbsp;</a></span>tmatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , std::size_t M, std::size_t... d&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1tmatrix.html">tfel::math::tmatrix</a> </td>
          <td>(</td>
          <td class="paramtype">ValueType &#160;</td>
          <td class="paramname"><em>const</em>(&amp;)[M], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &#160;</td>
          <td class="paramname"><em>const</em>(&amp;... arrays)[d]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  <a class="el" href="structtfel_1_1math_1_1tmatrix.html">tmatrix</a>&lt; 1u+sizeof...(d), M, ValueType &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>class template argument deduction </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>numeric type </td></tr>
    <tr><td class="paramname">M</td><td>number of columns </td></tr>
    <tr><td class="paramname">d</td><td>sizes of the arrays, that must be all equal to M </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac6a7ebc388352e7eec62fbc92a17fafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a7ebc388352e7eec62fbc92a17fafb">&#9670;&nbsp;</a></span>trace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the trace of a symmetric tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40f892f7f49207008189f30e3d7344ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f892f7f49207008189f30e3d7344ec">&#9670;&nbsp;</a></span>trace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#aa3a145427c716c04c1fa4fbfacf43a80">TensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the trace of a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25051153822df1582044c5ba9c97350a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25051153822df1582044c5ba9c97350a">&#9670;&nbsp;</a></span>transpose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacetfel_1_1math.html#aeca06c0ef953bcbf93189fa8513ce243">ST2toST2Concept</a> auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a transposed view of a fourth order tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>fourth order tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02e541ea20d7ac9d3cea6c06b473a083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e541ea20d7ac9d3cea6c06b473a083">&#9670;&nbsp;</a></span>transpose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;TensorConcept TensorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::transpose </td>
          <td>(</td>
          <td class="paramtype">TensorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression representing the transpose of a tensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef63f7558d34da9a924006a4764aa372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef63f7558d34da9a924006a4764aa372">&#9670;&nbsp;</a></span>tresca() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE T tfel::math::tresca </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; 1u, T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>compute the tresca stress for a symmetric tensor.</p>
<p>Partial specialisation in 1D</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a6a818d3f33afa7e28e7b5791ee2f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6a818d3f33afa7e28e7b5791ee2f49">&#9670;&nbsp;</a></span>tresca() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short N, typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE T tfel::math::tresca </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1stensor.html">stensor</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>compute the tresca stress for a symmetric tensor</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d42c5379cbec7faa5e35f780c1451cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d42c5379cbec7faa5e35f780c1451cb">&#9670;&nbsp;</a></span>unsyme()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::unsyme </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the unsymmetric tensor corresponding to the given symmetric tensor. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>symmetric tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad164223e414ca0700f6a4ee410598f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad164223e414ca0700f6a4ee410598f4c">&#9670;&nbsp;</a></span>ArrayConcept</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArrayType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept tfel::math::ArrayConcept</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      (std::is_same_v&lt;typename std::decay_t&lt;ArrayType&gt;::ConceptTag,</div>
<div class="line">                      ArrayTag&gt;) &amp;&amp;  </div>
<div class="line">      (<a class="code" href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">requires</a>(<span class="keyword">const</span> ArrayType t, <span class="keyword">const</span> index_type&lt;ArrayType&gt; i) {</div>
<div class="line">        t[i];</div>
<div class="line">      }) &amp;&amp;  </div>
<div class="line">      (<a class="code" href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">requires</a>(<span class="keyword">const</span> ArrayType t, <span class="keyword">const</span> index_type&lt;ArrayType&gt; i) { t(i); })</div>
<div class="ttc" id="anamespacetfel_1_1material_html_a6e4734204ad8818f98036b7798b72ba9"><div class="ttname"><a href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">tfel::material::requires</a></div><div class="ttdeci">requires(tfel::math::getSpaceDimension&lt; StensorType &gt;()==1u) TFEL_HOST_DEVICE const expr auto computeJ2O(const StensorType &amp;</div><div class="ttdoc">compute  the orthotropic generalization of the third invariant of the deviatoric part of the stress t...</div></div>
</div><!-- fragment -->
<p>definition of the ArrayConcept concept a class matching the array concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_array_tag.html" title="Helper class to characterise arrays.">ArrayTag</a></code> and have access operators. </p>

</div>
</div>
<a id="a7d6a5c545e9dec23c53c80c017574f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6a5c545e9dec23c53c80c017574f3c">&#9670;&nbsp;</a></span>computeCauchyStressDerivativeFromKirchhoffStressDerivative</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;T2toST2Concept T2toST2ResultType, T2toST2Concept T2toST2Type, StensorConcept StensorType, TensorConcept TensorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> computePushForwardDerivativeWithRespectToDeformationGradient ( T2toST2ResultType&amp;, const StensorType&amp;, const TensorType&amp;) noexcept requires(tfel constexpr TFEL_HOST_DEVICE <a class="el" href="include_2_cyrano_2_behaviour_8hxx.html#a04a02917f85c2196f18aa1b3c89504bd">void</a> tfel::math::computeCauchyStressDerivativeFromKirchhoffStressDerivative(T2toST2ResultType &amp;, const T2toST2Type &amp;, const StensorType &amp;, const TensorType &amp;) noexcept requires(<a class="el" href="namespacetfel_1_1math.html#a9a771d27759ba3cd62bfb1b3ad06a0fa">getSpaceDimension</a>&lt; T2toST2ResultType &gt;() </td>
          <td>(</td>
          <td class="paramtype">T2toST2ResultType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StensorType &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">==</div>
<div class="line">            getSpaceDimension&lt;T2toST2Type&gt;() &amp;&amp;</div>
<div class="line">        getSpaceDimension&lt;T2toST2ResultType&gt;() ==</div>
<div class="line">            getSpaceDimension&lt;StensorType&gt;() &amp;&amp;</div>
<div class="line">        getSpaceDimension&lt;T2toST2ResultType&gt;() ==</div>
<div class="line">            getSpaceDimension&lt;TensorType&gt;() &amp;&amp;</div>
<div class="line">        <a class="code" href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a>&lt;</div>
<div class="line">            numeric_type&lt;TensorType&gt;&gt;::cond &amp;&amp;</div>
<div class="line">        isAssignableTo&lt;typename ComputeBinaryResult&lt;numeric_type&lt;T2toST2Type&gt;,</div>
<div class="line">                                                    numeric_type&lt;StensorType&gt;,</div>
<div class="line">                                                    OpPlus&gt;::Result,</div>
<div class="line">                       numeric_type&lt;T2toST2ResultType&gt;&gt;())</div>
<div class="ttc" id="astructtfel_1_1typetraits_1_1_is_fundamental_numeric_type_html"><div class="ttname"><a href="structtfel_1_1typetraits_1_1_is_fundamental_numeric_type.html">tfel::typetraits::IsFundamentalNumericType</a></div><div class="ttdoc">Traits class which says if its argument is one of the standard numerical types.</div><div class="ttdef"><b>Definition:</b> IsFundamentalNumericType.hxx:38</div></div>
</div><!-- fragment -->
<p>compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient, i.e. it computes the derivative of F . S . transpose(F) with respect to F assuming that S is constant </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname"></td><td>derivative of the push-forward symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>orginal tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname"></td><td>deformation gradient</td></tr>
  </table>
  </dd>
</dl>
<p>compute the Cauchy stress derivative from the Kirchhoff stress derivative with respect to the deformation gradient </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">ds</td><td>: Cauchy stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dt_K</td><td>: Kirchhoff stress derivative </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: Cauchy stress </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>: deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1aa539be8131b309e2ced4f8f2b190b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa539be8131b309e2ced4f8f2b190b0">&#9670;&nbsp;</a></span>map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned short M, typename MappedType , unsigned short offset = 0u, unsigned short stride = getViewsArrayMinimalStride&lt;MappedType&gt;(), unsigned short N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto map ( <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt;N, <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt;MappedType&gt;&gt;&gt;&amp;) noexcept requires((!<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt;MappedType&gt;()) &amp;&amp; (IndexingPolicyType constexpr TFEL_HOST_DEVICE auto map ( const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt;N, <a class="el" href="namespacetfel_1_1math.html#aee110500aba43bd0fc73c7a5ecd510e9">base_type</a>&lt;<a class="el" href="namespacetfel_1_1math.html#a269ae6d80236c1e3a8f97af7c50997e9">numeric_type</a>&lt;MappedType&gt;&gt;&gt;&amp;) noexcept requires((!<a class="el" href="namespacetfel_1_1math.html#a43abf99e1b4a3f6efa986124a21ccbd4">isScalar</a>&lt;MappedType&gt;()) &amp;&amp; (IndexingPolicyType constexpr TFEL_HOST_DEVICE auto map (<a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt;N, real&gt;&amp;) noexcept requires((!std constexpr TFEL_HOST_DEVICE auto map (const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt;N, real&gt;&amp;) noexcept requires((IndexingPolicyType constexpr TFEL_HOST_DEVICE auto map ( <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt;N, <a class="el" href="namespacetfel_1_1math.html#afe1e469d35bbeb45d57faa77680c8a4e">ViewsArrayNumericType</a>&lt;MappedType&gt;&gt;&amp;) noexcept requires(!std constexpr TFEL_HOST_DEVICE auto tfel::math::map(const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, <a class="el" href="namespacetfel_1_1math.html#afe1e469d35bbeb45d57faa77680c8a4e">ViewsArrayNumericType</a>&lt; MappedType &gt;&gt; &amp;) </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtfel_1_1math_1_1tvector.html">tvector</a>&lt; N, <a class="el" href="namespacetfel_1_1math.html#afe1e469d35bbeb45d57faa77680c8a4e">ViewsArrayNumericType</a>&lt; MappedType &gt;&gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a view of a math object from a tiny vector </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MappedType</td><td>: type of mapped object </td></tr>
    <tr><td class="paramname">IndexingPolicyType</td><td>index policy type used by the generated view </td></tr>
    <tr><td class="paramname">N</td><td>size of the tiny vector </td></tr>
    <tr><td class="paramname">T</td><td>type hold by the tiny vector</td></tr>
  </table>
  </dd>
</dl>
<p>create a constant view of a math object from a tiny vector </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MappedType</td><td>: type of mapped object </td></tr>
    <tr><td class="paramname">IndexingPolicyType</td><td>index policy type used by the generated view </td></tr>
    <tr><td class="paramname">N</td><td>size of the tiny vector </td></tr>
    <tr><td class="paramname">T</td><td>type hold by the tiny vector</td></tr>
  </table>
  </dd>
</dl>
<p>create a view of a math object from a tiny vector </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MappedType</td><td>: type of mapped object </td></tr>
    <tr><td class="paramname">offset</td><td>offset in the tiny vector </td></tr>
    <tr><td class="paramname">IndexingPolicyType</td><td>index policy type used by the generated view </td></tr>
    <tr><td class="paramname">N</td><td>size of the tiny vector </td></tr>
    <tr><td class="paramname">T</td><td>type hold by the tiny vector</td></tr>
  </table>
  </dd>
</dl>
<p>create a constant view of a math object from a tiny vector </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MappedType</td><td>: type of mapped object </td></tr>
    <tr><td class="paramname">offset</td><td>offset in the tiny vector </td></tr>
    <tr><td class="paramname">IndexingPolicyType</td><td>index policy type used by the generated view </td></tr>
    <tr><td class="paramname">N</td><td>size of the tiny vector </td></tr>
    <tr><td class="paramname">T</td><td>type hold by the tiny vector</td></tr>
  </table>
  </dd>
</dl>
<p>create a view on an array of fixed sized math objects from a tiny vector </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>number of objects mapped </td></tr>
    <tr><td class="paramname">MappedType</td><td>: type of mapped object </td></tr>
    <tr><td class="paramname">offset</td><td>offset from the start of the tiny vector </td></tr>
    <tr><td class="paramname">N</td><td>size of the tiny vector</td></tr>
  </table>
  </dd>
</dl>
<p>create a const view on an array of fixed sized math objects from a tiny vector </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">M</td><td>number of objects mapped </td></tr>
    <tr><td class="paramname">MappedType</td><td>: type of mapped object </td></tr>
    <tr><td class="paramname">offset</td><td>offset from the start of the tiny vector </td></tr>
    <tr><td class="paramname">N</td><td>size of the tiny vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a383101542c9ac60f276aa9516e798a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383101542c9ac60f276aa9516e798a5c">&#9670;&nbsp;</a></span>MatrixConcept</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept tfel::math::MatrixConcept</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      (std::is_same_v&lt;typename std::decay_t&lt;MatrixType&gt;::ConceptTag,</div>
<div class="line">                      MatrixTag&gt;) &amp;&amp;</div>
<div class="line">      (<a class="code" href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">requires</a>(<span class="keyword">const</span> MatrixType t,</div>
<div class="line">                <span class="keyword">const</span> index_type&lt;MatrixType&gt; i,</div>
<div class="line">                <span class="keyword">const</span> index_type&lt;MatrixType&gt; j) { t(i, j); })</div>
</div><!-- fragment -->
<p>definition of the MatrixConcept concept a class matching the matrix concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_matrix_tag.html" title="Helper class to characterise matrices.">MatrixTag</a></code> and have access operators. </p>

</div>
</div>
<a id="a6431b0b5cd1f3c080568fa12d72cb828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6431b0b5cd1f3c080568fa12d72cb828">&#9670;&nbsp;</a></span>Power&lt; N, D &gt;</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtfel_1_1math_1_1_power.html">tfel::math::Power</a>&lt; N, D &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keyword">using</span> type = <span class="keywordtype">float</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a49b1ee32a0cd9dce3fb2d1be70b97f62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b1ee32a0cd9dce3fb2d1be70b97f62">&#9670;&nbsp;</a></span>push_forward</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;ST2toST2Concept ST2toST2Type, ST2toST2Concept ST2toST2Type2, TensorConcept TensorType&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr TFEL_HOST_DEVICE auto tfel::math::push_forward </td>
          <td>(</td>
          <td class="paramtype">ST2toST2Type &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ST2toST2Type2 &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorType &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">==</div>
<div class="line">                 getSpaceDimension&lt;ST2toST2Type2&gt;() &amp;&amp;</div>
<div class="line">             getSpaceDimension&lt;ST2toST2Type&gt;() ==</div>
<div class="line">                 getSpaceDimension&lt;TensorType&gt;())</div>
</div><!-- fragment -->
<p>compute de derivative of the push-forward of a symmetric second order tensor with respect to the deformation gradient, i.e. it computes the derivative of F . S . transpose(F) with respect to S assuming that F is constant </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">r</td><td>derivative of the push-forward symmetric tensor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient</td></tr>
  </table>
  </dd>
</dl>
<p>performs the push_forward of a <a class="el" href="structtfel_1_1math_1_1st2tost2.html" title="linear operator on symmetric tensors.">st2tost2</a>: [ Ct_{ijkl}=F_{im}F_{jn}F_{kp}F_{lq}C_{mnpq} ] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Ct</td><td>result </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>input </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>deformation gradient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a359e482446b8f5efdbf67c3f7706621b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a359e482446b8f5efdbf67c3f7706621b">&#9670;&nbsp;</a></span>square</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StensorConcept StensorType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TFEL_HOST_DEVICE auto logarithm (const StensorType&amp;, const bool = false) requires(tfel TFEL_HOST_DEVICE auto absolute_value (const StensorType&amp;, const bool = false) requires(tfel TFEL_HOST_DEVICE auto positive_part (const StensorType&amp;, const bool = false) requires(tfel TFEL_HOST_DEVICE auto negative_part (const StensorType&amp;, const bool = false) requires(tfel TFEL_HOST_DEVICE auto tfel::math::square(const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;) </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetfel_1_1math.html#ae5faa7fb4e6dea09c6c50a80d73cfb0c">StensorConcept</a> auto &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the logarithm of a symmetric tensor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed</td></tr>
  </table>
  </dd>
</dl>
<p>compute the absolute value of a symmetric tensor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed</td></tr>
  </table>
  </dd>
</dl>
<p>compute the positive part of a symmetric tensor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed</td></tr>
  </table>
  </dd>
</dl>
<p>compute the negative part of a symmetric tensor </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>: tensor </td></tr>
    <tr><td class="paramname">b</td><td>: if true, refinement of eigen values is performed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the square of a symmetric stensor </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s</td><td>: squared tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeca06c0ef953bcbf93189fa8513ce243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca06c0ef953bcbf93189fa8513ce243">&#9670;&nbsp;</a></span>ST2toST2Concept</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept tfel::math::ST2toST2Concept</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      (std::is_same_v&lt;typename std::decay_t&lt;T&gt;::ConceptTag, ST2toST2Tag&gt;) &amp;&amp;  </div>
<div class="line">      (<a class="code" href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">requires</a>(<span class="keyword">const</span> T t, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> j) {</div>
<div class="line">        t(i, j);</div>
<div class="line">      })</div>
</div><!-- fragment -->
<p>definition of the ST2toST2Concept a class matching the stensor concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_s_t2to_s_t2_tag.html" title="Helper class to characterise st2tost2.">ST2toST2Tag</a></code> and have access operators. </p>

</div>
</div>
<a id="ab2e863c47f92cd44e5188f09efee68b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e863c47f92cd44e5188f09efee68b6">&#9670;&nbsp;</a></span>ST2toT2Concept</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept tfel::math::ST2toT2Concept</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      (std::is_same_v&lt;typename std::decay_t&lt;T&gt;::ConceptTag, ST2toT2Tag&gt;) &amp;&amp;  </div>
<div class="line">      (<a class="code" href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">requires</a>(<span class="keyword">const</span> T t, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> j) {</div>
<div class="line">        t(i, j);</div>
<div class="line">      })</div>
</div><!-- fragment -->
<p>definition of the ST2toT2Concept </p>
<p>A class matching this concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_s_t2to_t2_tag.html" title="Helper class to characterise st2tot2.">ST2toT2Tag</a></code> and have appropriate access operators. </p>

</div>
</div>
<a id="ae5faa7fb4e6dea09c6c50a80d73cfb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5faa7fb4e6dea09c6c50a80d73cfb0c">&#9670;&nbsp;</a></span>StensorConcept</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept tfel::math::StensorConcept</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      (std::is_same_v&lt;typename std::decay_t&lt;T&gt;::ConceptTag, StensorTag&gt;) &amp;&amp;  </div>
<div class="line">      (<a class="code" href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">requires</a>(<span class="keyword">const</span> T t, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i) { t[i]; }) &amp;&amp;             </div>
<div class="line">      (<a class="code" href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">requires</a>(<span class="keyword">const</span> T t, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i) { t(i); })</div>
</div><!-- fragment -->
<p>definition of the StensorConcept a class matching the stensor concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_stensor_tag.html" title="Helper class to characterise stensors.">StensorTag</a></code> and have access operators. </p>

</div>
</div>
<a id="a27e6aca4a83fd4f27fb85c9d5811478f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e6aca4a83fd4f27fb85c9d5811478f">&#9670;&nbsp;</a></span>T2toST2Concept</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept tfel::math::T2toST2Concept</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      (std::is_same_v&lt;typename std::decay_t&lt;T&gt;::ConceptTag, T2toST2Tag&gt;) &amp;&amp;  </div>
<div class="line">      (<a class="code" href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">requires</a>(<span class="keyword">const</span> T t, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> j) {</div>
<div class="line">        t(i, j);</div>
<div class="line">      })</div>
</div><!-- fragment -->
<p>definition of the T2toST2Concept a class matching the stensor concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_t2to_s_t2_tag.html" title="Helper class to characterise t2tost2.">T2toST2Tag</a></code> and have access operators. </p>

</div>
</div>
<a id="a1cdbe69ac76f33f811132f6d7ad5ff04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cdbe69ac76f33f811132f6d7ad5ff04">&#9670;&nbsp;</a></span>T2toT2Concept</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept tfel::math::T2toT2Concept</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      (std::is_same_v&lt;typename std::decay_t&lt;T&gt;::ConceptTag, T2toT2Tag&gt;) &amp;&amp;  </div>
<div class="line">      (<a class="code" href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">requires</a>(<span class="keyword">const</span> T t, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> j) {</div>
<div class="line">        t(i, j);</div>
<div class="line">      })</div>
</div><!-- fragment -->
<p>definition of the T2toT2Concept </p>
<p>A class matching this concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_t2to_t2_tag.html" title="Helper class to characterise t2tot2.">T2toT2Tag</a></code> and have appropriate access operators. </p>

</div>
</div>
<a id="aa3a145427c716c04c1fa4fbfacf43a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a145427c716c04c1fa4fbfacf43a80">&#9670;&nbsp;</a></span>TensorConcept</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept tfel::math::TensorConcept</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      (std::is_same_v&lt;typename std::decay_t&lt;T&gt;::ConceptTag, TensorTag&gt;) &amp;&amp;  </div>
<div class="line">      (<a class="code" href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">requires</a>(<span class="keyword">const</span> T t, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i) { t[i]; }) &amp;&amp;            </div>
<div class="line">      (<a class="code" href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">requires</a>(<span class="keyword">const</span> T t, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i) { t(i); })</div>
</div><!-- fragment -->
<p>definition of the StensorConcept a class matching the stensor concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_stensor_tag.html" title="Helper class to characterise stensors.">StensorTag</a></code> and have access operators. </p>

</div>
</div>
<a id="a2573a7378fc579582e8c2c07042efbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2573a7378fc579582e8c2c07042efbde">&#9670;&nbsp;</a></span>VectorConcept</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">concept tfel::math::VectorConcept</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">      (std::is_same_v&lt;typename std::decay_t&lt;VectorType&gt;::ConceptTag,</div>
<div class="line">                      VectorTag&gt;) &amp;&amp;  </div>
<div class="line">      (<a class="code" href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">requires</a>(<span class="keyword">const</span> VectorType t, <span class="keyword">const</span> index_type&lt;VectorType&gt; i) {</div>
<div class="line">        t[i];</div>
<div class="line">      }) &amp;&amp;  </div>
<div class="line">      (<a class="code" href="namespacetfel_1_1material.html#a6e4734204ad8818f98036b7798b72ba9">requires</a>(<span class="keyword">const</span> VectorType t, <span class="keyword">const</span> index_type&lt;VectorType&gt; i) { t(i); })</div>
</div><!-- fragment -->
<p>definition of the VectorConcept concept a class matching the vector concept must expose the <code><a class="el" href="structtfel_1_1math_1_1_vector_tag.html" title="Helper class to characterise vectors.">VectorTag</a></code> and have access operators. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 22 2024 11:05:20 for tfel by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
</body>
</html>
