<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-EN" xml:lang="en-EN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Release notes of the 4.0 version of TFEL, MFront and MTest</title>
        <meta name="author" content="Thomas Helfer" />
            <meta name="date" content="2020-01-01" />
        <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
    <style type="text/css">code{white-space: pre;}</style>
            <style type="text/css">
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f8f8f8; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ef2929; } /* Alert */
      code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #c4a000; } /* Attribute */
      code span.bn { color: #0000cf; } /* BaseN */
      code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4e9a06; } /* Char */
      code span.cn { color: #000000; } /* Constant */
      code span.co { color: #8f5902; font-style: italic; } /* Comment */
      code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
      code span.dt { color: #204a87; } /* DataType */
      code span.dv { color: #0000cf; } /* DecVal */
      code span.er { color: #a40000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #0000cf; } /* Float */
      code span.fu { color: #000000; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
      code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
      code span.ot { color: #8f5902; } /* Other */
      code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
      code span.sc { color: #000000; } /* SpecialChar */
      code span.ss { color: #4e9a06; } /* SpecialString */
      code span.st { color: #4e9a06; } /* String */
      code span.va { color: #000000; } /* Variable */
      code span.vs { color: #4e9a06; } /* VerbatimString */
      code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
    </style>
            <link rel="stylesheet" href="css/normalize.css"/>
    <link rel="stylesheet" href="css/main.css"/>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
          </head>
  <body>
    <!--[if lt IE 7]>
        <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]-->
        <header>
      <ul id="nav">
	<li><a href="news.html">News</a></li>
	<li><a href="index.html">Overview</a>
	  <ul>
	    <li><a>Domain specific languages</a>
	      <ul>
		<li><a href="material-properties.html">Material properties</a></li>
		<li><a href="behaviours.html">Mechanical behaviours</a></li>
		<li><a href="models.html">Models</a></li>
	      </ul>
            </li>
	    <li><a href="interfaces.html">Available interfaces</a></li>
	    <li><a href="associated-projects.html">Associated projects</a></li>
     	    <li><a>Tools</a>
	      <ul>
	        <li><a href="mfront-doc.html">mfront-doc</a></li>
	        <li><a href="mtest.html">mtest</a></li>
	        <li><a href="mfm.html">mfm</a></li>
	        <li><a href="mfm-test-generator.html">mfm-test-generator</a></li>
	        <li><a href="tfel-check.html">tfel-check</a></li>
	      </ul>
	    </li>
	  </ul>
	</li>
	<li><a>Getting started</a>
	  <ul>
	    <li><a href="https://github.com/thelfer/tfel/">Github repository</a></li>
	    <li><a href="https://github.com/thelfer/tfel/releases">Download</a></li>
	    <li><a href="release-notes.html">Release notes</a>
	      <ul>
		<li><a>Versions 2.0.x</a>
                  <ul>
                    <li><a href="release-notes.html">Versions prior to 2.0.5</a></li>
	 	    <li><a href="release-notes-2.0.5.html">Version 2.0.5</a></li>
                  </ul>
		</li>
		<li><a>Versions 3.0.x</a>
                  <ul>
		    <li><a href="release-notes-3.0.html">Version 3.0.0</a></li>
		    <li><a href="release-notes-3.0.1.html">Version 3.0.1</a></li>
		    <li><a href="release-notes-3.0.2.html">Version 3.0.2</a></li>
		    <li><a href="release-notes-3.0.3.html">Version 3.0.3</a></li>
		    <li><a href="release-notes-3.0.4.html">Version 3.0.4</a></li>
		    <li><a href="release-notes-3.0.5.html">Version 3.0.5</a></li>
		    <li><a href="release-notes-3.0.6.html">Version 3.0.6</a></li>
		    <li><a href="release-notes-3.0.7.html">Version 3.0.7</a></li>
		    <li><a href="release-notes-3.0.8.html">Version 3.0.8</a></li>
		    <li><a href="release-notes-3.0.9.html">Version 3.0.9</a></li>
		    <li><a href="release-notes-3.0.10.html">Version 3.0.10</a></li>
		    <li><a href="release-notes-3.0.11.html">Version 3.0.11</a></li>
		    <li><a href="release-notes-3.0.12.html">Version 3.0.12</a></li>
		    <li><a href="release-notes-3.0.13.html">Version 3.0.13</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.1.x</a>
		  <ul>
		    <li><a href="release-notes-3.1.html">Version 3.1.0</a></li>
		    <li><a href="release-notes-3.1.1.html">Version 3.1.1</a></li>
		    <li><a href="release-notes-3.1.2.html">Version 3.1.2</a></li>
		    <li><a href="release-notes-3.1.3.html">Version 3.1.3</a></li>
		    <li><a href="release-notes-3.1.4.html">Version 3.1.4</a></li>
		    <li><a href="release-notes-3.1.5.html">Version 3.1.5</a></li>
		    <li><a href="release-notes-3.1.6.html">Version 3.1.6</a></li>
		    <li><a href="release-notes-3.1.7.html">Version 3.1.7</a></li>
		    <li><a href="release-notes-3.1.8.html">Version 3.1.8</a></li>
		    <li><a href="release-notes-3.1.9.html">Version 3.1.9</a></li>
		    <li><a href="release-notes-3.1.10.html">Version 3.1.10</a></li>
		    <li><a href="release-notes-3.1.11.html">Version 3.1.11</a></li>
		    <li><a href="release-notes-3.1.12.html">Version 3.1.12</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.2.x</a>
		  <ul>
		    <li><a href="release-notes-3.2.html">Version 3.2.0</a></li>
		    <li><a href="release-notes-3.2.1.html">Version 3.2.1</a></li>
		    <li><a href="release-notes-3.2.2.html">Version 3.2.2</a></li>
		    <li><a href="release-notes-3.2.3.html">Version 3.2.3</a></li>
		    <li><a href="release-notes-3.2.4.html">Version 3.2.4</a></li>
		    <li><a href="release-notes-3.2.5.html">Version 3.2.5</a></li>
		    <li><a href="release-notes-3.2.6.html">Version 3.2.6</a></li>
		    <li><a href="release-notes-3.2.7.html">Version 3.2.7</a></li>
		    <li><a href="release-notes-3.2.8.html">Version 3.2.8</a></li>
		    <li><a href="release-notes-3.2.9.html">Version 3.2.9</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.3.x</a>
		  <ul>
		    <li><a href="release-notes-3.3.html">Version 3.3.0</a></li>
		    <li><a href="release-notes-3.3.1.html">Version 3.3.1</a></li>
		    <li><a href="release-notes-3.3.1.html">Version 3.3.2</a></li>
		    <li><a href="release-notes-3.3.2.html">Version 3.3.2</a></li>
		    <li><a href="release-notes-3.3.3.html">Version 3.3.3</a></li>
		    <li><a href="release-notes-3.3.4.html">Version 3.3.4</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.4.x</a>
		  <ul>
		    <li><a href="release-notes-3.4.html">Version 3.4.0</a></li>
		    <li><a href="release-notes-3.4.1.html">Version 3.4.1</a></li>
		    <li><a href="release-notes-3.4.2.html">Version 3.4.2</a></li>
		    <li><a href="release-notes-3.4.3.html">Version 3.4.3</a></li>
		    <li><a href="release-notes-3.4.4.html">Version 3.4.4</a></li>
		    <li><a href="release-notes-3.4.5.html">Version 3.4.5</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.0.x</a>
		  <ul>
		    <li><a href="release-notes-4.0.html">Version 4.0.0</a></li>
		    <li><a href="release-notes-4.0.1.html">Version 4.0.1</a></li>
		    <li><a href="release-notes-4.0.2.html">Version 4.0.2</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.1.x</a>
		  <ul>
		    <li><a href="release-notes-4.1.html">Version 4.1.0</a></li>
		    <li><a href="release-notes-4.1.1.html">Version 4.1.1</a></li>
		    <li><a href="release-notes-4.1.2.html">Version 4.1.2</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.2.x</a>
		  <ul>
		    <li><a href="release-notes-4.2.html">Version 4.2.0</a></li>
		    <li><a href="release-notes-4.2.1.html">Version 4.2.1</a></li>
		  </ul>
		</li>
		<li><a>Versions 5.0.x</a>
		  <ul>
		    <li><a href="release-notes-5.0.html">Version 5.0.0</a></li>
		  </ul>
		</li>
	      </ul>
	    </li>
	    <li><a href="coverity-scan.html">Coverity scan</a></li>
	    <li><a href="install.html">Installation</a></li>
	  </ul>
	</li>
	<li><a>Documentation</a>
	  <ul>
	    <li><a href="documentations.html">General documentation</a></li>
	    <li><a href="gallery.html">Gallery</a></li>
<!--	    
	    <li><a href="http://tfel.sourceforge.net/doxygen/index.html">Doxygen documentation</a></li>
-->
	    <li><a>Behaviours</a>
	      <ul>
		<li><a href="tutorial.html">Tutorial</a></li>
		<li><a href="implicit-dsl.html">The Implicit DSL</a></li>
		<li><a href="benchmark.html">Benchmark</a></li>
		<li><a href="parameters.html">Parameters</a></li>
		<li><a href="BehaviourBricks.html">Behaviour bricks</a></li>
		<li><a href="interfaces.html">Solver interfaces</a>
		  <ul>
		    <li><a href="castem.html">Cast3M</a></li>
		    <li><a href="amitex.html">AMITEX_FFTP</a></li>
		    <li><a href="aster.html">Code-Aster</a></li>
    		    <li><a href="abaqus.html">Abaqus</a></li>
    		    <li><a href="epx.html">EUROPLEXUS</a></li>
		    <li><a href="zmat.html">ZeBuLoN</a></li>
   		    <li><a href="calculix.html">CalculiX</a></li>
		    <!-- <li><a >TMFFT</a></li> -->
		    <li><a href="cyrano.html">Cyrano</a></li>
   		    <li><a href="generic-material-property-interface.html">Generic interface for material properties</a></li>
   		    <li><a href="generic-behaviours-interface.html">Generic interface for behaviours</a></li>
		  </ul>
		</li>
	      </ul>
	    </li>
	    <li><a>TFEL libraries</a>
	      <ul>
		<li><a href="tfel-math.html">TFEL/Math</a></li>
		<li><a href="tfel-material.html">TFEL/Material</a></li>
	      </ul>
	    </li>
	    <li><a>Python modules</a>
	      <ul>
		<li><a href="tfel-python.html">TFEL modules</a></li>
		<li><a href="mfront-python.html">mfront module</a></li>
		<li><a href="mtest-python.html">mtest module</a></li>
	      </ul>
	    </li>
	    <li><a>MFront keywords</a>
	      <ul>
	        <li><a href="Default-keywords.html">Default</a></li>
	        <li><a href="DefaultCZM-keywords.html">DefaultCZM</a></li>
	        <li><a href="DefaultFiniteStrain-keywords.html">DefaultFiniteStrain</a></li>
	        <li><a href="DefaultGenericBehaviour-keywords.html">DefaultGenericBehaviour</a></li>
	        <li><a href="DefaultModel-keywords.html">DefaultModel</a></li>
	        <li><a href="Implicit-keywords.html">Implicit</a></li>
	        <li><a href="ImplicitCZM-keywords.html">ImplicitCZM</a></li>
	        <li><a href="ImplicitFiniteStrain-keywords.html">ImplicitFiniteStrain</a></li>
	        <li><a href="ImplicitGenericBehaviour-keywords.html">ImplicitGenericBehaviour</a></li>
	        <li><a href="ImplicitModel-keywords.html">ImplicitModel</a></li>
	        <li><a href="ImplicitII-keywords.html">ImplicitII</a></li>
	        <li><a href="IsotropicMisesCreep-keywords.html">IsotropicMisesCreep</a></li>
	        <li><a href="IsotropicMisesPlasticFlow-keywords.html">IsotropicMisesPlasticFlow</a></li>
	        <li><a href="IsotropicPlasticMisesFlow-keywords.html">IsotropicPlasticMisesFlow</a></li>
	        <li><a href="IsotropicStrainHardeningMisesCreep-keywords.html">IsotropicStrainHardeningMisesCreep</a></li>
	        <li><a href="MaterialLaw-keywords.html">MaterialLaw</a></li>
	        <li><a href="MaterialProperty-keywords.html">MaterialProperty</a></li>
	        <li><a href="Model-keywords.html">Model</a></li>
	        <li><a href="MultipleIsotropicMisesFlows-keywords.html">MultipleIsotropicMisesFlows</a></li>
	        <li><a href="RungeKutta-keywords.html">RungeKutta</a></li>
	        <li><a href="RungeKuttaFiniteStrain-keywords.html">RungeKuttaFiniteStrain</a></li>
	        <li><a href="RungeKuttaGenericBehaviour-keywords.html">RungeKuttaGenericBehaviour</a></li>
	        <li><a href="RungeKuttaModel-keywords.html">RungeKuttaModel</a></li>
	      </ul>
	    </li>
	    <li><a href="MTest-keywords.html">MTest keywords</a></li>
	    <li><a href="physical-constants.html">Physical constants</a></li>
	    <li><a href="glossary.html">Glossary</a></li>
	    <li><a href="publications.html">Publications</a></li>
	    <li><a href="faq.html">FAQ</a></li>
	    <li><a href="about.html">About</a></li>
	  </ul>
	</li>
	<li><a>Contributing</a>
	  <ul>
	    <li><a href="svn.html">Access to source repositories</a></li>
	    <li><a href="devel.html">Development guidelines</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Report bugs</a></li>
	  </ul>
	</li>
	<li><a>Getting Help</a>
	  <ul>
	    <li><a href="search.html">Search on this site</a></li>
	    <li><a href="https://github.com/thelfer/tfel/discussions">Forum</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Bug report</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Feature request</a></li>
	    <li><a href="mailto:tfel-contact@cea.fr">Contact</a></li>
	  </ul>
	</li>
      </ul>
    </header>
<div id="header">
<h1 class="title">Release notes of the 4.0 version of <code>TFEL</code>, <code>MFront</code> and <code>MTest</code></h1>
<h2 class="author">Thomas Helfer</h2>
<h3 class="date">2020</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#known-incompatibilities"><span class="toc-section-number">1</span> Known incompatibilities</a>
<ul>
<li><a href="#changes-to-existing-models"><span class="toc-section-number">1.1</span> Changes to existing models</a></li>
</ul></li>
<li><a href="#rejuvenation-of-the-tfelmath-library"><span class="toc-section-number">2</span> Rejuvenation of the <code>TFEL/Math</code> library</a>
<ul>
<li><a href="#description-of-some-shortcomings-of-previous-versions"><span class="toc-section-number">2.1</span> Description of some shortcomings of previous versions</a></li>
<li><a href="#overview-of-the-new-design-of-the-tfelmath-library"><span class="toc-section-number">2.2</span> Overview of the new design of the TFEL/Math library</a></li>
</ul></li>
<li><a href="#new-mfront-features"><span class="toc-section-number">3</span> New MFront features</a>
<ul>
<li><a href="#improvements-to-implicit-dsls"><span class="toc-section-number">3.1</span> Improvements to implicit DSLs</a></li>
</ul></li>
<li><a href="#issues-fixed"><span class="toc-section-number">4</span> Issues fixed</a>
<ul>
<li><a href="#issue277-material-properties-support-for-quantities"><span class="toc-section-number">4.1</span> Issue:#277: [material properties] Support for quantities</a></li>
<li><a href="#issue-276-support-for-quantities-in-tfelphysicalconstants"><span class="toc-section-number">4.2</span> Issue #276: Support for quantities in <code>TFEL/PhysicalConstants</code></a></li>
<li><a href="#issue-275-material-properties-define-standard-mfront-scalar-types"><span class="toc-section-number">4.3</span> Issue #275: [material properties] Define standard MFront scalar types</a></li>
<li><a href="#issue-160-add-the-ability-to-change-the-linear-solver-used-by-the-implicit-dsl"><span class="toc-section-number">4.4</span> Issue #160: Add the ability to change the linear solver used by the Implicit DSL</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<p>The page describes the new functionalities of Version 4.0 of the <code>TFEL</code> project.</p>
<p>This version was released on October 26, 2021 along with <code>TFEL-3.0.10</code>, <code>TFEL-3.1.10</code>, <code>TFEL-3.2.7</code>, <code>TFEL-3.3.3</code> and <code>TFEL-3.4.3</code> and inherits from the issues fixed in those releases.</p>
<h1 data-number="1" id="known-incompatibilities"><span class="header-section-number">1</span> Known incompatibilities</h1>
<ul>
<li>Material properties now define a list of aliases to scalar types that can conflict with variables declarations. The name of those aliases is thus reserved. See <a href="mfront-types.html">this page</a> for details.</li>
<li>The <code>TFELPhysicalConstants</code> library has been removed.</li>
<li>The <code>TFEL_NORETURN</code> macro has been removed.</li>
<li>In implicit DSLs, the corrections to the increment of the state variables are now stored in a variable called <code>delta_zeros</code>. This name is now reserved. For each integration variable <code>X</code>, the name <code>delta_dX</code> is also reserved. The <code>delta_dX</code> variable is only defined in the <code>@ProcessNewCorrection</code> code block (See Section 3.1.1.1).</li>
</ul>
<h2 data-number="1.1" id="changes-to-existing-models"><span class="header-section-number">1.1</span> Changes to existing models</h2>
<h3 data-number="1.1.1" id="mohr-coulomb-abbo-sloan"><span class="header-section-number">1.1.1</span> Mohr Coulomb Abbo Sloan</h3>
<ul>
<li>The corner smoothing of the Mohr Coulomb surface in the deviatoric plane is changed from the C1-continuous version (Abbo and Sloan, 1995) to the C2-continuous version from Abbo et al., 2011.</li>
</ul>
<h1 data-number="2" id="rejuvenation-of-the-tfelmath-library"><span class="header-section-number">2</span> Rejuvenation of the <code>TFEL/Math</code> library</h1>
<h2 data-number="2.1" id="description-of-some-shortcomings-of-previous-versions"><span class="header-section-number">2.1</span> Description of some shortcomings of previous versions</h2>
<h3 data-number="2.1.1" id="template-metaprogramming"><span class="header-section-number">2.1.1</span> Template metaprogramming</h3>
<p>The first versions of <code>TFEL</code> were based on <code>C++-98</code> standard which had limited support for template metaprogramming and no support for concept based requirements.</p>
<p>Template metaprogramming is the basis of many optimization techniques used in the library, such as expression templates, loop unrolling, compile-time conditionals, etc.</p>
<p>Metaprogramming in <code>C++</code> is becoming much easier at each revision of the standard. For example, <code>constexpr</code> functions were introduced in <code>C++-11</code> and extended in later revisions <code>C++-11</code> and <code>C++-17</code>.</p>
<p>Compile-time conditionals based in the <code>if constexpr</code> construct have been introduced in <code>C++-17</code>. This new construct eliminates the need of recurring to partial template specialization of auxiliary class template classes to implement compile-time conditionals, a pattern frequently used within the <code>TFEL/Math</code> library which is both verbose and difficult to read.</p>
<h4 data-number="2.1.1.1" id="example-of-code-size-reduction-related-to-compile-time-conditionals"><span class="header-section-number">2.1.1.1</span> Example of code size reduction related to compile-time conditionals</h4>
<p>The <code>sigmaeq</code> function compute the von Mises norm of a symmetric second order tensor. Depending on the space dimension, some components are null are shall be neglected. Since the space dimension is known at compile-time, the correct implementation can be chosen at this stage, thus avoiding a conditional branch at runtime.</p>
<h5 data-number="2.1.1.1.1" id="implementation-in-version-3.4.1"><span class="header-section-number">2.1.1.1.1</span> Implementation in Version <code>3.4.1</code></h5>
<p>The implementation of this function in <code>TFEL-3.4.1</code> is illustrated in Listing lst. 1.</p>
<div id="lst:sigmaeq_tfel_3.4.0" class="listing cxx">
<p>Listing 1: Implementation of the sigmaeq function in TFEL-3.4.1</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">typename</span> <span class="bu">std::</span>enable_if&lt;tfel::meta::Implements&lt;T, StensorConceptBase&gt;::cond,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                        StensorNumType&lt;T&gt;&gt;::type</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>sigmaeq(<span class="at">const</span> T&amp; s) {</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">typedef</span> tfel::math::internals::SigmaEqImpl&lt;StensorTraits&lt;T&gt;::dime&gt; Impl;</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> Impl::exe(s);</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</div>
<p>The returned type of this function is quite complex and will be discussed in depth in Section 2.1.2. In this section, let us focus on the body of this function which selects a specialization of the class <code>SigmaEqImpl</code> based on the space dimension and call its static function member <code>exe</code>.</p>
<p>Listing lst. 2 shows this specialization in <span class="math inline">\(1\)</span> dimension.</p>
<div id="lst:sigmaeq_impl_tfel_3.4.0" class="listing cxx">
<p>Listing 2: Implementation of the SigmaEqImpl class in TFEL-3.4.1</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">namespace</span> internals {</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> SigmaEqImplBase {</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> &lt;<span class="kw">typename</span> T&gt;</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">auto</span> square(<span class="at">const</span> T x) {</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> x * x;</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  };</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> &lt;<span class="dt">unsigned</span> <span class="dt">short</span> N&gt;</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> SigmaEqImpl;</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">template</span> &lt;&gt;</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> SigmaEqImpl&lt;<span class="dv">1</span><span class="bu">u</span>&gt; : <span class="kw">public</span> SigmaEqImplBase {</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">static</span> <span class="kw">typename</span> <span class="bu">std::</span>enable_if&lt;</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        tfel::meta::Implements&lt;T, StensorConceptBase&gt;::cond,</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        StensorNumType&lt;T&gt;&gt;::type</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    exe(<span class="at">const</span> T&amp; s) {</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">typedef</span> StensorNumType&lt;T&gt; NumType;</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>      <span class="kw">typedef</span> tfel::typetraits::<span class="dt">base_type</span>&lt;NumType&gt; base;</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>      <span class="kw">constexpr</span> <span class="kw">auto</span> cste = base{<span class="dv">3</span>} / base{<span class="dv">2</span>};</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> <span class="fu">tr</span> = trace(s) / <span class="dv">3</span>;</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="bu">std::</span>sqrt(cste * (SigmaEqImplBase::square(s(<span class="dv">0</span>) - <span class="fu">tr</span>) +</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>                               SigmaEqImplBase::square(s(<span class="dv">1</span>) - <span class="fu">tr</span>) +</span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>                               SigmaEqImplBase::square(s(<span class="dv">2</span>) - <span class="fu">tr</span>)));</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>  };</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>} <span class="co">// end of namespace internals</span></span></code></pre></div>
</div>
<p>The specializations in <span class="math inline">\(2D\)</span> and <span class="math inline">\(3D\)</span> are of course very similar. In fine, the whole implementation is hardly readable and verbose with about 80 lines.</p>
<h5 data-number="2.1.1.1.2" id="implementation-in-version-4.0"><span class="header-section-number">2.1.1.1.2</span> Implementation in Version <code>4.0</code></h5>
<p>In constrast, the use of the <code>if constexpr</code> construct of <code>C++-17</code> leads to this aknowledgly much more compact and readable code:</p>
<div id="lst:sigmaeq_tfel_4.0.1" class="listing cxx cxx">
<p>Listing 3: Implementation of the sigmaeq function in TFEL-4.0</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode cxx cxx"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> StensorType&gt;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>enable_if_t&lt;implementsStensorConcept&lt;StensorType&gt;(),</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                 <span class="dt">numeric_type</span>&lt;StensorType&gt;&gt;</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>sigmaeq(<span class="at">const</span> StensorType&amp; s) {</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">using</span> real = <span class="dt">base_type</span>&lt;<span class="dt">numeric_type</span>&lt;StensorType&gt;&gt;;</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> N = getSpaceDimension&lt;StensorType&gt;();</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> one_third = real(<span class="dv">1</span>) / <span class="dv">3</span>;</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="kw">auto</span> cste = real(<span class="dv">3</span>) / <span class="dv">2</span>;</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_assert</span>((N == <span class="dv">1</span>) || (N == <span class="dv">2</span>) || (N == <span class="dv">3</span>), <span class="st">&quot;invalid space dimension&quot;</span>);</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> square = [](<span class="at">const</span> <span class="kw">auto</span> x) { <span class="cf">return</span> x * x; };</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> <span class="fu">tr</span> = one_third * trace(s);</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="kw">constexpr</span> (N == <span class="dv">1</span><span class="bu">u</span>) {</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>sqrt(cste * (square(s(<span class="dv">0</span>) - <span class="fu">tr</span>) +  <span class="co">//</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>                             square(s(<span class="dv">1</span>) - <span class="fu">tr</span>) +  <span class="co">//</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>                             square(s(<span class="dv">2</span>) - <span class="fu">tr</span>)));</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> <span class="cf">if</span> <span class="kw">constexpr</span> (N == <span class="dv">2</span><span class="bu">u</span>) {</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>sqrt(cste * (square(s(<span class="dv">0</span>) - <span class="fu">tr</span>) +  <span class="co">//</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>                             square(s(<span class="dv">1</span>) - <span class="fu">tr</span>) +  <span class="co">//</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>                             square(s(<span class="dv">2</span>) - <span class="fu">tr</span>) + square(s(<span class="dv">3</span>))));</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> <span class="cf">if</span> <span class="kw">constexpr</span> (N == <span class="dv">3</span><span class="bu">u</span>) {</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">std::</span>sqrt(cste * (square(s(<span class="dv">0</span>) - <span class="fu">tr</span>) +  <span class="co">//</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>                             square(s(<span class="dv">1</span>) - <span class="fu">tr</span>) +  <span class="co">//</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>                             square(s(<span class="dv">2</span>) - <span class="fu">tr</span>) +  <span class="co">//</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>                             square(s(<span class="dv">3</span>)) + square(s(<span class="dv">4</span>)) + square(s(<span class="dv">5</span>))));</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>}  <span class="co">// end of sigmaeq</span></span></code></pre></div>
</div>
<h3 data-number="2.1.2" id="sec:tfel_math:concepts"><span class="header-section-number">2.1.2</span> Concepts</h3>
<p>Concepts are used in the library to relate objects having the same mathematical nature, such as symmetric second order tensors.</p>
<p>Indeed, several data structures in the library matches the concept of symmetric second order tensors:</p>
<ul>
<li>The <code>stensor</code> data structure defines a symmetric second order tensor usually allocated on the stack.</li>
<li>Following the expression template technique, data structures representing an operation that will result to a symmetric second order tensor if evaluated.</li>
<li>Views to externally allocated memory areas (see Section 2.1.3.2).</li>
</ul>
<p>Support for concepts is not part of the <code>C++-17</code> standard and has only been introduced in the <code>C++-20</code> standard. Hence, the support of concepts currently rely on a hand crafted machinery which has been simplified using <code>C++-17</code> facilities and prepared for its elimination when the library will be ported to <code>C++-20</code>.</p>
<p>Requirements on template arguments are currently based on the <code>SFINAE</code> rule and the <code>std::enable_if</code> facility, which takes as first template argument a boolean value which states if the template parameters of the function satisfies the requirements and as second argument giving the result of the function. To illustrate this, one may consider the declaration of the <code>sigmaeq</code> function:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">template</span> &lt;<span class="kw">typename</span> StensorType&gt;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>enable_if_t&lt;implementsStensorConcept&lt;StensorType&gt;(),</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                 <span class="dt">numeric_type</span>&lt;StensorType&gt;&gt;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>sigmaeq(<span class="at">const</span> StensorType&amp;);</span></code></pre></div>
<p>In this example, the <code>implementsStensorConcept</code> function can be called at compile-time to check if the type <code>StensorType</code> is a symmetric second order tensor. If not, this function is not considered by the compiler.</p>
<p>Several functions similar to <code>implementsStensorConcept</code> has been introduced in <code>TFEL-4.0</code> to facilitate the transition to <code>C++-20</code> built-in support of concepts.</p>
<blockquote>
<p><strong>Declaration in the future <code>TFEL-5.0</code></strong></p>
<p>With <code>C++-20</code>, the declaration of the <code>sigmaeq</code> will probably be much simplier and is expected to look as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> sigmaeq(<span class="at">const</span> StensorConcept <span class="kw">auto</span>&amp;);</span></code></pre></div>
</blockquote>
<h3 data-number="2.1.3" id="need-of-a-higher-level-of-abstraction-and-genericity"><span class="header-section-number">2.1.3</span> Need of a higher level of abstraction and genericity</h3>
<h4 data-number="2.1.3.1" id="basic-assignement-operators-scaling-operators"><span class="header-section-number">2.1.3.1</span> Basic assignement operators, scaling operators</h4>
<p>A mathematical object must implement some basic assignement operators such as:</p>
<ul>
<li>The standard assignement which is implemented using <code>operator=</code>.</li>
<li>The <code>operator+=</code> operator</li>
<li>The <code>operator-=</code> operator</li>
</ul>
<p>Those operators must be valid for any mathematical object assignable to the current object or to an object representing an operation whose result is assignable to this object (see the expression template technique described in Section 2.2.1.6). For example, assigning a strain tensor to a stress tensor is not allowed because a strain value can be assigned to a stress value.</p>
<p>A mathematical object must implement scaling operators allowing to mulply (<code>operator*=</code>) and divide (<code>operator/=</code>) every components of the object by a scalar value. This operation is only valid if the result of the operation of multiplying the component by the scalar value is assignable to the component. For example, scaling a strain tensor by a stress value is not allowed (because the result of the multiplication of a strain value by a stress value is a stress value which is not assignable to a strain value).</p>
<p>Those operators were implemented once per supported mathematical object (vector, symmetric tensors, etc.) in dedicated base classes such as:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>tvector_base<span class="er">`</span>, <span class="er">`</span>tmatrix_base<span class="er">`</span>, <span class="er">`</span>stensor_base<span class="er">`</span>, <span class="er">`</span>tensor_base<span class="er">`</span>,</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>st2tost2_base<span class="er">`</span>, <span class="er">`</span>t2tot2_base<span class="er">`</span>, <span class="er">`</span>st2tot2_base<span class="er">`</span>, <span class="er">`</span>t2tost2_base<span class="er">`</span></span></code></pre></div>
<p>The use of base class allowed to factorize code between the class implementing the mathematical objects and surrogate classes acting like those mathematical objects like views (see Section 2.2.1.7).</p>
<p>Nevertheless, implementing such operators increased the total code size and were extra-work which prevented introduction of new mathematical objects.</p>
<p>This was required by the lack of a common way to access individual components of a mathematical object. Providing such access is one of the driving force for the re-design of the <code>TFEL/Math</code> library.</p>
<h4 data-number="2.1.3.2" id="sec:tfel_math_3.x:view"><span class="header-section-number">2.1.3.2</span> Views</h4>
<p>Views are an important feature of the library which allows to map an externally allocated memory area to mathematical objets. The concept of views is fully described in Section 2.2.1.7.</p>
<p>In previous versions, views were implemented as lightweight classes `which were introduced as needed. With time, a myriad of such classes were introduced:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>ConstTMatrixView<span class="er">`</span>, <span class="er">`</span>tmatrix_column_view<span class="er">`</span>,</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>tmatrix_const_column_view<span class="er">`</span>, <span class="er">`</span>tmatrix_const_row_view<span class="er">`</span>,</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>tmatrix_const_submatrix_view<span class="er">`</span>, <span class="er">`</span>tmatrix_row_view<span class="er">`</span>,</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>tmatrix_submatrix_view<span class="er">`</span> <span class="er">`</span>TMatrixView<span class="er">`</span>, <span class="er">`</span>ConstST2toST2View<span class="er">`</span>,</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>ST2toST2View<span class="er">`</span>, <span class="er">`</span>ST2toT2FromTinyMatrixView2<span class="er">`</span>,</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>ST2toT2FromTinyMatrixView<span class="er">`</span>, <span class="er">`</span>ST2toT2View<span class="er">`</span>, <span class="er">`</span>ConstStensorView<span class="er">`</span>,</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>StensorFromTinyVectorView<span class="er">`</span>, <span class="er">`</span>StensorView<span class="er">`</span>, <span class="er">`</span>ConstT2toST2View<span class="er">`</span>,</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>T2toST2FromTinyMatrixView2<span class="er">`</span>, <span class="er">`</span>T2toST2FromTinyMatrixView<span class="er">`</span>,</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>T2toST2View<span class="er">`</span>, <span class="er">`</span>T2toT2FromTinyMatrixView2<span class="er">`</span>, <span class="er">`</span>T2toT2FromTinyMatrixView<span class="er">`</span>,</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>T2toT2View<span class="er">`</span>, <span class="er">`</span>TensorFromTinyVectorView<span class="er">`</span>, <span class="er">`</span>TensorView<span class="er">`</span>,</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>ConstTVectorView<span class="er">`</span>, <span class="er">`</span>TinyVectorFromTinyVectorView<span class="er">`</span>,</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>TinyVectorOfStensorFromTinyVectorView<span class="er">`</span>,</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>TinyVectorOfTinyVectorFromTinyVectorView<span class="er">`</span>,</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="er">`</span>TVectorFromTinyVectorView<span class="er">`</span> <span class="er">`</span>TVectorView<span class="er">`</span>, TensorViewFromStensor<span class="er">`</span>,</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>TensorFromTinyMatrixRowView<span class="er">`</span>, TensorFromTinyMatrixColumnView2<span class="er">`</span>,</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>MatrixViewFromTensor<span class="er">`</span>, TensorFromTinyMatrixRowView2<span class="er">`</span>,</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>TensorFromTinyMatrixColumnView<span class="er">`</span>, VectorFromTinyMatrixColumnView2<span class="er">`</span>,</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>VectorFromTinyMatrixRowView2<span class="er">`</span>, VectorFromTinyMatrixRowView<span class="er">`</span>,</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>VectorFromTinyMatrixColumnView<span class="er">`</span>, StensorFromTinyMatrixColumnView<span class="er">`</span>,</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>StensorFromTinyMatrixRowView<span class="er">`</span>, StensorFromTinyMatrixColumnView2<span class="er">`</span>,</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>StensorFromTinyMatrixRowView2<span class="er">`</span></span></code></pre></div>
<p>Multiplying such utility classes became a maintenability burden and was also a reason to limit the number of mathematical objects supported by the library and in <code>MFront</code>.</p>
<p>Moreover, those classes were not designed to handle quantities appropriately (see Section 2.2.1.1), i.e. one could not map math objets with units.</p>
<p>All those classes are now remplaced by the two classes <code>View</code> and <code>ViewsArray</code> which heavily relies on the notion of indexing policy described in Section 2.2.1.3 and which correctly handles quantities. Thoses classes are described in depth in Section 2.2.1.7.</p>
<h3 data-number="2.1.4" id="support-for-compile-time-operations-constexpr"><span class="header-section-number">2.1.4</span> Support for compile-time operations (<code>constexpr</code>)</h3>
<p>The <code>constexpr</code> keywords has been introduced in <code>C++-11</code>. They can qualify functions and member functions. However, they were rarely used in the <code>TFEL/Math</code> library in previous versions because of important restrictions put by the <code>C++-11</code> standard and brittle compiler support, as least when <code>TFEL-3.0</code> was released. Those restrictions were relaxed by <code>C++-14</code> and <code>C++-17</code> standards.</p>
<p>Declaring most functions <code>constexpr</code> allow to test them at compile-time which is incredibly confortable: basically, if a unit-test based on the evaluation of <code>constexpr</code> function compiles, then the test does not even have to be run.</p>
<h3 data-number="2.1.5" id="error-handling-and-noexcept-correctness."><span class="header-section-number">2.1.5</span> Error handling and <code>noexcept</code> correctness.</h3>
<p>The default way of reporting errors in the <code>TFEL/Math</code> library was exceptions thrown using one of the <code>tfel::raise</code> functions.</p>
<p>In hindsight, it appears that relying on exceptions was in most cases a bad design choice<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>.</p>
<p>Most errors can be grabbed at compile-time by the compiler or are just avoided by design. For example, checking if the indices passed to the access operator to a symmetric tensors are valid is mostly useless as:</p>
<ul>
<li>The access operator is hardly ever used by the end user and the library provide all the tensorial operations required to work at a higher level of abstraction closed to the mathematical expression.</li>
<li>Most out of bounds access can be detected by the compiler at compile-time as most mathematical objects are based on stacked allocated arrays whose size is known at compile-time.</li>
</ul>
<p>As runtime-time checks may prevent optimisations, such tests were inhibited in release builds and only enabled in debug builds. In this case, it seems pretty clear that aborting the execution is a much better choice than throwing an exception. This is the purpose of the <code>reportContractViolation</code> function.</p>
<p>As a consequence, most functions and methods of the <code>TFEL/Math</code> library are marked as <code>noexcept</code> which may allow more aggressive optimisation by the compiler.</p>
<h2 data-number="2.2" id="overview-of-the-new-design-of-the-tfelmath-library"><span class="header-section-number">2.2</span> Overview of the new design of the TFEL/Math library</h2>
<p>This overview of Version 4.0 of the <code>TFEL/Math</code> library mostly focuses on two important features:</p>
<ul>
<li>The <code>TFEL/Math</code> library provides a linear algebra engine with mathematical objects and operations on those objets required to express the constitutive equations in an efficient and natural manner, i.e. as close as possible to the mathematical expressions. Section 2.2.1 is devoted to describe this linear algebra engine.</li>
<li>The <code>TFEL/Math</code> library provides efficient and robust non linear solvers for small sized problems described in Section 2.2.2.</li>
</ul>
<h3 data-number="2.2.1" id="sec:tfel_math:math_objects"><span class="header-section-number">2.2.1</span> Mathematical objects</h3>
<p>The mathematical objects provided by the <code>TFEL/Math</code> library are based on scalar values which can be standard <code>C++</code> numeric types (<code>float</code>, <code>double</code> or <code>long double</code>), or so-called quantities, i.e. an object describing a value with an unit. The later allows to distinguish physical quantities such as a strain from a stress and prevent illegal operations between them. Quantities are described in depth in Section 2.2.1.1.</p>
<p>The <code>TFEL/Math</code> library then introduces some mathematical objects of rank 1, i.e. objects which can be stored in a contiguous memory location and access by a single index, such as:</p>
<ul>
<li>fixed size vectors (implemented by the <code>tvector</code> class)</li>
<li>symmetric tensors (implemented by the <code>stensor</code> class)</li>
<li>unsymmetric tensors (implemented by the <code>tensor</code> class)</li>
</ul>
<p>Higher order objects are then defined as the derivatives of objects of lower ranks. For instance, the derivative of a symmetric tensor with respect to an unsymmetric tensor is implemented by the <code>t2tost2</code> class. The latter can also be viewed a linear application between unsymmetric tensor and symmetric tensor or as a fourth order tensor. In practice, there are four kind of fourth order tensor defined in the library respectively implemented by the <code>st2tost2</code>, <code>st2tot2</code>, <code>t2tost2</code>, and <code>t2tot2</code> classes.</p>
<p>Currently only tensors up to the fourth order are specialized which allows to provide some specific features.</p>
<p>Higher order tensors may be represented by a generic class which represent derivatives of two mathematical objects. Currently, the number of operations allowed by this generic class is rather limited and will be extended as needed in future versions.</p>
<p>The main concepts behing the implementation of the mathematical objects are described in Section 2.2.1.2.</p>
<h4 data-number="2.2.1.1" id="sec:tfel_math:quantities"><span class="header-section-number">2.2.1.1</span> Quantities</h4>
<p>Quantities were introduced in <code>TFEL/Math</code> following ideas of the book D. Abrahams and A. Gurstovoy <span class="citation" data-cites="abrahams_cxx_2004">[<a href="#ref-abrahams_cxx_2004" role="doc-biblioref">1</a>]</span> to allow dimensional analysis at compile time. Basically, a quantity is the combinaison of a value and an unit. The type of the value is called the base type of the quantity.</p>
<p>The unit is encrypted in a type called <code>Unit</code> so that the <code>C++</code> type-system can be used to detect at compile-time (without runtime-checks) if operations are legal. According to the International System of Units (SI), an unit is decomposed along <span class="math inline">\(7\)</span> basic units which are the mass (kg), the length (l), the time (s), the electric current (A), the temperature (K), the luminous intensity (cd) and the amount of substance (mole). To be able to describe fractional unit, such as the fracture toughness which is has the unit of a stress times the square root of a length, the <code>Unit</code> class is parametrized by <span class="math inline">\(14\)</span> integers. The <code>TFEL/Math</code> library provides some convenient aliases for the most common units.</p>
<p>The <code>NoUnit</code> unit is a special case where all those integers are set to 0 for the numerator parts and 1 (by convention) for the denomiator parts.</p>
<h5 data-number="2.2.1.1.1" id="the-qt-class"><span class="header-section-number">2.2.1.1.1</span> The <code>qt</code> class</h5>
<p>A quantity is presented by the <code>qt</code> class which is parametrized by a class describing the unit and a numeric base type (generally <code>float</code>, <code>double</code> or <code>long double</code>) which stores the value of the quantity. By default, the <code>double</code> type is used. This class can be used as follows:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> qt&lt;Mass&gt; m1(<span class="fl">100.</span>);</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> qt&lt;Mass&gt; m2(<span class="fl">100.</span>);</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> qt&lt;Mass&gt; m3 = m1 + <span class="fl">0.5</span> * m2;</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> qt&lt;Acceleration&gt; a(<span class="dv">2</span>);</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> qt&lt;Force&gt; f = m1 * a;</span></code></pre></div>
<p>The previous code sample illustrates how to declare a new quantity and how to perform operations on quantities. It also highlights that those operations can be used in a <code>constexpr</code> context, i.e. that at compile-time.</p>
<h5 data-number="2.2.1.1.2" id="the-qt_ref-and-const_qt_ref-classes"><span class="header-section-number">2.2.1.1.2</span> The <code>qt_ref</code> and <code>const_qt_ref</code> classes</h5>
<p>The library also provides two wrapper classes called <code>qt_ref</code> and <code>const_qt_ref</code> which allows to wrap a value into an object which acts respectively as an mutable an immutable quantity, as illustrated in the following code sample:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> eps = <span class="fl">1e-14</span>;</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="kw">auto</span> value = [] ()<span class="kw">constexpr</span> {</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a> <span class="kw">constexpr</span> qt&lt;Mass&gt; m(<span class="fl">100.</span>);</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a> <span class="kw">constexpr</span> qt&lt;Acceleration&gt; a(<span class="dv">2</span>);</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a> <span class="kw">auto</span> vf = <span class="dt">double</span>{};</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a> <span class="kw">auto</span> f = qt_ref&lt;Force&gt;(vf);</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a> f = m * a;</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a> <span class="cf">return</span> vf;</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>}();</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>TFEL_TESTS_STATIC_ASSERT(<span class="bu">std::</span>abs(value - <span class="fl">200.</span>) &lt; eps);</span></code></pre></div>
<p>While a bit contrieved, this example shows that the <code>qt_ref</code> class can also be used in a <code>constexpr</code> context.</p>
<p>The <code>qt_ref</code> and <code>const_qt_ref</code> classes are parametrized by two template parameters which describe respectively the unit and a numeric base type.</p>
<p>The <code>qt_ref</code> and <code>const_qt_ref</code> classes are essentially used to build views of mathematical objects from a raw memory area, as described in Section 2.2.1.7.</p>
<h5 data-number="2.2.1.1.3" id="the-quantity-class"><span class="header-section-number">2.2.1.1.3</span> The <code>Quantity</code> class</h5>
<p>For the sake of simplicity, the <code>qt</code>, <code>qt_ref</code> and <code>const_qt_ref</code> were described as classes. This is not actually the case in the current implementation which defines them through type aliases to a more general <code>Quantity</code> class which is parametrized by three template arguments: the unit, the basic numeric type and a third argument describing how the value associated with the quantity is handled.</p>
<h5 data-number="2.2.1.1.4" id="operations-on-quantities"><span class="header-section-number">2.2.1.1.4</span> Operations on quantities</h5>
<p>Common operations on quantities, such as additions, substraction, multiplications, division and negations are supported.</p>
<p>Scaling and multiplication by a standard numeric value works as expected, as demonstrated by the following code:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> qt&lt;Mass&gt; m(<span class="fl">100.</span>);</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co">// multiplication by a raw numeric type</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> m2 = <span class="fl">2.</span> * m;</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">// scaling</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>m2 *= <span class="dv">4</span>;</span></code></pre></div>
<p>A quantity with unit <code>NoUnit</code> is implicitly convertible to its base type:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> qt&lt;NoUnit&gt; q(<span class="fl">1.2</span>);</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">constexpr</span> <span class="dt">double</span> q_value = q;</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> cos_q = <span class="bu">std::</span>cos(q);</span></code></pre></div>
<p>The latter line shows that standard mathematical functions can be called directly.</p>
<p>Fractional power of a quantity are supported through the <code>power</code> function as follows:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">// declaration of a stress symmetric tensor</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>stensor&lt;<span class="dv">3</span><span class="bu">u</span>,qt&lt;Stress&gt;&gt; s;</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="co">// contracted product of s which has the unit</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co">// of the square of a stress</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> s2 = s|s;</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="co">// norm of s</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> norm = power&lt;<span class="dv">1</span>,<span class="dv">2</span>&gt;(s2);</span></code></pre></div>
<blockquote>
<p><strong>About the <code>power</code> function</strong></p>
<p>The <code>power</code> function is a very convenient function which takes two template parameters <code>N</code> and <code>D</code> defining the exponent as the fraction <span class="math inline">\(N/D\)</span>. The default value of <code>D</code> is <span class="math inline">\(1\)</span>, so the following syntax is valid:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> v = power&lt;<span class="dv">3</span>&gt;(<span class="dv">12</span>);</span></code></pre></div>
<p>which computes <span class="math inline">\(12^{3}\)</span>.</p>
<p>The <code>power</code> function is optimised for the following values of the denominator:</p>
<ul>
<li><span class="math inline">\(1\)</span>: In this case, the <code>Nth</code> power of the argument is computed using by multiplications if <span class="math inline">\(N\)</span> is positive. If <span class="math inline">\(N\)</span> is negative, the <code>Nth</code> power of the inverse of the argument is computed.</li>
<li><span class="math inline">\(2\)</span>: In this case, the square root of the <code>Nth</code> power of the argument is computed using the <code>std::sqrt</code> function.</li>
<li><span class="math inline">\(3\)</span>: In this case, the square root of the <code>Nth</code> power of the argument is computed using the <code>std::cbrt</code> function.</li>
</ul>
</blockquote>
<h4 data-number="2.2.1.2" id="sec:tfel_math:tensorial_objects"><span class="header-section-number">2.2.1.2</span> A generic framework to build tensorial-like objects</h4>
<p>This section first introduces the notion of array policy and indexing policy which describes respectively how data are handled (stored) and how those data are accesssed.</p>
<p>Common objects of rank <span class="math inline">\(1\)</span> are then defined, including tiny vectors, symmetric tensors and unsymmetric tensors. Higher order objects are defined recursively as derivative of objects of lower ranks.</p>
<h5 data-number="2.2.1.2.1" id="description-of-the-arraypolicy-concept"><span class="header-section-number">2.2.1.2.1</span> Description of the <code>ArrayPolicy</code> concept</h5>
<p>Array policies describes how data are handled and accessed. For the latter, the description of the access partern is delegated to an indexing policy which will be described later in Section 2.2.1.3. Thus, this section mostly focuses on how array policies describe how the data are handled.</p>
<p>A class matching the <code>ArrayPolicy</code> concept must provide:</p>
<ul>
<li>An alias to a type called <code>value_type</code> which corresponds to the logical type hold by the array (see below).</li>
<li>An alias to a type called <code>const_value_type</code> which corresponds to a constant value to a an object of the logical type hold by the array.</li>
<li>An alias to a type called <code>storage_type</code> which is the type actually stored in memory.</li>
<li>An alias to a type called <code>reference</code> which is the type returned by the non-constant access operators of the array. A object of the <code>reference</code> type must be convertible and assignable to a <code>value_type</code> object and provide the following operators:
<ul>
<li><code>operator=(const other_type&amp;)</code></li>
<li><code>operator+=(const other_type&amp;)</code></li>
<li><code>operator-=(const other_type&amp;)</code></li>
<li><code>operator*=(const other_type&amp;)</code></li>
<li><code>operator/=(const other_type&amp;)</code></li>
</ul>
where <code>other_type</code> denotes for each operator a type for which the considered operator in the <code>value_type</code> class is valid.</li>
<li>An alias to a type calle <code>const_reference</code> which is the type returned by the constant access operators of the array. A object of the <code>const_reference</code> type must be convertible and assignable to a <code>value_type</code> object.</li>
<li>A static function called <code>make_const_reference</code> which turns a a constant reference to a <code>storage_type</code> object into a <code>const_reference</code> object.</li>
<li>A static function called <code>make_reference</code> which turns a reference to a <code>storage_type</code> object into a <code>reference</code> object.</li>
<li>An alias type a type called <code>IndexingPolicy</code> which refers an indexing policy. The <code>IndexingPolicy</code> concept is described in depth in Section 2.2.1.3.</li>
</ul>
<p>It is worth illustrating those concepts in two commonly used cases:</p>
<ul>
<li>Standard array policies.</li>
<li>Array policies used by views.</li>
</ul>
<h5 data-number="2.2.1.2.2" id="standard-array-policies"><span class="header-section-number">2.2.1.2.2</span> Standard array policies</h5>
<p>The <code>StandardArrayPolicy</code> class is based in the following statements:</p>
<ul>
<li><code>storage_type</code> is the same as <code>value_type</code>.</li>
<li><code>reference</code> is the same as as <code>value_type&amp;</code>.</li>
<li><code>const_reference</code> is the same as as <code>const value_type&amp;</code>.</li>
<li><code>make_reference</code> is trivial an only returns a const reference to the stored value.</li>
<li><code>make_const_reference</code> is trivial an only returns an immutable reference to the stored value.</li>
</ul>
<p>Standard array policies are which are used to implement concrete mathematical objects such as <code>tvector</code>, <code>tmatrix</code>, <code>stensor</code>, <code>tensor</code>, etc.</p>
<blockquote>
<p><strong>Note</strong></p>
<p>Contrary to view array policies described in the next paragraph, the <code>storage_type</code> is not restricted to be a basic numeric type (<code>float</code>, <code>double</code> or <code>long double</code>).</p>
</blockquote>
<h5 data-number="2.2.1.2.3" id="view-array-policies"><span class="header-section-number">2.2.1.2.3</span> View array policies</h5>
<p>Views generally maps a memory location made of basic numeric types (<code>float</code>, <code>double</code> or <code>long double</code>) to a mathematical objects.</p>
<p>To support quantities, the type stored (<code>storage_type</code>) must be distinguished from the logical type of the mapped object (<code>value_type</code>). The reference type is then a simple wrapper around a numeric value which acts as the desired quantity.</p>
<p>For example, let us consider the case of a view mapping a stress symmetric tensor from an array of double precision numbers. In this case, <code>storage_type</code> is the base type of <code>value_type</code>, so:</p>
<ul>
<li><code>storage_type</code> is an alias to <code>double</code>.</li>
<li><code>value_type</code> is an alias to <code>qt&lt;Stress, double&gt;</code>.</li>
<li><code>reference</code> is an alias to <code>qt_ref&lt;stress, double&gt;</code>.</li>
<li><code>const_reference</code> is an alias to <code>const_qt_ref&lt;stress, double&gt;</code>.</li>
<li><code>make_reference</code> simply builds a reference for the address of the stored value. So does <code>make_const_reference</code>.</li>
</ul>
<p>This mostly describes the implementation of the <code>ViewArrayPolicy</code> class.</p>
<p>However, those rules only applies when <code>storage_type</code> is a quantity. Otherwise, i.e. when <code>value_type</code> is a basic numeric type, the implementation of the <code>ViewArrayPolicy</code> class is equivalent to the <code>StandardArrayPolicy</code> class.</p>
<h4 data-number="2.2.1.3" id="sec:tfel_math:indexing_policies"><span class="header-section-number">2.2.1.3</span> Description of the <code>IndexingPolicy</code> concept</h4>
<p>A class matching the <code>IndexingPolicy</code> concept must provide:</p>
<ul>
<li>An alias to a type called <code>size_type</code> to the type used to index data.</li>
<li>An alias to a type called <code>RowMajorIndexingPolicy</code> which can be used to import data from raw <code>C</code> pointers.</li>
<li>A static member data called <code>arity</code> of type <code>size_type</code> which describes the number of indices required to describe the object.</li>
<li>A static boolean data member called <code>hasFixedSizes</code>. If this data member is <code>true</code>, the class must be stateless, i.e. empty.</li>
<li>A static boolean data member called <code>areDataContiguous</code> which states if the data are continous</li>
<li>A member function called <code>size</code> which takes no argument returning the number of data values accessible by the indexing policy. This member function must be <code>constexpr</code> if <code>hasFixedSizes</code> is true.</li>
<li>A member function called <code>size</code> which takes a <code>size_type</code> argument returning range in the given dimension. This member function must be <code>constexpr</code> if <code>hasFixedSizes</code> is true.</li>
<li>A member function called <code>getUnderlyingArrayMinimalSize</code> which returns the minimal size of an array required by the indexing policy. This member function must be <code>constexpr</code> if <code>hasFixedSizes</code> is true.</li>
<li>A member function called <code>getIndex</code> which returns the memory offset of an element of the object with respect to the location of the first element of the object. The number of argument of this method must be equal to the <code>arity</code> member. This member function must be <code>constexpr</code> if <code>hasFixedSizes</code> is true.</li>
</ul>
<h5 data-number="2.2.1.3.1" id="an-example-of-indexing-policy"><span class="header-section-number">2.2.1.3.1</span> An example of indexing policy</h5>
<figure>
<img src="img/tfel-math/matrix_row_major.svg" id="fig:tfel_math:matrix_row_major" style="width:90.0%" alt="Figure 1: Storage of the elements of a matrix using the row-major format" /><figcaption aria-hidden="true">Figure 1: Storage of the elements of a matrix using the row-major format</figcaption>
</figure>
<p>Let us consider an <span class="math inline">\(N\,\times\,M\)</span> matrix stored in a contiguous memory location using the row major format, i.e. all elements of the same row are stored continuously as depicted on Figure 1. The position of <span class="math inline">\(i,j\)</span> element from the start of the memory area is given by <span class="math inline">\(i \, M + j\)</span>.</p>
<p>Let us now consider a view on a <span class="math inline">\(L\,\times\,K\)</span> submatrix in a which starts at row <span class="math inline">\(i0\)</span> and column <span class="math inline">\(j0\)</span>. The position of the <span class="math inline">\(i,j\)</span> element of the submatrix in the matrix is also given by <span class="math inline">\(i \, M + j\)</span> if we start from the first element of the submatrix.</p>
<p>This formula is implemented by the <code>getIndex</code> method of the <code>FixedSizeRowMajorMatrixIndexingPolicy</code> which is used by many classes provide by the library, such as <code>tmatrix</code> (matrices whose size is known at compile time), <code>st2tost2</code>, <code>t2tot2</code>, etc.. and views to those objects in a matrix.</p>
<h5 data-number="2.2.1.3.2" id="higher-order-indexing-policies-for-fixed-size-mathematical-objects"><span class="header-section-number">2.2.1.3.2</span> Higher order indexing policies for fixed-size mathematical objects</h5>
<p>Let us consider an mathematical object <span class="math inline">\(o_{3}\)</span> resulting from the derivation of an mathematical object <span class="math inline">\(o_{1}\)</span> of arity <span class="math inline">\(a_{1}\)</span> with respect to an mathematical object <span class="math inline">\(o_{2}\)</span> of arity <span class="math inline">\(a_{2}\)</span>. <span class="math inline">\(o_{3}\)</span> has an arity of <span class="math inline">\(a_{1}+a_{2}\)</span>.</p>
<p>The storage of those objects are described respectively by the indexing policies <span class="math inline">\(p_{1}\)</span> and <span class="math inline">\(p_{2}\)</span>. We assume that the object <span class="math inline">\(o_{1}\)</span> can be stored in a memory area of size <span class="math inline">\(s_{1}\)</span> and that the object <span class="math inline">\(o_{2}\)</span> can be stored in a memory area of size <span class="math inline">\(s_{2}\)</span>. Then the object <span class="math inline">\(o_{3}\)</span> can be stored in a memory location <span class="math inline">\(s_{1}\,s_{2}\)</span>.</p>
<p>Then, an indexing policy <span class="math inline">\(p_{3}\)</span> suitable to describe <span class="math inline">\(o_{3}\)</span> may compute the position of the derivative of the component <span class="math inline">\(o_{1}{\left(i_{0},\ldots,i_{a_{1}-1}\right)}\)</span> with respect to the component <span class="math inline">\(o_{2}{\left(j_{0},\ldots,j_{a_{2}-1}\right)}\)</span> is given by:</p>
<p><span class="math display">\[
p_{3}{\left(i_{0},\ldots,i_{a_{1}-1},j_{0},\ldots,j_{a_{2}-1}\right)}=
p_{1}{\left(i_{0},\ldots,i_{a_{1}-1}\right)}\,s_{2}+p_{2}{\left(j_{0},\ldots,j_{a_{2}-1}\right)}
\]</span></p>
<p>This choice is implemented in the <code>FixedSizeIndexingPoliciesCartesianProduct</code> class which is used to by the <code>FixedSizeArrayDerivative</code> class to describe derivatives of two arbitrary mathematical objects.</p>
<h4 data-number="2.2.1.4" id="low-rank-mathematical-objects"><span class="header-section-number">2.2.1.4</span> Low rank mathematical objects</h4>
<p>The library is based on a few low rank mathematical objects:</p>
<ul>
<li><code>tvector</code>: a tiny vector of fixed size. This template class is parametrized by the size of the vector and the value hold.</li>
<li><code>stensor</code>: a symmetric tensor. This template class is parametrized by the space dimension and the scalar type.</li>
<li><code>tensor</code>: a unsymmetric tensor. This template class is parametrized by the space dimension and the scalar type.</li>
</ul>
<p>All those objects are represented by objects of rank one using a vector-like notations. For example, a <span class="math inline">\(3D\)</span> symmetric tensor is represented as follows:</p>
<p><span class="math display">\[
  \underline{s}=
  \begin{pmatrix}
    s_{\,11}\quad
    s_{\,22}\quad
    s_{\,33}\quad
    \sqrt{2}\,s_{\,12}\quad
    \sqrt{2}\,s_{\,13}\quad
    \sqrt{2}\,s_{\,23}
  \end{pmatrix}^{T}
\]</span></p>
<p>This notations has the property that the contracted product of two symmetric tensors is the scalar product of this vector form (hence the <span class="math inline">\(\sqrt{2}\)</span>).</p>
<p>In a similar manner, an unsymmetric tensor is represented as follows: <span class="math display">\[
  \underline{s}=
  \begin{pmatrix}
    s_{\,11}\quad
    s_{\,22}\quad
    s_{\,33}\quad
    s_{\,12}\quad
    s_{\,21}\quad
    s_{\,13}\quad
    s_{\,31}\quad
    s_{\,23}\quad
    s_{\,32}
  \end{pmatrix}^{T}
\]</span></p>
<h4 data-number="2.2.1.5" id="higher-order-objects-defined-as-derivatives"><span class="header-section-number">2.2.1.5</span> Higher order objects defined as derivatives</h4>
<p>The library provides a generic class called <code>FixedSizeArrayDerivative</code> which allows to create higher order objects as being the derivative of two objects of lowest ranks.</p>
<p>This class is currently very limited but will be extended in future versions of the library.</p>
<h5 data-number="2.2.1.5.1" id="the-case-of-fourth-order-tensors"><span class="header-section-number">2.2.1.5.1</span> The case of fourth order tensors</h5>
<p>Fourth order tensors can be defined as derivatives of two tensors or as linear mappings from the second order tensors to second order tensors.</p>
<p>As there are two kinds of second order tensors (i.e. symmetric and non symmetric tensors), there are four kinds of fourth order tensors defined in the <code>TFEL/Math</code> library, which satisfy the following concepts:</p>
<ul>
<li><code>ST2toST2Concept</code>: linear mapping from symmetric tensors to symmetric tensors.</li>
<li><code>ST2toT2Concept</code>: linear mapping from symmetric tensors to non symmetric tensors.</li>
<li><code>T2toST2Concept</code>: linear mapping from non symmetric tensors to symmetric tensors.</li>
<li><code>T2toT2Concept</code>: linear mapping from non symmetric tensors to non symmetric tensors.</li>
</ul>
<p>An end user will mostly use the following implementations of those concepts: <code>st2tost2</code>, <code>st2tot2</code>, <code>t2tost2</code> and <code>t2tot2</code> respectively. Those classes have the following template arguments:</p>
<ul>
<li>The space dimension (<code>1</code>, <code>2</code> or <code>3</code>).</li>
<li>The type used to perform the computation.</li>
</ul>
<h5 data-number="2.2.1.5.2" id="the-tmatrix-case"><span class="header-section-number">2.2.1.5.2</span> The <code>tmatrix</code> case</h5>
<p>A fixed size matrix, implemented by the <code>tmatrix</code> class can be seen as the derivative of a tiny tensor with respect to a tiny vecor.</p>
<h5 data-number="2.2.1.5.3" id="the-derivative_type-metafunction"><span class="header-section-number">2.2.1.5.3</span> The <code>derivative_type</code> metafunction</h5>
<p>The <code>TFEL/Math</code> library provides a very convenient type alias called <code>derivative_type</code> which automatically selects the correct type as the derivative of two objects of fixed sizes. This alias also works with scalars. This type alias takes quantities into account if required.</p>
<p>Here are a few examples:</p>
<ul>
<li><code>derivative_type&lt;double, double&gt;</code> is an alias to <code>double</code>.</li>
<li><code>derivative_type&lt;qt&lt;Stress&gt;, double&gt;</code> is an alias to <code>qt&lt;Stress&gt;</code>.</li>
<li><code>derivative_type&lt;qt&lt;Stress&gt;, qt&lt;Time&gt;&gt;</code> is an alias to <code>qt&lt;StrainRate&gt;</code>.</li>
<li><code>derivative_type&lt;tvector&lt;2u, double&gt;, tvector&lt;3u, double&gt;&gt;</code> is an alias to <code>tmatrix&lt;2u, 3u, double&gt;</code>.</li>
<li><code>derivative_type&lt;stensor&lt;2u, double&gt;, stensor&lt;2u, double&gt;&gt;</code> is an alias to <code>st2tost2&lt;2u, double&gt;&gt;</code>.</li>
<li><code>derivative_type&lt;stensor&lt;2u, double&gt;, tvector&lt;3u, double&gt;&gt;</code> is an alias to <code>FixedSizeArray</code> <code>Derivative&lt;stensor&lt;2u, double&gt;, tvector&lt;3u,   double&gt;&gt;</code>.</li>
</ul>
<h4 data-number="2.2.1.6" id="sec:tfel_math:expression_templates"><span class="header-section-number">2.2.1.6</span> Expressions templates</h4>
<p>One may expect that the addition of two vector results in a new vector. This naive approach may lead to poor performances, due to temporaries objects and data copying <span class="citation" data-cites="veldhuizen_techniques_1999">[<a href="#ref-veldhuizen_techniques_1999" role="doc-biblioref">2</a>]</span>.</p>
<p>Expression templates is a C++ template metaprogramming technique which introduces additional classes which represent the actions to be performed on some objects and lazily delay the execution of those actions until the result is explicitly requested.</p>
<p>The objects of those classes are placeholders, also called handlers within the library, that are meant to be assigned to an object whose type is the expected result of the operation treated.</p>
<p>To illustrate this technique, let us consider the addition of three vectors <span class="math inline">\(\vec{a}\)</span>, <span class="math inline">\(\vec{b}\)</span> and <span class="math inline">\(\vec{c}\)</span> and its assignment to a vector <span class="math inline">\(\vec{d}\)</span>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>d = a + b + c;</span></code></pre></div>
<p>The addition of the vectors <span class="math inline">\(\vec{a}\)</span> and <span class="math inline">\(\vec{b}\)</span> produces an intermediate object <span class="math inline">\(\vec{e1}\)</span> of type <code>Expr1</code> which keeps a reference to those two vectors. Similarly, the addition of those three vectors defines another object <span class="math inline">\(\vec{e2}\)</span> of type <code>Expr2</code> which stands for the addition of <span class="math inline">\(\vec{e1}\)</span> and the vector <span class="math inline">\(\vec{c}\)</span>.</p>
<figure>
<img src="img/tfel-math/expression_templates.svg" id="fig:tfel_math:expression_templates" style="width:50.0%" alt="Figure 2: Application of the expression templates technique to the addition of three vectors." /><figcaption aria-hidden="true">Figure 2: Application of the expression templates technique to the addition of three vectors.</figcaption>
</figure>
<p>Figure 2 shows how the access operator of <code>e2</code> is implemented. The assignment of an object of type <code>Expr2</code> to a vector <code>d</code> is implemented as a standard <code>for</code> loop:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(<span class="dt">size_type</span> i=<span class="dv">0</span>;i!=d.size();++i){</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  d(i) = e2(i);</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>The temporary objects <code>e1</code> and <code>e2</code> are meant to be eliminated by the compiler optimisation process. Thanks to function inlining, the compiler is able to produce a code that is equivalent to what would have been obtained with the following instructions:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(<span class="dt">size_type</span> i=<span class="dv">0</span>;i!=d.size();++i){</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  d[i] = a[i] + b[i] + c[i];</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<blockquote>
<p><strong>About loop unrolling</strong></p>
<p>When dealing with objects whose size is known at compile-time, the <code>TFEL/Math</code> library also performs an additional optimisation technique known as <em>loop unrolling</em>. For example, if <span class="math inline">\(\underline{a}\)</span>, <span class="math inline">\(\underline{b}\)</span> and <span class="math inline">\(\underline{c}\)</span> are three <span class="math inline">\(1D\)</span> symmetric tensors, the code:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>c = a + <span class="dv">2</span> * b;</span></code></pre></div>
<p>is equivalent to:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>c[<span class="dv">0</span>] = a[<span class="dv">0</span>] + <span class="dv">2</span> * b[<span class="dv">0</span>];</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>c[<span class="dv">1</span>] = a[<span class="dv">1</span>] + <span class="dv">2</span> * b[<span class="dv">1</span>];</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>c[<span class="dv">2</span>] = a[<span class="dv">2</span>] + <span class="dv">2</span> * b[<span class="dv">2</span>];</span></code></pre></div>
</blockquote>
<h5 data-number="2.2.1.6.1" id="the-eval-function"><span class="header-section-number">2.2.1.6.1</span> The <code>eval</code> function</h5>
<p>One possible caveat of the expression template technique can be illustrated by the following example. Let us consider two vectors <code>a</code> and <code>b</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>a[<span class="dv">0</span>] = <span class="dv">1</span>;</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>b[<span class="dv">0</span>] = <span class="dv">2</span>;</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> c = a + b;</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co">// Here, c[0] evaluates to 3, as expected.</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>a[<span class="dv">0</span>] = <span class="dv">2</span>;</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co">// However, at this stage, c[0] evaluates to 4 !</span></span></code></pre></div>
<p>Another caveat is that is sometimes more efficient to evaluate the result of an operation once and use the result of this evaluation rather than performing the evaluation of the operation several times.</p>
<p>To avoid those two caveats, the <code>eval</code> function allows the evaluation of an expression, as follows:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> c = eval(a + b);</span></code></pre></div>
<h4 data-number="2.2.1.7" id="sec:tfel_math:views"><span class="header-section-number">2.2.1.7</span> Views</h4>
<p>Views allows to map memory area to mathematical objets.</p>
<blockquote>
<p><strong>Typical usage of views in <code>MFront</code></strong></p>
<p>A typical usage of views is given by the example of the integration of a behaviour using an implicit scheme. In such a scheme, a non linear solver tries to determine the increments <span class="math inline">\(\Delta\,Y\)</span> of a set of internal state variables packed in a vector <span class="math inline">\(Y\)</span> which are the zero of residual denoted <span class="math inline">\(F\)</span>. The derivative of the residual <span class="math inline">\(F\)</span> with respect to <span class="math inline">\(\Delta\,Y\)</span> is called the jacobian and is denoted <span class="math inline">\(J\)</span>.</p>
<p>If one considers a simple plastic law with isotropic hardening, the vector of internal state variables typically contains the elastic strain, a symmetric tensor, and the equivalent plastic strain, a scalar.</p>
<p>In the general case, the vector of internal state variables, the residual and the jacobian can be decomposed as follows:</p>
<p><span class="math display">\[
Y=
\begin{pmatrix}
 y_{1} \\
 \vdots \\
 y_{i} \\
 \vdots \\
 y_{n} \\
\end{pmatrix}
\quad\quad
F=
\begin{pmatrix}
 f_{y_{1}} \\
 \vdots \\
 f_{y_{i}} \\
 \vdots \\
 f_{y_{n}} \\
\end{pmatrix}
\quad\quad
J = {\displaystyle \frac{\displaystyle \partial F}{\displaystyle \partial \Delta\,Y}} =
\begin{pmatrix}
  {\displaystyle \frac{\displaystyle \partial f_{y_{1}}}{\displaystyle \partial \Delta\,y_{1}}} &amp; \ldots &amp; \ldots &amp; \ldots &amp; \ldots \\
  \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
  \vdots &amp; \vdots &amp; {\displaystyle \frac{\displaystyle \partial f_{y_{i}}}{\displaystyle \partial \Delta\,y_{j}}} &amp; \vdots &amp; \vdots \\
  \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\
  \ldots &amp; \ldots &amp; \ldots &amp; \ldots &amp; {\displaystyle \frac{\displaystyle \partial f_{y_{N}}}{\displaystyle \partial \Delta\,y_{N}}} \\
\end{pmatrix}
\]</span></p>
<p><code>MFront</code> automatically define views to the objects <span class="math inline">\(y_{i}\)</span>, <span class="math inline">\(f_{y_{i}}\)</span>, <span class="math inline">\({\displaystyle \frac{\displaystyle \partial f_{y_{i}}}{\displaystyle \partial \Delta\,y_{j}}}\)</span> which allows to compute the residual blocks and the jacobian blocks in a very intuitive ways using tensorial operations. Hence, the user never manipulate directly the vectors <span class="math inline">\(Y\)</span>, <span class="math inline">\(\Delta\,Y\)</span> and <span class="math inline">\(F\)</span> nor the jacobian matrix <span class="math inline">\(J\)</span> but views which acts as tensorial objects.</p>
</blockquote>
<h5 data-number="2.2.1.7.1" id="the-map-function"><span class="header-section-number">2.2.1.7.1</span> The <code>map</code> function</h5>
<p>The <code>map</code> function is a small utility function which simplifies the creation of views from either raw pointers or from tiny vectors (i.e. objects of type <code>tvector</code>).</p>
<p>For example, Listing lst. 4 shows how a vector containing the elastic strain and the equivalent plastic strain can be decomposed by blocks. This decomposition is illustrated on Figure 3.</p>
<div id="lst:tfel_4.0:view" class="listing cxx">
<p>Listing 4: Usage of the `map` function</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> Y = tvector&lt;<span class="dv">7</span>, <span class="dt">double</span>&gt;{<span class="dv">0</span>};</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> eel = map&lt;stensor&lt;<span class="dv">3</span><span class="bu">u</span>, <span class="dt">double</span>&gt;&gt;(Y);</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span>&amp; p = Y[<span class="dv">6</span>];</span></code></pre></div>
</div>
<figure>
<img src="img/tfel-math/view.svg" id="fig:tfel_4.0:view" style="width:75.0%" alt="Figure 3: “Exemple of decomposition by blocks of a memory area using views”" /><figcaption aria-hidden="true">Figure 3: “Exemple of decomposition by blocks of a memory area using views”</figcaption>
</figure>
<p>The <code>map</code> function allows to define offset at compile-time: this allows to checks at compile-time that the memory area is large enough to store the mapped object when mapping a fixed size object (i.e. an object whose size is known at compile-time) from a memory area hold by a tiny vector.</p>
<h5 data-number="2.2.1.7.2" id="the-map_array-function"><span class="header-section-number">2.2.1.7.2</span> The <code>map_array</code> function</h5>
<p>The <code>map_array</code> returns an object which acts like a fixed size of mathematical objects. It takes one template argument which describes an arry of of mathematical objects. This template argument is used to determine the number of object mapped and the kind of object mapped.</p>
<p>It can be used as follows:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> a = map_array&lt;tvector&lt;<span class="dv">2</span><span class="bu">u</span>, stensor&lt;<span class="dv">2</span><span class="bu">u</span>, <span class="dt">double</span>&gt;&gt;&gt;(ptr);</span></code></pre></div>
<p>where <code>ptr</code> is a pointer to a suitable memory location.</p>
<h5 data-number="2.2.1.7.3" id="the-map_derivative-function"><span class="header-section-number">2.2.1.7.3</span> The <code>map_derivative</code> function</h5>
<p>The <code>map_derivative</code> function allows to create a view of the derivative of two math objects in a matrix as illustrated by the following example which create a view of the object resulting of the derivation of a symmetric stress tensor with respect to a scalar whose first element is located in element <span class="math inline">\(1,1\)</span> of the matrix:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> r = tmatrix&lt;<span class="dv">5</span>, <span class="dv">3</span>&gt;{<span class="dv">0</span>};</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>map_derivative&lt;<span class="dv">1</span>, <span class="dv">1</span>, stensor&lt;<span class="dv">2</span><span class="bu">u</span>, qt&lt;Stress&gt;&gt;, <span class="dt">double</span>&gt;(r) = stensor&lt;<span class="dv">2</span><span class="bu">u</span>, Stress&gt;::Id();</span></code></pre></div>
<p>The result of this operation is the matrix:</p>
<p><span class="math display">\[
\begin{pmatrix}
  0 &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; 0 \\
  0 &amp; 1 &amp; 0 \\
  0 &amp; 1 &amp; 0 \\
  0 &amp; 0 &amp; 0 \\
\end{pmatrix}
\]</span></p>
<h3 data-number="2.2.2" id="sec:tfel_math:non_linear_solvers"><span class="header-section-number">2.2.2</span> Solvers for fixed size non linear systems</h3>
<p>The <code>TFEL/Math</code> library provides several non linear solvers which are mainly used by <code>MFront</code> implicit schemes. Those solvers mostly targets systems of small size and focuse on robustness and flexibility. Each solver implements a classical algorithm by also provides several customisation points which allows to create many variants of this basic algorithms.</p>
<p>The solvers available are based on the following algorithms:</p>
<ul>
<li>The standard Newton-Raphson algorithm is implemented in the <code>TinyNewtonRaphsonSolver</code> class. This algorithm is coupled with a Powell’ dog leg step in the <code>TinyPowellDogLegNewtonRaphsonSolver</code> class.</li>
<li>The first and second Broyden algorithms, also known respectively as the good and bad Broyden algorithms are respectively implemented in the <code>TinyBroydenSolver</code> and <code>TinyBroyden2Solver</code> classes. The first Broyden algorithm is coupled with a Powell’ dog leg step in the <code>TinyPowellDogLegBroydenSolver</code> class.</li>
<li>The Levenberg-Marquardt algorithm is implemented in the <code>TinyLevenbergMarquardtSolver</code> class.</li>
</ul>
<p>Those classes implements the curiously recurring template pattern (CRTP) to avoid the use of virtual calls <span class="citation" data-cites="coplien_curiously_1995">[<a href="#ref-coplien_curiously_1995" role="doc-biblioref">3</a>]</span>. The derived class must provide a method called <code>computeResidual</code> which must compute the residual for the current estimate of the unknowns and, if required by the solver, the jacobian.</p>
<p>A typical usage of those classes is given by the following example:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> NewtonRaphsonSolver</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    : <span class="kw">public</span> tfel::math::</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>          TinyNewtonRaphsonSolver&lt;<span class="dv">2</span><span class="bu">u</span>, <span class="dt">double</span>, NewtonRaphsonSolver&gt; {</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  NewtonRaphsonSolver() {</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span>-&gt;zeros = {<span class="fl">0.</span>, <span class="fl">0.</span>};</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span>-&gt;epsilon = <span class="fl">1.e-14</span>;</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span>-&gt;iterMax = <span class="dv">20</span>;</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> solve() { <span class="cf">return</span> <span class="kw">this</span>-&gt;solveNonLinearSystem(); }</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> getCurrentEstimate() <span class="at">const</span> <span class="kw">noexcept</span> { <span class="cf">return</span> <span class="kw">this</span>-&gt;zeros; }</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">bool</span> computeResidual() <span class="kw">noexcept</span> {</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">double</span> a = <span class="fl">1.</span>;</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">constexpr</span> <span class="dt">double</span> b = <span class="fl">10.</span>;</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>&amp; x = <span class="kw">this</span>-&gt;zeros;</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>&amp; f = <span class="kw">this</span>-&gt;fzeros;</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">auto</span>&amp; J = <span class="kw">this</span>-&gt;jacobian;</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>    f = {<span class="dv">1</span> - x(<span class="dv">0</span>), <span class="dv">100</span> * (x(<span class="dv">1</span>) - x(<span class="dv">0</span>) * x(<span class="dv">0</span>))};</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>    J = {-<span class="fl">1.</span>, <span class="fl">0.</span>,  <span class="co">//</span></span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>         -<span class="dv">200</span> * x(<span class="dv">0</span>), <span class="fl">100.</span>};</span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">true</span>;</span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>  }  <span class="co">// end of computeResidual</span></span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>};  <span class="co">// end of struct NewtonRaphsonSolver</span></span></code></pre></div>
<p>which solves the non linear system:</p>
<p><span class="math display">\[
\vec{f}{\left(x,y\right)} = 
\begin{pmatrix}
0 \\
0 \\
\end{pmatrix}
\quad\text{with}\quad
\vec{f}{\left(x,y\right)} = 
\begin{pmatrix}
1-x \\
10\,{\left(y-x^{2}\right)} \\
\end{pmatrix}
\]</span></p>
<p>whose obvious root is <span class="math inline">\({\left(1,1\right)}\)</span>.</p>
<p>This previous example shows that:</p>
<ol type="1">
<li>The current estimate of the unknowns is stored in a data member called <code>zeros</code>.</li>
<li>The residual is stored in a data member called <code>fzeros</code>.</li>
<li>The jacobian is stored in a data member called <code>jacobian</code>.</li>
</ol>
<p>Those names have been chosen in the early versions of <code>MFront</code> and are kept for back-ward compatibility.</p>
<p>This section describes the generic framework used to implement those algorithms.</p>
<h4 data-number="2.2.2.1" id="the-tinynonlinearsolverbase-class"><span class="header-section-number">2.2.2.1</span> The <code>TinyNonLinearSolverBase</code> class</h4>
<p>All the available solvers are based on the <code>TinyNonLinearSolverBase</code> which provides two main methods <code>solveNonLinearSystem</code> and <code>solveNonLinearSystem2</code> for the end users and many methods that can be overloaded to customize the behaviour of the algorithm.</p>
<p>In pratice, the <code>NewtonRaphsonSolver</code> class presented in the previous example inherits from <code>TinyNewtonRaphson</code> <code>Solver&lt;2u, double, NewtonRaphsonSolver&gt;</code> which itself inherits from <code>TinyNonLinearSolverBase&lt;2u, double, NewtonRaphsonSolver&gt;</code>.</p>
<p>While a bit contrieved, this design ensures that all algorithms share the same customization points, a constraint which is not easy to enforce when relying on CRTP (compared to standard approach based on virtual calls).</p>
<p>As a consequence, the <code>TinyNewtonRaphsonSolver</code> class only implements some methods specific to the Newton-Raphson algorithm while the global algorithmic structure in handled by the <code>TinyNonLinearSolverBase</code> class.</p>
<p>More precisely, the <code>TinyNonLinearSolverBase</code> provides a method called <code>solveNonLinearSystem</code>. This method internally calls a method called <code>solveNonLinearSystem2</code> which indeed implements the core of the resolution algorithm. The <code>solveNonLinearSystem2</code> method is described in depth in Section 2.2.2.1.2.</p>
<p>The point of the <code>solveNonLinearSystem</code> is to handle failures of the resolution algorithms. The current strategy to handle those failures is described in depth in Section 2.2.2.1.3.</p>
<h5 data-number="2.2.2.1.1" id="some-data-members-of-the-tinynonlinearsolverbase-class"><span class="header-section-number">2.2.2.1.1</span> Some data members of the <code>TinyNonLinearSolverBase</code> class</h5>
<p>The <code>TinyNonLinearSolverBase</code> class provides the following data members:</p>
<ul>
<li><code>fzeros</code>: residual vector.</li>
<li><code>zeros</code>: current estimate of the unknowns.</li>
<li><code>delta_zeros</code>: last computed correction.</li>
<li><code>iter</code>: current iteration number.</li>
<li><code>is_delta_zeros_defined</code>: boolean stating if an increment of the unknowns has already been computed.</li>
<li><code>epsilon</code>: criterion value</li>
<li><code>iterMax</code>: maximum number of iterations.</li>
</ul>
<p>It is worth metionning that a few variables must be initalized, by the base class before calling this method, such as:</p>
<ul>
<li>The initial estimate of the unknowns. The method <code>processNewEstimate</code> must be called must be called one this initial estimate is known.</li>
<li>The values <code>epsilon</code> and <code>iterMax</code>, as well as other numerical parameters required by the core algorithm and declared in derived class.</li>
</ul>
<p>The <code>iter</code> and <code>has_delta_zeros</code> members are automatically initialized at the beginning of the <code>solveNonLinearSystem</code> method. This method also calls the <code>processNewEstimate</code> method.</p>
<h5 data-number="2.2.2.1.2" id="sec:tfel_math:TinyNonLinearSolverBase:solveNonLinearSystem2"><span class="header-section-number">2.2.2.1.2</span> The <code>solveNonLinearSystem2</code> method</h5>
<p>This method is called internally by the <code>solveNonLinearSystem</code> method. It could be called directly if the required initialization are performed beforehand.</p>
<p>The algorithm implemented by <code>solveNonLinearSystem2</code> method is depicted in Figure 4.</p>
<figure>
<img src="img/tfel-math/solveNonLinearSystem2.svg" id="fig:tfel_math:TinyNonLinearSolverBase:solveNonLinearSystem2" style="width:100.0%" alt="Figure 4: “Flowchart for the resolution of non linear systems proposed by the solveNonLinearSystem2 of the TinyNonLinearSolverBase class”" /><figcaption aria-hidden="true">Figure 4: “Flowchart for the resolution of non linear systems proposed by the <code>solveNonLinearSystem2</code> of the <code>TinyNonLinearSolverBase</code> class”</figcaption>
</figure>
<p>The <code>computeNewCorrection</code> is the only method that must be implemented in the derived class. It totally defines the resolution algorithm. This method thus has no default implementation.</p>
<p>This flowchart also shows that the <code>solveNonLinearSystem</code> method has many customization points which either defines the underlying algorithm and or that can be use to enhance directly affects the performance and the robustness of the algorithm:</p>
<ul>
<li><code>executeInitialisationTaskBeforeBeginningOfCoreAlgorithm</code> which is started at the start of the method. The default implementation does nothing. This method is mostly meant to be used by the derived class to initialize members specific to the resolution algorithm.</li>
<li><code>computeResidual</code>: is meant to compute the residual for the current estimate of the unknowns. This method may also compute the jacobian if required.</li>
<li><code>computeResidualNorm</code> which must computes the norm of the residual. By default, this method computes the euclidian norm of the residual. This method.</li>
<li><code>checkConvergence</code> which checks if convergence is reached. By default, this method checks if the residual norm is lower than the criterion value <code>epsilon</code>. This method can also be used to implement active-sets algorithms for non-smooth functions.</li>
<li><code>processNewCorrection</code>: this method meant to set bounds on some components of the current correction or to implement a line search along the search direction returned by the <code>computeNewCorrection</code> method.</li>
<li><code>processNewEstimate</code>: this method is meant to update variables dependant on the current estimate of the unknowns.</li>
<li>By convention, the <code>computeNewCorrection</code> method may use the following helper methods:
<ul>
<li><code>updateOrCheckJacobian</code>: This method can be used to compute the jacobian or part of the jacobian numerically. If the jacobian was computed in <code>computeResidual</code>, this method can be used to compare it to a numerical approximation.</li>
<li><code>solveLinearSystem</code>: This method can be used to solve a linear system if required. By default, an LU method with partial decomposition is used (implemented by the <code>TinyMatrixSolve</code> class).</li>
</ul></li>
</ul>
<p>The algorithm also provides methods which are meant to display informations about the state of the resolution:</p>
<ul>
<li><code>reportInvalidResidualEvaluation</code> which is called method when the evaluation of the residual failed or when the norm of the residual is not finite.</li>
<li><code>reportStandardIteration</code>: which is called once the residual is known.</li>
</ul>
<p>Note that other methods for reporting the current status of the algorithm, such as <code>reportFailure</code> and <code>reportSuccess</code> are also available but are called in the <code>solveNonLinearMethod</code>.</p>
<blockquote>
<p><strong>Usage in <code>MFront</code></strong></p>
<p>It is worth hilighting how the implicit DSL’s provided by <code>MFront</code> may override those methods:</p>
<ul>
<li>The <code>computeResidual</code> method first computes the thermodynamic forces using the code provided by the <code>@ComputeThermodynamicForces</code> code bock (or <code>@ComputeStress</code> for mechanical behaviours) and then evaluates the residual using the code given by the <code>@Integrator</code> code block and the jacobian if it is computed analytically.</li>
<li>The <code>updateOrCheckJacobian</code> method is overloaded if:
<ul>
<li>A numerical approximation of the jacobian or blocks of the jacobian are required.</li>
<li>A comparison of the analytical jacobian to a numerical approximation is required.</li>
</ul></li>
<li>The <code>checkConvergence</code> method is overloaded to take into account additional convergence checks defined in the <code>@AdditionalConvergenceChecks</code> code block. This method can be used to implement active-sets algorithms or interior points methods for multi-surface plasticity or the fixed-point method used by the <code>StandardElastoViscoplasticity</code> brick for porous viscoplasticity.</li>
<li>The <code>processNewCorrection</code> is used either to set bounds on some components of the current correction based on the physical bounds of the variables or to limit the magnitude of the corrections of some integration variables. See the <code>setMaximumIncrementValuePerIteration</code> method for integration variables or the <code>@MaximumIncrementValuePerIteration</code> keyword.</li>
<li>The <code>processNewEstimate</code> method is overloaded if some quantities depend on the current estimation of the integration variables. A typical example is given by the case of porous viscoplastic behaviours for which the elastic properties depend on the porosity.</li>
</ul>
</blockquote>
<h5 data-number="2.2.2.1.3" id="sec:tfel_math:TinyNonLinearSolverBase:solveNonLinearSystem"><span class="header-section-number">2.2.2.1.3</span> The <code>solveNonLinearSystem</code> method</h5>
<p>As highlighted by Figure 4, the <code>solveNonLinearSystem2</code> methods may fail for many reasons. A very common one is that the current estimate of the unknowns are unphysical, leading to a failure in the evaluation of the residual.</p>
<p>The <code>solveNonLinearSystem</code> method implements a simple algorithm which can be seen as a hand crafted line search method which greatly improve the robustness of the non linear solvers. When used correctly, this method may also be used to increase the performances of the non linear solvers (i.e. reduce the total number of iterations).</p>
<figure>
<img src="img/tfel-math/solveNonLinearSystem.svg" style="width:100.0%" alt="“Flowchart for the resolution of non linear systems proposed by the solveNonLinearSystem of the TinyNonLinearSolverBase class”" /><figcaption aria-hidden="true">“Flowchart for the resolution of non linear systems proposed by the <code>solveNonLinearSystem</code> of the <code>TinyNonLinearSolverBase</code> class”</figcaption>
</figure>
<p>The idea of this hand-crafted linesearch is simply to take the last correction to the unknowns and divide it by two and restart the core algorithm. In other words, the search direction is leaved unchanged, but the norm of the correction is reduced. This operation can be repeated several times to find a suitable estimate of the unknowns.</p>
<p>Of course, this only works a correction is known, i.e. if the <code>has_delta_zeros</code> flag is <code>true</code>. Otherwise, this means that the initial guess of the unknowns is incorrect. In this case, we just divide this initial guess by zero. This choice may seem arbitrary but does makes sense in most cases of <code>MFront</code> implicit schemes where the unknowns are almost always the increment of the state variables: if we divide the increments of the state variables, their estimates at the middle of the time step tends to theirs values at the beginning of the time step, which is generally physically acceptable<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p>
<blockquote>
<p><strong>Pratical importance</strong></p>
<p>While very simple, the strategy described in this section is in practice extremly powerful and can be used to easily build very robust and efficient algorithms based on physical considerations. Let us consider a few example:</p>
<ul>
<li>If one considers a plastic behaviour, one may want to reject a prediction of the stress which too largely exceeds the current estimate of the plastic limit.</li>
<li>If one considers a viscoplastic behaviour, one may want to reject a prediction of the stress which would lead to an unphysical viscoplastic strain rate. This is particularly useful with viscoplastic behaviour having an exponential sensitivity to the stress.</li>
<li>If one considers a plasic behaviour yield surface with sharp corners, such as the approximations of the Mohr-Coulomb criterion given by Abbo and Sloan <span class="citation" data-cites="Abbo1995 Nagel2016">[<a href="#ref-Abbo1995" role="doc-biblioref">4</a>, <a href="#ref-Nagel2016" role="doc-biblioref">5</a>]</span>, the solver may fail because the flow direction may oscillate between too iterations. Too solve this issue, we can simply reject iterations that lead to a large change in the flow direction.</li>
</ul>
<p>The reader may find an example of such algorithms in the case of a perfect plastic behaviour based on the Hosford stress criterion on this page of the <code>MFront</code> gallery: <a href="http://tfel.sourceforge.net/hosford.html" class="uri">http://tfel.sourceforge.net/hosford.html</a></p>
</blockquote>
<p>An important caveat to this strategy is link to the use of an active-set method to describe multi-surface plasticity. The active-set method makes <em>a priori</em> assumptions on which plastic mechanisms are active and solve the non-linear equations with those assumptions. After convergence, those assumptions are checked and some mechanisms may be activated or desactivated and the non linear solver is restarted. The activation of a plastic mechanism can lead the <code>computeResidual</code> method to fail (as described earlier, rejecting steps leading to a prediction well beyond the current plastic limit is generally a good strategy). The trouble here is that the last correction computed by the solver is very small since the algorithm had converged. Thus, the strategy implemented by the <code>solveNonLinearSystem</code> method would divide a correction that is already almost null. To avoid this caveat, <code>MFront</code> automatically resets the <code>is_delta_zeros_defined</code> member to <code>false</code>. More precisely, here is the implementation of the <code>checkConvergence</code> method when the user has defined additional convergence checks:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> checkConvergence(<span class="at">const</span> NumericType error) {</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> converged = error &lt; <span class="kw">this</span>-&gt;epsilon;</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> mfront_internals_converged = converged;</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">this</span>-&gt;additionalConvergenceChecks(converged, error);</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>((mfront_internals_converged) &amp;&amp; (!converged)){</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span>-&gt;is_delta_zeros_defined = <span class="kw">false</span>;</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h1 data-number="3" id="new-mfront-features"><span class="header-section-number">3</span> New MFront features</h1>
<h2 data-number="3.1" id="improvements-to-implicit-dsls"><span class="header-section-number">3.1</span> Improvements to implicit DSLs</h2>
<h3 data-number="3.1.1" id="new-keywords"><span class="header-section-number">3.1.1</span> New keywords</h3>
<h4 data-number="3.1.1.1" id="sec:tfel-4.0:mfront:implicit:ProcessNewCorrection"><span class="header-section-number">3.1.1.1</span> The <code>@ProcessNewCorrection</code> keyword</h4>
<p>The <code>@ProcessNewCorrection</code> keyword introduces a code block called when a new correction of the increments of the integration variables is available.</p>
<p>This method can be used to:</p>
<ul>
<li>Limit the amplitude of the correction (see also the <code>setMaximumIncrementValuePerIteration</code> method).</li>
<li>Implement a line-search algorithm.</li>
<li>Implement the decondensation step when some integration variables were eliminated by static condensation.</li>
</ul>
<p>This increment is stored in an array called <code>delta_zeros</code>. The <code>delta_zeros</code> variable is not meant to be used directly by the users and views to the corrections of the increments of the integration variables are automatically declared in this code block.</p>
<p>Let <code>v</code> be an integration variable, then the variable <code>delta_dv</code> is a view to the correction of the increment of this variable. If unicode notations are used, let <code>υ</code> be the symbolic name of <code>v</code>, then <code>δΔv</code> is an alias for <code>delta_dv</code>.</p>
<p>The increments of the integration variables are not updated at this stage of the resolution algorithm.</p>
<h5 data-number="3.1.1.1.1" id="example"><span class="header-section-number">3.1.1.1.1</span> Example</h5>
<p>The following code limits the amplitude of the correction given to the increment of the elastic strain:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>ProcessNewCorrection{</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">constexpr</span> <span class="at">const</span> real δΔεᵉˡ_m = <span class="fl">1.e-4</span>;</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a> <span class="at">const</span> <span class="kw">auto</span> e = abs(δΔεᵉˡ);</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a> <span class="cf">if</span>(e &gt; δΔεᵉˡ_m){</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>   δΔεᵉˡ *= e / δΔεᵉˡ_m;</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a> }</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h4 data-number="3.1.1.2" id="the-processnewestimate-keyword"><span class="header-section-number">3.1.1.2</span> The <code>@ProcessNewEstimate</code> keyword</h4>
<p>The <code>@ProcessNewEstimate</code> keyword introduces a code block called after the update of the increments of the integration variables.</p>
<p>This method may be used to compute local variables dependent on the updated value of the integration variables.</p>
<p>For example, <code>MFront</code> may define or update this code block to evaluate material properties dependent on the value of the state variable (for example, a Young modulus depending of the porosity), if any.</p>
<h1 data-number="4" id="issues-fixed"><span class="header-section-number">4</span> Issues fixed</h1>
<h2 data-number="4.1" id="issue277-material-properties-support-for-quantities"><span class="header-section-number">4.1</span> Issue:#277: [material properties] Support for quantities</h2>
<p>The <code>UseQt</code> keyword now allows to turn on support for quantities in material properties for interfaces that supports it.</p>
<p>All interfaces delivered by <code>MFront</code> have proper support for quantities.</p>
<p>For more details, see : <a href="https://sourceforge.net/p/tfel/tickets/277/" class="uri">https://sourceforge.net/p/tfel/tickets/277/</a></p>
<h2 data-number="4.2" id="issue-276-support-for-quantities-in-tfelphysicalconstants"><span class="header-section-number">4.2</span> Issue #276: Support for quantities in <code>TFEL/PhysicalConstants</code></h2>
<p>The <code>PhysicalConstants</code> class now have an additional boolean template parameter stating if quantities are to be used. For backward compatibility, this boolean value is <code>false</code> by default.</p>
<p>The inline variables in the <code>tfel::constants</code> now also have a similar template parameter.</p>
<p>For more details, see : <a href="https://sourceforge.net/p/tfel/tickets/276/" class="uri">https://sourceforge.net/p/tfel/tickets/276/</a></p>
<h2 data-number="4.3" id="issue-275-material-properties-define-standard-mfront-scalar-types"><span class="header-section-number">4.3</span> Issue #275: [material properties] Define standard MFront scalar types</h2>
<p>For consistency with behaviours, aliases to many scalar types are now automatically defined in material properties, such as:</p>
<ul>
<li><code>temperature</code>, <code>strain</code>, etc…</li>
</ul>
<p>A complete list of those aliases can be found on <a href="mfront-types.html">this page</a>.</p>
<p>For more details, see : <a href="https://sourceforge.net/p/tfel/tickets/275/" class="uri">https://sourceforge.net/p/tfel/tickets/275/</a></p>
<h2 data-number="4.4" id="issue-160-add-the-ability-to-change-the-linear-solver-used-by-the-implicit-dsl"><span class="header-section-number">4.4</span> Issue #160: Add the ability to change the linear solver used by the Implicit DSL</h2>
<p>Changing the linear solver can now be done by defining an user defined algorithm. The general framework to a new linear solver is documented here: <a href="http://tfel.sourceforge.net/tfel-math.html" class="uri">http://tfel.sourceforge.net/tfel-math.html</a></p>
<p>For more details, see : <a href="https://sourceforge.net/p/tfel/tickets/160/" class="uri">https://sourceforge.net/p/tfel/tickets/160/</a></p>
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-abrahams_cxx_2004" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">1. </div><div class="csl-right-inline"><span class="smallcaps">Abrahams</span>, David and <span class="smallcaps">Gurtovoy</span>, Aleksey. C++ template metaprogramming: Concepts, tools, and techniques from boost and beyond. Boston : Addison-Welsley, 2004. ISBN <a href="https://worldcat.org/isbn/0321227255 9780321227256">0321227255 9780321227256</a>. </div>
</div>
<div id="ref-veldhuizen_techniques_1999" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">2. </div><div class="csl-right-inline"><span class="smallcaps">Veldhuizen</span>, Todd. Techniques for <span>Scientific</span> <span>C</span>++. 1999. </div>
</div>
<div id="ref-coplien_curiously_1995" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">3. </div><div class="csl-right-inline"><span class="smallcaps">Coplien</span>, James O. Curiously recurring template patterns. <em>C++ Report</em>. 1995. Vol. 7, no. 2, p. 24–27. </div>
</div>
<div id="ref-Abbo1995" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">4. </div><div class="csl-right-inline"><span class="smallcaps">Abbo</span>, A. J. and <span class="smallcaps">Sloan</span>, S. W. <span class="nocase">A smooth hyperbolic approximation to the Mohr-Coulomb yield criterion</span>. <em>Computers <span>&amp;</span> Structures</em>. February 1995. Vol. 54, no. 3, p. 427–441. DOI <a href="https://doi.org/10.1016/0045-7949(94)00339-5">10.1016/0045-7949(94)00339-5</a>. Available from: <a href="http://linkinghub.elsevier.com/retrieve/pii/0045794994003395">http://linkinghub.elsevier.com/retrieve/pii/0045794994003395</a></div>
</div>
<div id="ref-Nagel2016" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">5. </div><div class="csl-right-inline"><span class="smallcaps">Nagel</span>, Thomas, <span class="smallcaps">Minkley</span>, Wolfgang, <span class="smallcaps">Böttcher</span>, Norbert, <span class="smallcaps">Naumov</span>, Dmitri, <span class="smallcaps">Görke</span>, Uwe-Jens and <span class="smallcaps">Kolditz</span>, Olaf. <span class="nocase">Implicit numerical integration and consistent linearization of inelastic constitutive models of rock salt</span>. <em>Computers <span>&amp;</span> Structures</em>. April 2017. Vol. 182, p. 87–103. DOI <a href="https://doi.org/10.1016/j.compstruc.2016.11.010">10.1016/j.compstruc.2016.11.010</a>. Available from: <a href="http://www.scopus.com/inward/record.url?eid=2-s2.0-85006482432&amp;partnerID=MN8TOARS http://linkinghub.elsevier.com/retrieve/pii/S0045794916306319">http://www.scopus.com/inward/record.url?eid=2-s2.0-85006482432&amp;partnerID=MN8TOARS http://linkinghub.elsevier.com/retrieve/pii/S0045794916306319</a></div>
</div>
</div>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>It shall be clearly stated that this statement only concerns the <code>TFEL/Math</code> library.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>This is the reason why, by default, the initial guess of the unknowns in <code>MFront</code> is simply a null vector. The user may specify an initial guess for the unknowns using the <code>@Predictor</code> code block, although this is seldom used.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-62273823-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
