<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>The TFEL/Material library</title>
        <meta name="author" content="Thomas Helfer" />
            <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
    <style type="text/css">code{white-space: pre;}</style>
            <style type="text/css">
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      .sourceCode { overflow: visible; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f8f8f8; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ef2929; } /* Alert */
      code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #204a87; } /* Attribute */
      code span.bn { color: #0000cf; } /* BaseN */
      code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4e9a06; } /* Char */
      code span.cn { color: #8f5902; } /* Constant */
      code span.co { color: #8f5902; font-style: italic; } /* Comment */
      code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
      code span.dt { color: #204a87; } /* DataType */
      code span.dv { color: #0000cf; } /* DecVal */
      code span.er { color: #a40000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #0000cf; } /* Float */
      code span.fu { color: #204a87; font-weight: bold; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
      code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
      code span.ot { color: #8f5902; } /* Other */
      code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
      code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
      code span.ss { color: #4e9a06; } /* SpecialString */
      code span.st { color: #4e9a06; } /* String */
      code span.va { color: #000000; } /* Variable */
      code span.vs { color: #4e9a06; } /* VerbatimString */
      code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
    </style>
            <link rel="stylesheet" href="css/normalize.css"/>
    <link rel="stylesheet" href="css/main.css"/>
        <script
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
        type="text/javascript"></script>
          </head>
  <body>
    <!--[if lt IE 7]>
        <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]-->
        <header>
      <ul id="nav">
	<li><a href="news.html">News</a></li>
	<li><a href="index.html">Overview</a>
	  <ul>
	    <li><a>Domain specific languages</a>
	      <ul>
		<li><a href="material-properties.html">Material properties</a></li>
		<li><a href="behaviours.html">Mechanical behaviours</a></li>
		<li><a href="models.html">Models</a></li>
	      </ul>
            </li>
	    <li><a href="interfaces.html">Available interfaces</a></li>
	    <li><a href="associated-projects.html">Associated projects</a></li>
	  </ul>
	</li>
	<li><a>Getting started</a>
	  <ul>
	    <li><a href="https://github.com/thelfer/tfel/">Github repository</a></li>
	    <li><a href="https://github.com/thelfer/tfel/releases">Download</a></li>
	    <li><a href="release-notes.html">Release notes</a>
	      <ul>
		<li><a>Versions 2.0.x</a>
                  <ul>
                    <li><a href="release-notes.html">Versions prior to 2.0.5</a></li>
	 	    <li><a href="release-notes-2.0.5.html">Version 2.0.5</a></li>
                  </ul>
		</li>
		<li><a>Versions 3.0.x</a>
                  <ul>
		    <li><a href="release-notes-3.0.html">Version 3.0.0</a></li>
		    <li><a href="release-notes-3.0.1.html">Version 3.0.1</a></li>
		    <li><a href="release-notes-3.0.2.html">Version 3.0.2</a></li>
		    <li><a href="release-notes-3.0.3.html">Version 3.0.3</a></li>
		    <li><a href="release-notes-3.0.4.html">Version 3.0.4</a></li>
		    <li><a href="release-notes-3.0.5.html">Version 3.0.5</a></li>
		    <li><a href="release-notes-3.0.6.html">Version 3.0.6</a></li>
		    <li><a href="release-notes-3.0.7.html">Version 3.0.7</a></li>
		    <li><a href="release-notes-3.0.8.html">Version 3.0.8</a></li>
		    <li><a href="release-notes-3.0.9.html">Version 3.0.9</a></li>
		    <li><a href="release-notes-3.0.10.html">Version 3.0.10</a></li>
		    <li><a href="release-notes-3.0.11.html">Version 3.0.11</a></li>
		    <li><a href="release-notes-3.0.12.html">Version 3.0.12</a></li>
		    <li><a href="release-notes-3.0.13.html">Version 3.0.13</a></li>
		    <li><a href="release-notes-3.0.14.html">Version 3.0.14</a></li>
		    <li><a href="release-notes-3.0.15.html">Version 3.0.15</a></li>
		    <li><a href="release-notes-3.0.16.html">Version 3.0.16</a></li>
		    <li><a href="release-notes-3.0.17.html">Version 3.0.17</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.1.x</a>
		  <ul>
		    <li><a href="release-notes-3.1.html">Version 3.1.0</a></li>
		    <li><a href="release-notes-3.1.1.html">Version 3.1.1</a></li>
		    <li><a href="release-notes-3.1.2.html">Version 3.1.2</a></li>
		    <li><a href="release-notes-3.1.3.html">Version 3.1.3</a></li>
		    <li><a href="release-notes-3.1.4.html">Version 3.1.4</a></li>
		    <li><a href="release-notes-3.1.5.html">Version 3.1.5</a></li>
		    <li><a href="release-notes-3.1.6.html">Version 3.1.6</a></li>
		    <li><a href="release-notes-3.1.7.html">Version 3.1.7</a></li>
		    <li><a href="release-notes-3.1.8.html">Version 3.1.8</a></li>
		    <li><a href="release-notes-3.1.9.html">Version 3.1.9</a></li>
		    <li><a href="release-notes-3.1.10.html">Version 3.1.10</a></li>
		    <li><a href="release-notes-3.1.11.html">Version 3.1.11</a></li>
		    <li><a href="release-notes-3.1.12.html">Version 3.1.12</a></li>
		    <li><a href="release-notes-3.1.13.html">Version 3.1.13</a></li>
		    <li><a href="release-notes-3.1.14.html">Version 3.1.14</a></li>
		    <li><a href="release-notes-3.1.15.html">Version 3.1.15</a></li>
		    <li><a href="release-notes-3.1.16.html">Version 3.1.16</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.2.x</a>
		  <ul>
		    <li><a href="release-notes-3.2.html">Version 3.2.0</a></li>
		    <li><a href="release-notes-3.2.1.html">Version 3.2.1</a></li>
		    <li><a href="release-notes-3.2.2.html">Version 3.2.2</a></li>
		    <li><a href="release-notes-3.2.3.html">Version 3.2.3</a></li>
		    <li><a href="release-notes-3.2.4.html">Version 3.2.4</a></li>
		    <li><a href="release-notes-3.2.5.html">Version 3.2.5</a></li>
		    <li><a href="release-notes-3.2.6.html">Version 3.2.6</a></li>
		    <li><a href="release-notes-3.2.7.html">Version 3.2.7</a></li>
		    <li><a href="release-notes-3.2.8.html">Version 3.2.8</a></li>
		    <li><a href="release-notes-3.2.9.html">Version 3.2.9</a></li>
		    <li><a href="release-notes-3.2.10.html">Version 3.2.10</a></li>
		    <li><a href="release-notes-3.2.11.html">Version 3.2.11</a></li>
		    <li><a href="release-notes-3.2.12.html">Version 3.2.12</a></li>
		    <li><a href="release-notes-3.2.13.html">Version 3.2.13</a></li>
		    <li><a href="release-notes-3.2.14.html">Version 3.2.14</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.3.x</a>
		  <ul>
		    <li><a href="release-notes-3.3.html">Version 3.3.0</a></li>
		    <li><a href="release-notes-3.3.1.html">Version 3.3.1</a></li>
		    <li><a href="release-notes-3.3.1.html">Version 3.3.2</a></li>
		    <li><a href="release-notes-3.3.2.html">Version 3.3.2</a></li>
		    <li><a href="release-notes-3.3.3.html">Version 3.3.3</a></li>
		    <li><a href="release-notes-3.3.4.html">Version 3.3.4</a></li>
		    <li><a href="release-notes-3.3.5.html">Version 3.3.5</a></li>
		    <li><a href="release-notes-3.3.6.html">Version 3.3.6</a></li>
		    <li><a href="release-notes-3.3.7.html">Version 3.3.7</a></li>
		    <li><a href="release-notes-3.3.7.html">Version 3.3.8</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.4.x</a>
		  <ul>
		    <li><a href="release-notes-3.4.html">Version 3.4.0</a></li>
		    <li><a href="release-notes-3.4.1.html">Version 3.4.1</a></li>
		    <li><a href="release-notes-3.4.2.html">Version 3.4.2</a></li>
		    <li><a href="release-notes-3.4.3.html">Version 3.4.3</a></li>
		    <li><a href="release-notes-3.4.4.html">Version 3.4.4</a></li>
		    <li><a href="release-notes-3.4.5.html">Version 3.4.5</a></li>
		    <li><a href="release-notes-3.4.6.html">Version 3.4.6</a></li>
		    <li><a href="release-notes-3.4.7.html">Version 3.4.7</a></li>
		    <li><a href="release-notes-3.4.8.html">Version 3.4.8</a></li>
		    <li><a href="release-notes-3.4.9.html">Version 3.4.9</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.0.x</a>
		  <ul>
		    <li><a href="release-notes-4.0.html">Version 4.0.0</a></li>
		    <li><a href="release-notes-4.0.1.html">Version 4.0.1</a></li>
		    <li><a href="release-notes-4.0.2.html">Version 4.0.2</a></li>
		    <li><a href="release-notes-4.0.3.html">Version 4.0.3</a></li>
		    <li><a href="release-notes-4.0.4.html">Version 4.0.4</a></li>
		    <li><a href="release-notes-4.0.5.html">Version 4.0.5</a></li>
		    <li><a href="release-notes-4.0.6.html">Version 4.0.6</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.1.x</a>
		  <ul>
		    <li><a href="release-notes-4.1.html">Version 4.1.0</a></li>
		    <li><a href="release-notes-4.1.1.html">Version 4.1.1</a></li>
		    <li><a href="release-notes-4.1.2.html">Version 4.1.2</a></li>
		    <li><a href="release-notes-4.1.3.html">Version 4.1.3</a></li>
		    <li><a href="release-notes-4.1.4.html">Version 4.1.4</a></li>
		    <li><a href="release-notes-4.1.5.html">Version 4.1.5</a></li>
		    <li><a href="release-notes-4.1.6.html">Version 4.1.6</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.2.x</a>
		  <ul>
		    <li><a href="release-notes-4.2.html">Version 4.2.0</a></li>
		    <li><a href="release-notes-4.2.1.html">Version 4.2.1</a></li>
		    <li><a href="release-notes-4.2.2.html">Version 4.2.2</a></li>
		    <li><a href="release-notes-4.2.3.html">Version 4.2.3</a></li>
		    <li><a href="release-notes-4.2.4.html">Version 4.2.4</a></li>
		    <li><a href="release-notes-4.2.5.html">Version 4.2.5</a></li>
		    <li><a href="release-notes-4.2.6.html">Version 4.2.6</a></li>
		  </ul>
		</li>
		<li><a>Versions 5.0.x</a>
		  <ul>
		    <li><a href="release-notes-5.0.html">Version 5.0.0</a></li>
		    <li><a href="release-notes-5.0.1.html">Version 5.0.1</a></li>
		    <li><a href="release-notes-5.0.2.html">Version 5.0.2</a></li>
		    <li><a href="release-notes-5.0.3.html">Version 5.0.3</a></li>
		  </ul>
		</li>
		<li><a>Versions 5.1.x</a>
		  <ul>
		    <li><a href="release-notes-5.1.html">Version 5.1.0</a></li>
		    <li><a href="release-notes-5.1.1.html">Version 5.1.1</a></li>
		  </ul>
		</li>
		<li><a>Versions 5.2.x</a>
		  <ul>
		    <li><a href="release-notes-5.1.html">Version 5.2.0</a></li>
		  </ul>
		</li>
	      </ul>
	    </li>
	    <li><a href="coverity-scan.html">Coverity scan</a></li>
	    <li><a href="install.html">Installation</a></li>
	  </ul>
	</li>
	<li><a>Documentation</a>
	  <ul>
	    <li><a href="documentations.html">General documentation</a></li>
	    <li><a href="gallery.html">Gallery</a></li>
<!--	    
	    <li><a href="http://tfel.sourceforge.net/doxygen/index.html">Doxygen documentation</a></li>
-->
	    <li><a>MFront</a>
	      <ul>
		<li><a href="tutorial.html">Tutorial</a></li>
		<li><a href="implicit-dsl.html">The Implicit DSL</a></li>
		<li><a href="benchmark.html">Benchmark</a></li>
		<li><a href="parameters.html">Parameters</a></li>
		<li><a href="BehaviourBricks.html">Behaviour bricks</a></li>
                 <li><a href="behaviour-variable.html">behaviour variables</a></li>
		<li><a href="interfaces.html">Solver interfaces</a>
		  <ul>
		    <li><a href="castem.html">Cast3M</a></li>
		    <li><a href="amitex.html">AMITEX_FFTP</a></li>
		    <li><a href="aster.html">Code-Aster</a></li>
    		    <li><a href="abaqus.html">Abaqus</a></li>
		    <li><a href="zmat.html">ZeBuLoN</a></li>
   		    <li><a href="calculix.html">CalculiX</a></li>
		    <!-- <li><a >TMFFT</a></li> -->
		    <li><a href="cyrano.html">Cyrano</a></li>
   		    <li><a href="generic-material-property-interface.html">Generic interface for material properties</a></li>
   		    <li><a href="generic-behaviours-interface.html">Generic interface for behaviours</a></li>
		  </ul>
		</li>
                 <li><a>MFront keywords</a>
    	              <ul>
    	        <li><a href="Default-keywords.html">Default</a></li>
    	        <li><a href="DefaultCZM-keywords.html">DefaultCZM</a></li>
    	        <li><a href="DefaultFiniteStrain-keywords.html">DefaultFiniteStrain</a></li>
    	        <li><a href="DefaultGenericBehaviour-keywords.html">DefaultGenericBehaviour</a></li>
    	        <li><a href="DefaultModel-keywords.html">DefaultModel</a></li>
    	        <li><a href="Implicit-keywords.html">Implicit</a></li>
    	        <li><a href="ImplicitCZM-keywords.html">ImplicitCZM</a></li>
    	        <li><a href="ImplicitFiniteStrain-keywords.html">ImplicitFiniteStrain</a></li>
    	        <li><a href="ImplicitGenericBehaviour-keywords.html">ImplicitGenericBehaviour</a></li>
    	        <li><a href="ImplicitModel-keywords.html">ImplicitModel</a></li>
    	        <li><a href="ImplicitII-keywords.html">ImplicitII</a></li>
    	        <li><a href="IsotropicMisesCreep-keywords.html">IsotropicMisesCreep</a></li>
    	        <li><a href="IsotropicMisesPlasticFlow-keywords.html">IsotropicMisesPlasticFlow</a></li>
    	        <li><a href="IsotropicPlasticMisesFlow-keywords.html">IsotropicPlasticMisesFlow</a></li>
    	        <li><a href="IsotropicStrainHardeningMisesCreep-keywords.html">IsotropicStrainHardeningMisesCreep</a></li>
    	        <li><a href="MaterialLaw-keywords.html">MaterialLaw</a></li>
    	        <li><a href="MaterialProperty-keywords.html">MaterialProperty</a></li>
    	        <li><a href="Model-keywords.html">Model</a></li>
    	        <li><a href="MultipleIsotropicMisesFlows-keywords.html">MultipleIsotropicMisesFlows</a></li>
    	        <li><a href="RungeKutta-keywords.html">RungeKutta</a></li>
    	        <li><a href="RungeKuttaFiniteStrain-keywords.html">RungeKuttaFiniteStrain</a></li>
    	        <li><a href="RungeKuttaGenericBehaviour-keywords.html">RungeKuttaGenericBehaviour</a></li>
    	        <li><a href="RungeKuttaModel-keywords.html">RungeKuttaModel</a></li>
    	      </ul>
                </li>
	      </ul>
	    </li>
	    <li><a href="mtest.html">MTest</a>
               <ul>
	      <li><a href="mtest-nonlinear-constraints.html">Nonlinear constraints</a></li>
              <li><a href="MTest-keywords.html">MTest keywords</a></li>
	      </ul>
            </li>
     	    <li><a>Tools</a>
	      <ul>
	        <li><a href="mfront-doc.html">mfront-doc</a></li>
	        <li><a href="mfm.html">mfm</a></li>
	        <li><a href="mfm-test-generator.html">mfm-test-generator</a></li>
	        <li><a href="tfel-check.html">tfel-check</a></li>
	      </ul>
	    </li>
	    <li><a>TFEL libraries</a>
	      <ul>
		<li><a href="libraries_usage.html">Usage of the TFEL libraries in C++</a></li>
		<li><a href="tfel-math.html">TFEL/Math</a></li>
                 <ul>
		  <li><a href="tfel-math-numerical-integration.html">Numerical integeration</a></li>
		  <li><a href="tfel-math-data-interpolation.html">Data interpolation</a></li>
	        </ul>
		<li><a href="tfel-material.html">TFEL/Material</a></li>
                 <li><a href="glossary.html">Glossary</a></li>
                 <li><a href="physical-constants.html">Physical constants</a></li>
		<li><a href="tfel-mfront-database.html">TFELMFrontDatabase</a></li>
	      </ul>
	    </li>
	    <li><a>Python modules</a>
	      <ul>
		<li><a href="tfel-python.html">TFEL modules</a></li>
		<li><a href="mfront-python.html">mfront module</a></li>
		<li><a href="mtest-python.html">mtest module</a></li>
	      </ul>
	    </li>
	    <li><a href="publications.html">Publications</a></li>
	    <li><a href="faq.html">FAQ</a></li>
	    <li><a href="about.html">About</a></li>
	  </ul>
	</li>
	<li><a>Contributing</a>
	  <ul>
	    <li><a href="https://github.com/thelfer/tfel">Access to sources</a></li>
	    <li><a href="contributing.html">Contributing guidelines</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Report bugs</a></li>
	  </ul>
	</li>
	<li><a>Getting Help</a>
	  <ul>
	    <li><a href="search.html">Search on this site</a></li>
	    <li><a href="https://github.com/thelfer/tfel/discussions">Forum</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Bug report</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Feature request</a></li>
	    <li><a href="mailto:tfel-contact@cea.fr">Contact</a></li>
	  </ul>
	</li>
      </ul>
    </header>
<div id="header">
<h1 class="title">The TFEL/Material library</h1>
<h2 class="author">Thomas Helfer</h2>
<h3 class="date">19/12/2017</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#equivalent-stress" id="toc-equivalent-stress">Equivalent
stress</a>
<ul>
<li><a href="#sec:hosford" id="toc-sec:hosford">Hosford equivalent
stress</a></li>
<li><a href="#sec:barlat" id="toc-sec:barlat">Barlat equivalent
stress</a></li>
</ul></li>
<li><a href="#general-functionalities"
id="toc-general-functionalities">General functionalities</a>
<ul>
<li><a href="#computation-of-the-inverse-of-the-langevin-function"
id="toc-computation-of-the-inverse-of-the-langevin-function">Computation
of the inverse of the Langevin function</a></li>
<li><a href="#example-of-usage" id="toc-example-of-usage">Example of
usage</a></li>
<li><a href="#pi-plane" id="toc-pi-plane"><span
class="math inline">\(\pi\)</span>-plane</a></li>
</ul></li>
<li><a href="#orthotropic-axes-convention"
id="toc-orthotropic-axes-convention">Orthotropic axes
convention</a></li>
<li><a href="#isotropic-elastic-moduli"
id="toc-isotropic-elastic-moduli">Isotropic elastic moduli</a></li>
<li><a href="#homogenization" id="toc-homogenization">Homogenization</a>
<ul>
<li><a href="#eshelby-hill-and-localisation-tensors"
id="toc-eshelby-hill-and-localisation-tensors">Eshelby, Hill and
localisation tensors</a></li>
<li><a href="#homogenization-schemes-for-biphasic-media"
id="toc-homogenization-schemes-for-biphasic-media">Homogenization
schemes for biphasic media</a></li>
<li><a href="#homogenization-bounds"
id="toc-homogenization-bounds">Homogenization bounds</a></li>
<li><a href="#homogenization-of-general-microstructures"
id="toc-homogenization-of-general-microstructures">Homogenization of
general microstructures</a></li>
</ul></li>
</ul>
</div>
<h1 id="equivalent-stress">Equivalent stress</h1>
<h2 id="sec:hosford">Hosford equivalent stress</h2>
<p>The header <code>TFEL/Material/Hosford1972YieldCriterion.hxx</code>
introduces three functions which are meant to compute the Hosford
equivalent stress and its first and second derivatives. <em>This header
is automatically included by <code>MFront</code></em></p>
<p>The Hosford equivalent stress is defined by: <span
class="math display">\[
\sigma_{\mathrm{eq}}^{H}=\sqrt[a]{\displaystyle\frac{\displaystyle
1}{\displaystyle
2}\left({\left|\sigma_{1}-\sigma_{2}\right|}^{a}+{\left|\sigma_{1}-\sigma_{3}\right|}^{a}+{\left|\sigma_{2}-\sigma_{3}\right|}^{a}\right)}
\]</span> where <span class="math inline">\(s_{1}\)</span>, <span
class="math inline">\(s_{2}\)</span> and <span
class="math inline">\(s_{3}\)</span> are the eigenvalues of the
stress.</p>
<p>Therefore, when <span class="math inline">\(a\)</span> goes to
infinity, the Hosford stress reduces to the Tresca stress. When <span
class="math inline">\(n = 2\)</span> the Hosford stress reduces to the
von Mises stress.</p>
<p>The following functions has been implemented:</p>
<ul>
<li><code>computeHosfordStress</code>: return the Hosford equivalent
stress</li>
<li><code>computeHosfordStressNormal</code>: return a tuple containing
the Hosford equivalent stress and its first derivative (the normal)</li>
<li><code>computeHosfordStressSecondDerivative</code>: return a tuple
containing the Hosford equivalent stress, its first derivative (the
normal) and the second derivative.</li>
</ul>
<h4 id="example">Example</h4>
<p>The following example computes the Hosford equivalent stress, its
normal and second derivative:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>stress seq<span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>Stensor  n<span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>Stensor4 dn<span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>tie<span class="op">(</span>seq<span class="op">,</span>n<span class="op">,</span>dn<span class="op">)</span> <span class="op">=</span> computeHosfordStressSecondDerivative<span class="op">(</span>s<span class="op">,</span>a<span class="op">,</span>seps<span class="op">);</span></span></code></pre></div>
<p>In this example, <code>s</code> is the stress tensor, <code>a</code>
is the Hosford exponent, <code>seps</code> is a numerical parameter used
to detect when two eigenvalues are equal.</p>
<p>If <code>C++-17</code> is available, the previous code can be made
much more readable:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>seq<span class="op">,</span>n<span class="op">,</span>dn<span class="op">]</span> <span class="op">=</span> computeHosfordStressSecondDerivative<span class="op">(</span>s<span class="op">,</span>a<span class="op">,</span>seps<span class="op">);</span></span></code></pre></div>
<h2 id="sec:barlat">Barlat equivalent stress</h2>
<p>The header <code>TFEL/Material/Barlat2004YieldCriterion.hxx</code>
introduces various functions which are meant to compute the Barlat
equivalent stress and its first and second derivatives. <em>This header
is automatically included by <code>MFront</code></em> for orthotropic
behaviours.</p>
<p>The Barlat equivalent stress is defined as follows (see <span
class="citation" data-cites="barlat_linear_2005">[1]</span>): <span
class="math display">\[
\sigma_{\mathrm{eq}}^{B}=
\sqrt[a]{
  \frac{1}{4}\left(
  \sum_{i=0}^{3}
  \sum_{j=0}^{3}
  {\left|s&#39;_{i}-s&#39;&#39;_{j}\right|}^{a}
  \right)
}
\]</span></p>
<p>where <span class="math inline">\(s&#39;_{i}\)</span> and <span
class="math inline">\(s&#39;&#39;_{i}\)</span> are the eigenvalues of
two transformed stresses <span
class="math inline">\(\underline{s}&#39;\)</span> and <span
class="math inline">\(\underline{s}&#39;&#39;\)</span> by two linear
transformation <span
class="math inline">\(\underline{\underline{\mathbf{L}}}&#39;\)</span>
and <span
class="math inline">\(\underline{\underline{\mathbf{L}}}&#39;&#39;\)</span>:
<span class="math display">\[
\left\{
\begin{aligned}
\underline{s}&#39;  &amp;= \underline{\underline{\mathbf{L&#39;}}}
\,\colon\,\underline{\sigma}\\
\underline{s}&#39;&#39; &amp;=
\underline{\underline{\mathbf{L&#39;&#39;}}}\,\colon\,\underline{\sigma}\\
\end{aligned}
\right.
\]</span></p>
<p>The linear transformations <span
class="math inline">\(\underline{\underline{\mathbf{L}}}&#39;\)</span>
and <span
class="math inline">\(\underline{\underline{\mathbf{L}}}&#39;&#39;\)</span>
are defined by <span class="math inline">\(9\)</span> coefficients
(each) which describe the material orthotropy. There are defined through
auxiliary linear transformations <span
class="math inline">\(\underline{\underline{\mathbf{C}}}&#39;\)</span>
and <span
class="math inline">\(\underline{\underline{\mathbf{C}}}&#39;&#39;\)</span>
as follows: <span class="math display">\[
\begin{aligned}
\underline{\underline{\mathbf{L}}}&#39;
&amp;=\underline{\underline{\mathbf{C}}}&#39;\,\colon\,\underline{\underline{\mathbf{M}}}
\\
\underline{\underline{\mathbf{L}}}&#39;&#39;&amp;=\underline{\underline{\mathbf{C}}}&#39;&#39;\,\colon\,\underline{\underline{\mathbf{M}}}
\end{aligned}
\]</span> where <span
class="math inline">\(\underline{\underline{\mathbf{M}}}\)</span> is the
transformation of the stress to its deviator: <span
class="math display">\[
\underline{\underline{\mathbf{M}}}=\underline{\underline{\mathbf{I}}}-\displaystyle\frac{\displaystyle
1}{\displaystyle 3}\underline{I}\,\otimes\,\underline{I}
\]</span></p>
<p>The linear transformations <span
class="math inline">\(\underline{\underline{\mathbf{C}}}&#39;\)</span>
and <span
class="math inline">\(\underline{\underline{\mathbf{C}}}&#39;&#39;\)</span>
of the deviator stress are defined as follows: <span
class="math display">\[
\underline{\underline{\mathbf{C}}}&#39;=
\begin{pmatrix}
0 &amp; -c&#39;_{12} &amp; -c&#39;_{13} &amp; 0 &amp; 0 &amp; 0 \\
-c&#39;_{21} &amp; 0 &amp; -c&#39;_{23} &amp; 0 &amp; 0 &amp; 0 \\
-c&#39;_{31} &amp; -c&#39;_{32} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; c&#39;_{44} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; c&#39;_{55} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; c&#39;_{66} \\
\end{pmatrix}
\quad
\text{and}
\quad
\underline{\underline{\mathbf{C}}}&#39;&#39;=
\begin{pmatrix}
0 &amp; -c&#39;&#39;_{12} &amp; -c&#39;&#39;_{13} &amp; 0 &amp; 0 &amp;
0 \\
-c&#39;&#39;_{21} &amp; 0 &amp; -c&#39;&#39;_{23} &amp; 0 &amp; 0 &amp;
0 \\
-c&#39;&#39;_{31} &amp; -c&#39;&#39;_{32} &amp; 0 &amp; 0 &amp; 0 &amp;
0 \\
0 &amp; 0 &amp; 0 &amp; c&#39;&#39;_{44} &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; c&#39;&#39;_{55} &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; c&#39;&#39;_{66} \\
\end{pmatrix}
\]</span></p>
<p>The following functions have been implemented:</p>
<ul>
<li><code>computeBarlatStress</code>: return the Barlat equivalent
stress</li>
<li><code>computeBarlatStressNormal</code>: return a tuple containing
the Barlat equivalent stress and its first derivative (the normal)</li>
<li><code>computeBarlatStressSecondDerivative</code>: return a tuple
containing the Barlat equivalent stress, its first derivative (the
normal) and the second derivative.</li>
</ul>
<h3 id="linear-transformations">Linear transformations</h3>
<p>To define the linear transformations, the
<code>makeBarlatLinearTransformation</code> function has been
introduced. This function takes two template parameter:</p>
<ul>
<li>the space dimension (<span class="math inline">\(1\)</span>, <span
class="math inline">\(2\)</span>, and <span
class="math inline">\(3\)</span>)</li>
<li>the numeric type used (automatically deduced)</li>
</ul>
<p>This functions takes the <span class="math inline">\(9\)</span>
coefficients as arguments, as follows:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> l1 <span class="op">=</span> makeBarlatLinearTransformation<span class="op">&lt;</span><span class="dv">3</span><span class="op">&gt;(</span>c_12<span class="op">,</span>c_21<span class="op">,</span>c_13<span class="op">,</span>c_31<span class="op">,</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>                                                  c_23<span class="op">,</span>c_32<span class="op">,</span>c_44<span class="op">,</span>c_55<span class="op">,</span>c_66<span class="op">);</span></span></code></pre></div>
<blockquote>
<p><strong>Note</strong> In his paper, Barlat and coworkers uses the
following convention for storing symmetric tensors:</p>
<p><span class="math display">\[
\begin{pmatrix}
xx &amp; yy &amp; zz &amp; yz &amp; zx &amp; xy
\end{pmatrix}
\]</span></p>
<p>which is not consistent with the
<code>TFEL</code>/<code>Cast3M</code>/<code>Abaqus</code>/<code>Ansys</code>
conventions:</p>
<p><span class="math display">\[
\begin{pmatrix}
xx &amp; yy &amp; zz &amp; xy &amp; xz &amp; yz
\end{pmatrix}
\]</span></p>
<p>Therefore, if one wants to use coefficients <span
class="math inline">\(c^{B}\)</span> given by Barlat, one shall call
this function as follows:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> l1 <span class="op">=</span> makeBarlatLinearTransformation<span class="op">&lt;</span><span class="dv">3</span><span class="op">&gt;(</span>cB_12<span class="op">,</span>cB_21<span class="op">,</span>cB_13<span class="op">,</span>cB_31<span class="op">,</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>                                                  cB_23<span class="op">,</span>cB_32<span class="op">,</span>cB_66<span class="op">,</span>cBB_55<span class="op">,</span>cBB_44<span class="op">);</span></span></code></pre></div>
</blockquote>
<p>The <code>TFEL/Material</code> library also provide an overload of
the <code>makeBarlatLinearTransformation</code> which template
parameters are the modelling hypothesis and the orthotropic axis
conventions. The purpose of this overload is to swap appropriate
coefficients to get a consistent definition of the linear
transformations for all the modelling hypotheses.</p>
<h1 id="general-functionalities">General functionalities</h1>
<h2 id="computation-of-the-inverse-of-the-langevin-function">Computation
of the inverse of the Langevin function</h2>
<p>The inverse Langevin function is used in many statistically based
network behaviours describing rubber-like materials.</p>
<p>The Langevin function <span
class="math inline">\(\mathcal{L}\)</span> is defined as follows: <span
class="math display">\[
\mathcal{L}\left(x\right)=\displaystyle\frac{\displaystyle
1}{\displaystyle \coth\left(x\right)}-\displaystyle\frac{\displaystyle
1}{\displaystyle x}
\]</span></p>
<p>The complexity of the inverse Langevin function <span
class="math inline">\(\mathcal{L}^{-1}\left(x\right)\)</span> motivated
the development of various approximations <span class="citation"
data-cites="cohen_pade_1991 bergstrom_constitutive_1998 jedynak_approximation_2015">[2–4]</span>.</p>
<figure id="fig:tfel_4.1:tfel_material:inverse_langevin_function">
<img src="img/InverseLangevinFunction.svg" style="width:95.0%"
alt="Comparison of various approximations of the inverse Langenvin function" />
<figcaption>Figure 1: Comparison of various approximations of the
inverse Langenvin function</figcaption>
</figure>
<p>Figure 1 compares those approximations. The approximations of
Bergström and Boyce <span class="citation"
data-cites="bergstrom_constitutive_1998">[3]</span> and Jedynak <span
class="citation" data-cites="jedynak_approximation_2015">[4]</span> are
undistinguishable. See Jedynak for a quantitative discussion of the
error generated by those approximations <span class="citation"
data-cites="jedynak_approximation_2015">[4]</span>. It is worth noting
that all those approximations mostly differs near the pole of inverse
Langevin function <span
class="math inline">\(\mathcal{L}^{-1}\left(x\right)\)</span>.</p>
<p>The <code>InverseLangevinFunctionApproximations</code> enumeration
lists the approximations that have been implemented and that can be
evaluated in a <code>constexpr</code> context:</p>
<ul>
<li>The value <code>COHEN_1991</code> is associated with the
approximation proposed by Cohen <span class="citation"
data-cites="cohen_pade_1991">[2]</span>: <span class="math display">\[
\mathcal{L}^{-1}\left(x\right) \approx
y\displaystyle\frac{\displaystyle 3-y^{2}}{\displaystyle 1-y^{2}}.
\]</span></li>
<li>The value <code>JEDYNAK_2015</code> is associated with the
approximation proposed by Jedynak <span class="citation"
data-cites="jedynak_approximation_2015">[4]</span>: <span
class="math display">\[
\mathcal{L}^{-1}\left(x\right) \approx
y \, \displaystyle\frac{\displaystyle c_{0} + c_{1}\,y +
c_{2}\,y^{2}}{\displaystyle 1 + d_{1}\,y + d_{2}\,y^{2}}
\]</span></li>
<li><code>KUHN_GRUN_1942</code> or <code>MORCH_2022</code> are
associated with a taylor expansion of <span
class="math inline">\(\mathcal{L}^{-1}\left(x\right)\)</span> at <span
class="math inline">\(0\)</span>: <span class="math display">\[
\mathcal{L}^{-1}\left(x\right) \approx
y\,P\left(y^{2}\right) \quad\text{with}\quad
P\left(y^{2}\right)=\sum_{i=0}^{9}c_{i}\,\left(y^{2}\right)^{i}
\]</span> where <span class="math inline">\(P\)</span> is a <span
class="math inline">\(9\)</span>th order polynomial. Hence, the Taylor
expression is of order <span class="math inline">\(19\)</span>.</li>
</ul>
<p>The <code>computeApproximateInverseLangevinFunction</code> computes
one approximation of the inverse Langevin function and the
<code>computeApproximateInverseLangevinFunctionAndDerivative</code>
function computes an approximation of the inverse Langevin function and
its derivative. These functions have two template parameters: the
approximation selected and the numeric type to be used. By default, the
<code>JEDYNAK_2015</code> approximation is used and the numeric type can
be deduced from the type of the argument.</p>
<p>The approximation proposed by Bergström and Boyce <span
class="citation" data-cites="bergstrom_constitutive_1998">[3]</span> is
given by the following function: <span class="math display">\[
\mathcal{L}^{-1}\left(x\right)
\approx
\left\{
\begin{aligned}
c_{1} \tan\left(c_{2} \, x\right) + c_{3} \, x &amp;\quad\text{if}\quad
\left|x\right| \leq c_{0}\\
\displaystyle\frac{\displaystyle 1}{\displaystyle
\mathop{sign}\left(x\right)-x}&amp;\quad\text{if}\quad \left|x\right|
&gt; c_{0}
\end{aligned}
\right.
\]</span></p>
<p>The
<code>computeBergstromBoyce1998ApproximateInverseLangevinFunction</code>
function computes this approximation and the
<code>computeBergstromBoyce1998ApproximateInverseLangevinFunctionAndDerivative</code>
function computes this function and its derivative. These functions
can’t be declared <code>constexpr</code> because of tangent function is
not <code>constexpr</code>. These functions have one template parameter,
the numeric type to be used. This template parameter can be
automatically deduced from the type of the argument.</p>
<h2 id="example-of-usage">Example of usage</h2>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> ApproximationFunctions <span class="op">=</span> InverseLangevinFunctionApproximations<span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">// compute Cohen&#39;s approximation of the inverse Langevin function</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> v <span class="op">=</span> computeApproximateInverseLangevinFunction<span class="op">&lt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>            ApproximationFunctions<span class="op">::</span>COHEN_1991<span class="op">&gt;(</span>y<span class="op">)</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="co">// compute Jedynak&#39;s approximation of the inverse Langevin function and its derivative</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> <span class="op">[</span>f<span class="op">,</span> df<span class="op">]</span> <span class="op">=</span> computeApproximateInverseLangevinFunctionAndDerivative<span class="op">(</span>y<span class="op">)</span></span></code></pre></div>
<h2 id="pi-plane"><span class="math inline">\(\pi\)</span>-plane</h2>
<p>The <span class="math inline">\(\pi\)</span>-plane is defined in the
space defined by the three eigenvalues <span
class="math inline">\(S_{0}\)</span>, <span
class="math inline">\(S_{1}\)</span> and <span
class="math inline">\(S_{2}\)</span> of the stress by the following
equations: <span class="math display">\[
S_{0}+S_{1}+S_{2}=0
\]</span></p>
<p>This plane contains deviatoric stress states and is perpendicular to
the hydrostatic axis. A basis of this plane is given by the following
vectors: <span class="math display">\[
\vec{n}_{0}=
\frac{1}{\sqrt{2}}\,
\begin{pmatrix}
1  \\
-1 \\
0
\end{pmatrix}
\quad\text{and}\quad
\vec{n}_{1}=
\frac{1}{\sqrt{6}}\,
\begin{pmatrix}
-1 \\
-1 \\
2
\end{pmatrix}
\]</span></p>
<p>This plane is used to characterize the iso-values of equivalent
stresses which are not sensitive to the hydrostatic pressure.</p>
<p>Various functions are available:</p>
<ul>
<li><code>projectOnPiPlane</code>: this function projects a stress state
on the <span class="math inline">\(\pi\)</span>-plane.</li>
<li><code>buildFromPiPlane</code>: this function builds a stress state,
defined by its three eigenvalues, from its coordinate in the <span
class="math inline">\(\pi\)</span>-plane.</li>
</ul>
<h1 id="orthotropic-axes-convention">Orthotropic axes convention</h1>
<p>Most finite element solver can’t have a unique definition of the
orthotropic axes valid for all the modelling hypotheses.</p>
<p>For example, one can define a pipe using the following axes
definition:</p>
<ul>
<li><span class="math inline">\(\left(rr,zz,tt,...\right)\)</span> in
<span class="math inline">\(3D\)</span>, <span
class="math inline">\(2D\)</span> axysymmetric, <span
class="math inline">\(1D\)</span> axisymmetric generalised plane strain
or <span class="math inline">\(1D\)</span> axisymmetric generalised
plane stress.</li>
<li><span class="math inline">\(\left(rr,tt,zz,...\right)\)</span> in
<span class="math inline">\(2D\)</span> plane stress, <span
class="math inline">\(2D\)</span> plane strain and <span
class="math inline">\(2D\)</span> generalized plane strain.</li>
</ul>
<figure>
<img src="img/pipe.svg"
title="The `Pipe` orthotropic axes convention for (3D), (2D) axysymmetric, (1D) axisymmetric generalised plane strain or generalised plane stress (left) and (2D) plane stress, strain, generalized plane strain (right)"
style="width:50.0%"
alt="The Pipe orthotropic axes convention for 3D, 2D axysymmetric, 1D axisymmetric generalised plane strain or generalised plane stress (left) and 2D plane stress, strain, generalized plane strain (right)" />
<figcaption aria-hidden="true">The <code>Pipe</code> orthotropic axes
convention for <span class="math inline">\(3D\)</span>, <span
class="math inline">\(2D\)</span> axysymmetric, <span
class="math inline">\(1D\)</span> axisymmetric generalised plane strain
or generalised plane stress (left) and <span
class="math inline">\(2D\)</span> plane stress, strain, generalized
plane strain (right)</figcaption>
</figure>
<p>With those conventions, named <code>Pipe</code> in
<code>MFront</code>, the axial direction is either the second or the
third material axis, a fact that must be taken into account when
defining the stiffness tensor, the Hill tensor(s), the thermal
expansion, etc.</p>
<p>This convention is only valid for <span
class="math inline">\(3D\)</span>, <span
class="math inline">\(2D\)</span> axysymmetric, <span
class="math inline">\(1D\)</span> axisymmetric generalised plane strain
or generalised plane stress. - <span
class="math inline">\(\left(rr,tt,zz,...\right)\)</span> in <span
class="math inline">\(2D\)</span> plane stress, strain, generalized
plane strain.</p>
<figure>
<img src="img/plate.svg" title="The `Plate` orthotropic axes convention"
style="width:50.0%" alt="The Plate orthotropic axes convention" />
<figcaption aria-hidden="true">The <code>Plate</code> orthotropic axes
convention</figcaption>
</figure>
<p>If we were to model plates, an appropriate convention is the
following:</p>
<ul>
<li>The first material axis is the rolling direction</li>
<li>The second material axis is the in plane direction perpendicular to
the rolling direction (transverse direction).</li>
<li>The third material axis is the normal to the plate.</li>
</ul>
<p>By definition, this convention, named <code>Plate</code> in
<code>MFront</code> is only valid for <span
class="math inline">\(3D\)</span>, <span
class="math inline">\(2D\)</span> plane stress, <span
class="math inline">\(2D\)</span> plane strain and <span
class="math inline">\(2D\)</span> generalized plane strain modelling
hypotheses.</p>
<h1 id="isotropic-elastic-moduli">Isotropic elastic moduli</h1>
<p>Three data structures are defined to represent the isotropic moduli
of an isotropic material:</p>
<ul>
<li><code>KGModuli</code> (attributes:
<code>kappa</code>,<code>mu</code>)</li>
<li><code>YoungNuModuli</code> (attributes:
<code>young</code>,<code>nu</code>)</li>
<li><code>LambdaMuModuli</code> (attributes:
<code>lambda</code>,<code>mu</code>)</li>
</ul>
<p>It can be constructed as follows:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG <span class="op">=</span> KGModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>ka<span class="op">,</span>mu<span class="op">);</span></span></code></pre></div>
<p>And its attributes can be recovered as follows:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> K <span class="op">=</span> KG<span class="op">.</span>kappa<span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> G <span class="op">=</span> KG<span class="op">.</span>mu<span class="op">;</span></span></code></pre></div>
<p>It can be converted to the other describing isotropic moduli as
follows:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> Enu <span class="op">=</span> KG<span class="op">.</span>ToYoungNu<span class="op">();</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> LambdaMu <span class="op">=</span> KG<span class="op">.</span>ToLambdaMu<span class="op">();</span></span></code></pre></div>
<p>Moreover, some useful functions allow to go from one to another:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C <span class="op">=</span> computeIsotropicStiffnessTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>Enu<span class="op">);</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG <span class="op">=</span> computeKGModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C<span class="op">);</span></span></code></pre></div>
<p>Note that <code>computeKGModuli</code> makes a projection on the
fourth-order tensors <span
class="math inline">\(\underline{\underline{\mathbf{J}}}\)</span> and
<span class="math inline">\(\underline{\underline{\mathbf{K}}}\)</span>
if <span
class="math inline">\(\underline{\underline{\mathbf{C}}}\)</span> is not
isotropic. It can be check that <span
class="math inline">\(\underline{\underline{\mathbf{C}}}\)</span> is
isotropic by doing</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> eps <span class="op">=</span> <span class="fl">1e-6</span><span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">bool</span> <span class="op">=</span> isIsotropic<span class="op">(</span>C<span class="op">,</span>eps<span class="op">);</span></span></code></pre></div>
<p>Here, <code>isIsotropic</code> first projects <span
class="math inline">\(\underline{\underline{\mathbf{C}}}\)</span> on the
isotropic basis, and constructs the isotropized of <span
class="math inline">\(\underline{\underline{\mathbf{C}}}\)</span>. Then,
it computes the relative difference between <span
class="math inline">\(\underline{\underline{\mathbf{C}}}\)</span> and
its isotropized, by using the <span
class="math inline">\(L2\)</span>-norm. This difference is compared to
the tolerance <code>eps</code>.</p>
<h1 id="homogenization">Homogenization</h1>
<p>The homogenization functions are part of the namespace
<code>tfel::material::homogenization</code>. A specialization for
elasticity is defined:
<code>tfel::material::homogenization::elasticity</code>.</p>
<h2 id="eshelby-hill-and-localisation-tensors">Eshelby, Hill and
localisation tensors</h2>
<h3 id="definitions">Definitions</h3>
<p>If we consider a constant stress-free strain <span
class="math inline">\(\underline{\varepsilon}^\mathrm{T}\)</span>
filling an ellipsoidal volume embedded in an infinite homogeneous medium
whose elasticity is <span
class="math inline">\(\underline{\underline{\mathbf{C}}}_0\)</span>, the
strain tensor inside the ellipsoid is given by</p>
<p><span
class="math inline">\(\underline{\varepsilon}=\underline{\underline{\mathbf{S}}}_0:\underline{\varepsilon}^\mathrm{T}\)</span>.</p>
<p>where <span
class="math inline">\(\underline{\underline{\mathbf{S}}}_0\)</span> is
the Eshelby tensor. The Hill tensor <span
class="math inline">\(\underline{\underline{\mathbf{P}}}_0\)</span>
gives the strain tensor inside the ellipsoid as a function of the
polarization tensor <span class="math inline">\(\underline{\tau }=
-\underline{\underline{\mathbf{C}}}_0:\underline{\varepsilon}^\mathrm{T}\)</span>
:</p>
<p><span
class="math inline">\(\underline{\varepsilon}=-\underline{\underline{\mathbf{P}}}_0:\underline{\tau}\)</span>.</p>
<p>Note that <span
class="math inline">\(\quad\underline{\underline{\mathbf{P}}}_0=\underline{\underline{\mathbf{S}}}_0:\underline{\underline{\mathbf{C}}}_0^{-1}\)</span></p>
<p>The expressions of Eshelby tensor can be found in <span
class="citation" data-cites="torquato_2002">[5]</span> for the
spheroidal inclusions and in <span class="citation"
data-cites="eshelby_1957">[6]</span> for the general ellipsoid (three
different semi-axes).</p>
<p>Now if we consider an ellipsoid whose elasticity is <span
class="math inline">\(\underline{\underline{\mathbf{C}}}_i\)</span>,
embedded in an infinite homogeneous medium whose elasticity is <span
class="math inline">\(\underline{\underline{\mathbf{C}}}_0\)</span>,
submitted to a external uniform strain field at infinity <span
class="math inline">\(\underline{E}\)</span>, the strain field within
the ellipsoid is uniform and given by</p>
<p><span class="math inline">\(\underline{\varepsilon }=
\underline{\underline{\mathbf{A}}}:\underline{E}\)</span></p>
<p>where <span
class="math inline">\(\underline{\underline{\mathbf{A}}}\)</span> is the
strain localisation (or concentration) tensor.</p>
<h3 id="computation-in-isotropic-reference-medium">Computation in
isotropic reference medium</h3>
<h4 id="eshelby-and-hill-tensors">Eshelby and Hill tensors</h4>
<p>The header <code>IsotropicEshelbyTensor.hxx</code> introduces the
computation of the Eshelby tensors and Hill tensors of general
ellipsoids embedded in an isotropic medium.</p>
<p>We can compute the Hill tensors as follows:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> tfel<span class="op">::</span>material<span class="op">::</span>homogenization<span class="op">::</span>elasticity<span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0 <span class="op">=</span> computeSphereHillPolarisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">);</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_axi <span class="op">=</span> computeAxisymmetricalHillPolarisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>n_a<span class="op">,</span>e<span class="op">);</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_ellipsoid <span class="op">=</span> computeHillPolarisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span></code></pre></div>
<p>Here, the first line compute the Hill tensor for a sphere. The second
one computes the Hill tensor for an axisymmetrical ellipsoid (or
spheroidal inclusion). The user must provides the normal vector
<code>n_a</code> for the axis, and <code>e</code> for the aspect ratio.
The third line computes the Hill tensor of a more general ellipsoid
whose semi-axis lengths are
<code>a</code>,<code>b</code>,<code>c</code>. The axis <code>a</code> is
related to direction given by <code>n_a</code> and <code>b</code> is
related to the direction given by <code>n_b</code>, which must be normal
to <code>n_a</code>.</p>
<p>An <code>IsotropicModuli</code> can also be passed for the
elasticity, as follows:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> IM0<span class="op">=</span>YoungNuModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">);</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0 <span class="op">=</span> computeSphereHillPolarisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">);</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_axi <span class="op">=</span> computeAxisymmetricalHillPolarisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>n_a<span class="op">,</span>e<span class="op">);</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_ellipsoid <span class="op">=</span> computeHillPolarisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span></code></pre></div>
<p>The Eshelby tensors can be computed as follows:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0 <span class="op">=</span> computeSphereEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>nu0<span class="op">);</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0_axi <span class="op">=</span> computeAxisymmetricalEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>nu0<span class="op">,</span>e<span class="op">);</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0_ellipsoid <span class="op">=</span> computeEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>nu0<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span></code></pre></div>
<p>Note that the Eshelby tensors are not related to a basis, so that it
is recommended to use the Hill tensors instead. In 2 dimensional
framework, Eshelby tensors and Hill tensors are computed as follows:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0_D <span class="op">=</span> computeDiskPlaneStrainEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>nu0<span class="op">);</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0_C <span class="op">=</span> computePlaneStrainEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>nu0<span class="op">,</span>e<span class="op">);</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> IM0<span class="op">=</span>YoungNuModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">);</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_D <span class="op">=</span> computeDiskPlaneStrainHillTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">);</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_C <span class="op">=</span> computePlaneStrainHillTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">);</span></span></code></pre></div>
<p>The <code>computeDiskPlaneStrain</code> refers to a disk in plane
strain framework, whereas the <code>computePlaneStrain</code> refers to
an ellipse oriented by <code>n_a</code>, in a plane strain
framework.</p>
<h4 id="localisation-or-concentration-tensors">Localisation (or
concentration) tensors</h4>
<p>The header <code>LocalisationTensor.hxx</code> also introduces the
computation of the strain localisation tensors of an ellipsoid. These
localisation tensors can be computed as follows:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A <span class="op">=</span> computeSphereLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>Ei<span class="op">,</span>nui<span class="op">);</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_axi <span class="op">=</span> computeAxisymmetricalLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>Ei<span class="op">,</span>nui<span class="op">,</span>n_a<span class="op">,</span>e<span class="op">);</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_ellipsoid <span class="op">=</span> computeLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>Ei<span class="op">,</span>nui<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span></code></pre></div>
<p>Here, the subscript <code>i</code> refers to the inclusion. Here
again, an <code>IsotropicModuli</code> can be passed for the elasticity,
as follows:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> IM0<span class="op">=</span>YoungNuModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">);</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> IMi<span class="op">=</span>YoungNuModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>Ei<span class="op">,</span>nui<span class="op">);</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A <span class="op">=</span> computeSphereLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>IMi<span class="op">);</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_axi <span class="op">=</span> computeAxisymmetricalLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>e<span class="op">);</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_ellipsoid <span class="op">=</span> computeLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span></code></pre></div>
<p>Note that if the elasticity of the inclusion is not isotropic, an
anisotropic elasticity <code>C_i</code> can be provided, assuming that
this elasticiy is expressed in the same basis as the one defined by
<code>n_a,n_b</code> (the local basis of the inclusion):</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_aniso <span class="op">=</span> computeLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>C_i<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span></code></pre></div>
<p>In 2 dimensional framework, localisation tensors are computed as
follows:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_D <span class="op">=</span> computeDiskPlaneStrainLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>C_i<span class="op">);</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_C <span class="op">=</span> computePlaneStrainLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>C_i<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">);</span></span></code></pre></div>
<h3 id="computation-in-anisotropic-reference-medium">Computation in
anisotropic reference medium</h3>
<p>The header <code>AnisotropicEshelbyTensor.hxx</code> introduces the
computation of the Eshelby tensors and Hill tensors of general
ellipsoids embedded in an anisotropic medium.</p>
<p>These tensors can be computed as follows:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0 <span class="op">=</span> computeAnisotropicHillTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0_2d <span class="op">=</span> computePlaneStrainAnisotropicHillTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">);</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0 <span class="op">=</span> computeAnisotropicEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> S0_2d <span class="op">=</span> computePlaneStrainAnisotropicEshelbyTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">);</span></span></code></pre></div>
<p>The tensors are computed via an integration on a bi-dimensional
domain. The integration is iterative, and the user can provide the
number of iterations (basically, it corresponds to the number of
subdivisions in each domain direction). Hence, more iterations lead to a
more accurate results, but longer to compute. The default number of
iterations is <code>12</code>, but is is recommended to increase it for
sharp ellipsoids:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="bu">std::</span>size_t it <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> </span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0 <span class="op">=</span> computeAnisotropicHillTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">,</span><span class="dv">10</span><span class="op">);</span></span></code></pre></div>
<p>The localisation tensors are introduced in the same header
<code>AnisotropicEshelbyTensor.hxx</code>. We can do as follows:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A <span class="op">=</span> computeAnisotropicLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0_glob<span class="op">,</span>Ci_loc<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> A_2d <span class="op">=</span> computePlaneStrainAnisotropicLocalisationTensor<span class="op">&lt;</span>stress<span class="op">&gt;(</span>C0_glob<span class="op">,</span>Ci_loc<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">);</span></span></code></pre></div>
<p>The user must provide the elasticity of the inclusion as a
<code>st2tost2</code> <code>Ci_loc</code>, and if it is not isotropic,
it must be provided in the local basis defined by
<code>n_a,n_b</code>.</p>
<h2 id="homogenization-schemes-for-biphasic-media">Homogenization
schemes for biphasic media</h2>
<p>Different classical mean-field homogenization schemes are implemented
for biphasic media. These schemes are introduced by the header
<code>LinearHomogenizationSchemes.hxx</code>. They only deal with
isotropic matrices and locally isotropic inclusions (for anisotropic
matrices or inclusions, see the section “Homogenization of general
microstructures”).</p>
<p>The available schemes are:</p>
<ul>
<li>Mori-Tanaka scheme</li>
<li>dilute scheme</li>
<li>Ponte Castaneda and Willis scheme</li>
</ul>
<p>Each scheme is based on the average of the localisation tensor <span
class="math inline">\(\underline{A}\)</span> defined above. This average
is computed assuming different distributions of ellipsoids. Hence
different cases are considered:</p>
<ul>
<li>spheres (no orientations)</li>
<li>oriented ellipsoids (two vectors <span
class="math inline">\(\underline{n}_a,\underline{n}_b\)</span> define
the orientation)</li>
<li>uniform isotropic distribution of orientations (the ellipsoids have
no preferential orientation)</li>
<li>transverse isotropic distribution of orientations (one axis <span
class="math inline">\(\underline{n}_a\)</span> of the ellipsoid is
fixed, the others are uniformly distributed in the transverse
plane)</li>
</ul>
<p>Hence we can compute the homogenized stiffness returned by the
available schemes. For example, for the distribution of spheres:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> IM0<span class="op">=</span>YoungNuModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">);</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> IMi<span class="op">=</span>YoungNuModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>Ei<span class="op">,</span>nui<span class="op">);</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG_DS <span class="op">=</span> computeSphereDiluteScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">);</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG_MT <span class="op">=</span> computeSphereMoriTanakaScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">);</span></span></code></pre></div>
<p>Note that the two above schemes return a <code>KGModuli</code> object
(see <a href="tfel-material.html#isotropic-elastic-moduli">above</a>).
Also, <code>f</code> is the volume fraction, and the subscript
<code>0</code> refers to the matrix, and the subscript <code>i</code>
refers to the inclusion.</p>
<p>For the oriented inclusions, we can do:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_DS <span class="op">=</span> computeOrientedDiluteScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_MT <span class="op">=</span> computeOrientedMoriTanakaScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_PCW <span class="op">=</span> computeOrientedPCWScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>n_b<span class="op">,</span>b<span class="op">,</span>c<span class="op">,</span>D<span class="op">);</span></span></code></pre></div>
<p>Here, the three above schemes return <code>st2tost2</code> objects.
Note that <code>PCW</code> refers to the Ponte-Castaneda and Willis
scheme. For this scheme, a <code>Distribution</code> object must be
created by the user. It is defined by two vectors <span
class="math inline">\(\underline{n}_a,\underline{n}_b\)</span> and three
lengths <span class="math inline">\(a,b,c\)</span> that define the
ellipsoid which defines the distribution:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>Distribution<span class="op">&lt;</span>stress<span class="op">&gt;</span> D <span class="op">=</span> <span class="op">{.</span>n_a <span class="op">=</span> n_a<span class="op">,</span> <span class="op">.</span>a <span class="op">=</span> a<span class="op">,</span> <span class="op">.</span>n_b <span class="op">=</span> n_b<span class="op">,</span> <span class="op">.</span>b <span class="op">=</span> b<span class="op">,</span> <span class="op">.</span>c <span class="op">=</span> c<span class="op">};</span></span></code></pre></div>
<p>For the isotropic distribution of ellipsoids, we can do:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG_DS <span class="op">=</span> computeIsotropicDiluteScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG_MT <span class="op">=</span> computeIsotropicMoriTanakaScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_PCW <span class="op">=</span> computeIsotropicPCWScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">,</span>D<span class="op">);</span></span></code></pre></div>
<p>Here, the two first schemes return <code>KGModuli</code> objects,
whereas <code>computeIsotropicPCWScheme</code> returns a
<code>st2tost2</code> object. For this latter case, the ellipsoids have
indeed a uniform isotropic distribution of orientations, but the user
might use a non-isotropic <code>Distribution D</code>. And finally, we
can consider a transverse isotropic distribution of inclusions:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_DS <span class="op">=</span> computeTransverseIsotropicDiluteScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_MT <span class="op">=</span> computeTransverseIsotropicMoriTanakaScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_PCW <span class="op">=</span> computeTransverseIsotropicPCWScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>IM0<span class="op">,</span>f<span class="op">,</span>IMi<span class="op">,</span>n_a<span class="op">,</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">,</span>D<span class="op">);</span></span></code></pre></div>
<p>Here, the three above schemes return <code>st2tost2</code> objects.
Because the functions are based on the average of the localisation
tensor <span class="math inline">\(\underline{A}\)</span> associated
with each distribution, a <code>Base</code> function is also defined for
each scheme, that only takes in argument the average of the localisation
tensor <code>A_av</code>. We then can compute a homogenized stiffness
with a very general averaged localisator:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_DS <span class="op">=</span> computeDiluteScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>f<span class="op">,</span>Ei<span class="op">,</span>nui<span class="op">,</span>A_av<span class="op">);</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_MT <span class="op">=</span> computeMoriTanakaScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>f<span class="op">,</span>Ei<span class="op">,</span>nui<span class="op">,</span>A_av<span class="op">);</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C_PCW <span class="op">=</span> computePCWScheme<span class="op">&lt;</span>stress<span class="op">&gt;(</span>E0<span class="op">,</span>nu0<span class="op">,</span>f<span class="op">,</span>Ei<span class="op">,</span>nui<span class="op">,</span>A_av<span class="op">,</span>D<span class="op">);</span></span></code></pre></div>
<p>Here, the three above schemes return <code>st2tost2</code> objects. A
tutorial on the computation of homogenized schemes for biphasic
particulate microstructures is available <a
href="BiphasicLinearHomogenization.html">here</a>.</p>
<h2 id="homogenization-bounds">Homogenization bounds</h2>
<p>Different bounds are implemented and are introduced by the header
<code>LinearHomogenizationBounds.hxx</code>. The available bounds
are:</p>
<ul>
<li>Voigt bound</li>
<li>Reuss bound</li>
<li>Hashin-Shtrikman bounds</li>
</ul>
<p>Here are some examples of computation:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">//Voigt and Reuss bounds</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>real<span class="op">&gt;</span> tab_f<span class="op">={</span>real<span class="op">(</span><span class="fl">0.2</span><span class="op">),</span>real<span class="op">(</span><span class="fl">0.8</span><span class="op">)};</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C0 <span class="op">=</span> stress<span class="op">(</span><span class="fl">1e9</span><span class="op">)*</span>Stensor4<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span>real<span class="op">&gt;::</span>Id<span class="op">();</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C1 <span class="op">=</span> stress<span class="op">(</span><span class="fl">1e7</span><span class="op">)*</span>Stensor4<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span>real<span class="op">&gt;::</span>Id<span class="op">();</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>Stensor4<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span>stress<span class="op">&gt;&gt;</span> tab_C<span class="op">={</span>C0<span class="op">,</span>C1<span class="op">};</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> Stensor4<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span>real<span class="op">&gt;</span> CV <span class="op">=</span> computeVoigtStiffness<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span> stress<span class="op">&gt;(</span>tab_f<span class="op">,</span> tab_C<span class="op">);</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> Stensor4<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span>real<span class="op">&gt;</span> CR <span class="op">=</span> computeReussStiffness<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span> stress<span class="op">&gt;(</span>tab_f<span class="op">,</span> tab_C<span class="op">);</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="co">//Hashin-Shtrikman bounds</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> K0<span class="op">=</span>stress<span class="op">(</span><span class="dv">1</span><span class="op">/</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> G0<span class="op">=</span>stress<span class="op">(</span><span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> K1<span class="op">=</span>stress<span class="op">(</span><span class="dv">2</span><span class="op">/</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> G1<span class="op">=</span>stress<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb28-15"><a href="#cb28-15" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> K2<span class="op">=</span>stress<span class="op">(</span><span class="dv">5</span><span class="op">/</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb28-16"><a href="#cb28-16" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> G2<span class="op">=</span>stress<span class="op">(</span><span class="dv">5</span><span class="op">/</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb28-17"><a href="#cb28-17" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>real<span class="op">&gt;</span> tab_f<span class="op">={</span>real<span class="op">(</span><span class="fl">0.1</span><span class="op">),</span>real<span class="op">(</span><span class="fl">0.8</span><span class="op">),</span>real<span class="op">(</span><span class="fl">0.1</span><span class="op">)};</span></span>
<span id="cb28-18"><a href="#cb28-18" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>stress<span class="op">&gt;</span> tab_K<span class="op">={</span>K0<span class="op">,</span>K1<span class="op">,</span>K2<span class="op">};</span></span>
<span id="cb28-19"><a href="#cb28-19" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>stress<span class="op">&gt;</span> tab_mu<span class="op">={</span>G0<span class="op">,</span>G1<span class="op">,</span>G2<span class="op">};</span></span>
<span id="cb28-20"><a href="#cb28-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-21"><a href="#cb28-21" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> pair <span class="op">=</span> computeIsotropicHashinShtrikmanBounds<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span> stress<span class="op">&gt;(</span>tab_f<span class="op">,</span> tab_K<span class="op">,</span> tab_mu<span class="op">);</span></span>
<span id="cb28-22"><a href="#cb28-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-23"><a href="#cb28-23" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> LB <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>pair<span class="op">);</span></span>
<span id="cb28-24"><a href="#cb28-24" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> K_L <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>LB<span class="op">);</span></span>
<span id="cb28-25"><a href="#cb28-25" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> mu_L <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>LB<span class="op">);</span></span>
<span id="cb28-26"><a href="#cb28-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-27"><a href="#cb28-27" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> UB <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>pair<span class="op">);</span></span>
<span id="cb28-28"><a href="#cb28-28" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> K_U <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;(</span>UB<span class="op">);</span></span>
<span id="cb28-29"><a href="#cb28-29" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> mu_U <span class="op">=</span> <span class="bu">std::</span>get<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;(</span>UB<span class="op">);</span></span></code></pre></div>
<p>Note that Voigt and Reuss bounds work on <code>st2tost2</code> (or
<code>Stensor4</code>) objects, whereas Hashin-Shtrikman bounds work on
bulk and shear moduli. The number of phases is arbitrary, and the
dimension is 2 or 3.</p>
<h2 id="homogenization-of-general-microstructures">Homogenization of
general microstructures</h2>
<p>A <code>ParticulateMicrostructure</code> object can be created for
homogenization of general matrix-inclusion microstructures.</p>
<h3 id="description-and-construction-of-a-microstructure">Description
and construction of a microstructure</h3>
<h4 id="the-particulatemicrostructure-class">The
<code>ParticulateMicrostructure class</code></h4>
<p>The <code>ParticulateMicrostructure class</code> is available in 3d
an 2d via 2 template parameters:
<code>ParticulateMicrostructure&lt;N,stress&gt;</code> with
<code>N</code> the dimension. For the details, see the file
‘MicrostructureDescription.hxx’ which introduces the
<code>class</code>.</p>
<p>A <code>ParticulateMicrostructure</code> consists on a matrix, in
which are embedded several distributions of inclusions. The class has
three (private) attributes:</p>
<ul>
<li><code>number_of_phases</code></li>
<li><code>matrixPhase</code></li>
<li><code>inclusionPhases</code></li>
</ul>
<p>The <code>matrixPhase</code> is of type <code>Phase</code>, described
below.</p>
<p>The <code>inclusionPhases</code> is a <code>std::vector</code> of
pointers on <code>InclusionDistribution</code> objects (which represent
the distributions of inclusions). This class is also described
below.</p>
<p>We can instantiate a <code>ParticulateMicrostructure</code> as
follows, passing the matrix elasticity as an argument:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> tfel<span class="op">::</span>material<span class="op">::</span>homogenization<span class="op">::</span>elasticity<span class="op">;</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> IM0<span class="op">=</span>tfel<span class="op">::</span>material<span class="op">::</span>KGModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span><span class="fl">1e7</span><span class="op">,</span><span class="fl">1e7</span><span class="op">);</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> micro_1<span class="op">=</span>ParticulateMicrostructure<span class="op">(</span>IM0<span class="op">);</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C0 <span class="op">=</span> stress<span class="op">(</span><span class="fl">1e9</span><span class="op">)*</span>Stensor4<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span>real<span class="op">&gt;::</span>Id<span class="op">();</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> micro_2<span class="op">=</span>ParticulateMicrostructure<span class="op">(</span>C0<span class="op">);</span></span></code></pre></div>
<p><code>ParticulateMicrostructure</code> has also some methods (see
‘MicrostructureDescription.hxx’ for details). The following ones allow
to get some attributes of the class:</p>
<ul>
<li><code>get_number_of_phases</code></li>
<li><code>get_matrix_fraction</code> (attribute <code>fraction</code> of
<code>matrixPhase</code>)</li>
<li><code>get_matrix_elasticity</code> (attribute <code>stiffness</code>
of <code>matrixPhase</code>)</li>
<li><code>is_isotropic_matrix</code> (private attribute
<code>is_isotropic</code> of <code>matrixPhase</code>)</li>
</ul>
<p>Last method returns a boolean which states if the matrix is
considered isotropic or not. In fact, depending on how was instantiated
the <code>ParticulateMicrostructure</code>, the matrix is considered
isotropic or not. For example, by doing</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> val_1<span class="op">=</span>micro_1<span class="op">.</span>is_isotropic_matrix<span class="op">();</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> val_2<span class="op">=</span>micro_2<span class="op">.</span>is_isotropic_matrix<span class="op">();</span></span></code></pre></div>
<p><code>val_1</code> will be <code>True</code> because
<code>micro_1</code> was instantiated above with a
<code>KGModuli</code>, whereas <code>val_2</code> will be
<code>False</code>. Note that <code>False</code> does not mean that the
matrix elasticity is not isotropic, but that it is CONSIDERED as not
isotropic.</p>
<p>Other methods allows to add/remove <code>InclusionDistribution</code>
objects to the attribute <code>inclusionPhases</code>, and also to
replace <code>matrixPhase</code>:</p>
<ul>
<li><code>get_inclusionPhase</code></li>
<li><code>addInclusionPhase</code></li>
<li><code>removeInclusionPhase</code></li>
<li><code>replaceMatrixPhase</code></li>
</ul>
<p>But we first describe <code>Phase</code>,
<code>InclusionDistribution</code> and <code>Inclusion</code>
classes.</p>
<h4 id="the-phase-class">The <code>Phase</code> class</h4>
<p>The <code>Phase class</code> is very simple. It has two
attributes:</p>
<ul>
<li><code>fraction</code> (<code>real</code> type)</li>
<li><code>stiffness</code> (<code>st2tost2</code> type)</li>
</ul>
<p>and one method: <code>is_isotropic()</code> which returns a
<code>bool</code> stating if the phase is considered isotropic or not.
Again, the value of this <code>bool</code> depends on the way the
<code>Phase</code> was constructed. By doing</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> C0<span class="op">=</span>tfel<span class="op">::</span>math<span class="op">::</span>st2tost2<span class="op">&lt;</span>stress<span class="op">&gt;::</span>Id<span class="op">();</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>Phase<span class="op">&lt;</span>stress<span class="op">&gt;</span> ph<span class="op">(</span>f<span class="op">,</span>C0<span class="op">);</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> b <span class="op">=</span> ph<span class="op">.</span>is_isotropic<span class="op">();</span></span></code></pre></div>
<p><code>b</code> will have the value <code>false</code>, whereas by
doing</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KG<span class="op">=</span>tfel<span class="op">::</span>material<span class="op">::</span>KGModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>k<span class="op">,</span>g<span class="op">);</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>Phase<span class="op">&lt;</span>stress<span class="op">&gt;</span> ph<span class="op">(</span>f<span class="op">,</span>KG<span class="op">);</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> b <span class="op">=</span> ph<span class="op">.</span>is_isotropic<span class="op">();</span></span></code></pre></div>
<p><code>b</code> will have the value <code>true</code>. Hence, when a
<code>ParticulateMicrostructure</code> is instantiated, it automatically
instantiates a <code>Phase</code> object corresponding to the attribute
<code>matrixPhase</code>. However, we note that the user can construct a
microstructure without using <code>Phase</code> instantiation
himself.</p>
<h4 id="the-inclusion-class">The <code>Inclusion class</code></h4>
<p>Before describing the <code>InclusionDistribution class</code>, we
must describe the <code>Inclusion class</code>. This latter is
characterized by its unique attribute: <code>semiLengths</code>. It is a
<code>std::array</code> of <code>N</code> lengths, which are the
semi-lengths of the ellipsoid/ellipse, where <code>N</code> is the
dimension considered (2 or 3). Hence, <code>Inclusion</code> has two
template parameters: <code>Inclusion&lt;N,LengthType&gt;</code>. Some
particular <code>Inclusion</code> objects are also defined:</p>
<ul>
<li><code>Ellipsoid</code> (child of <code>Inclusion</code> in 3d)</li>
<li><code>Spheroid</code> (child of <code>Ellipsoid</code> with the last
two semi-lengths identical)</li>
<li><code>Sphere</code> (child of <code>Spheroid</code> with 3
semi-lengths equal to unity)</li>
</ul>
<p>Let us try:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>Ellipsoid<span class="op">&lt;</span>length<span class="op">&gt;</span> ellipsoid1<span class="op">(</span>a<span class="op">,</span>b<span class="op">,</span>c<span class="op">);</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>Spheroid<span class="op">&lt;</span>length<span class="op">&gt;</span> spheroid1<span class="op">(</span>a<span class="op">,</span>b<span class="op">);</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>Sphere<span class="op">&lt;</span>length<span class="op">&gt;</span> sphere1<span class="op">();</span></span></code></pre></div>
<h4 id="the-inclusiondistribution-class">The
<code>InclusionDistribution class</code></h4>
<p>The <code>InclusionDistribution class</code> is an abstract class
which represents a distribution of inclusions. It is a child of the
<code>Phase class</code>, and it is used to represent the distribution
of inclusions in a <code>ParticulateMicrostructure</code>. There are 4
child <code>class</code> of the
<code>InclusionDistribution class</code>:</p>
<ul>
<li><code>SphereDistribution</code> (distribution of spheres)</li>
<li><code>IsotropicDistribution</code> (isotropic distribution of
ellipsoids)</li>
<li><code>TransverseDistribution</code> (transverse isotropic
distribution of ellipsoids)</li>
<li><code>OrientedDistribution</code> (aligned distribution of
ellipsoids)</li>
</ul>
<p>Here are some examples of instantiation:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> KGi<span class="op">=</span>tfel<span class="op">::</span>material<span class="op">::</span>KGModuli<span class="op">&lt;</span>stress<span class="op">&gt;(</span>Ki<span class="op">,</span>Gi<span class="op">);</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>SphereDistribution<span class="op">&lt;</span>stress<span class="op">&gt;</span> distrib_sph<span class="op">(</span>sphere1<span class="op">,</span>f<span class="op">,</span>KGi<span class="op">);</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>IsotropicDistribution<span class="op">&lt;</span>stress<span class="op">&gt;</span> distrib_ell<span class="op">(</span>ellipsoid1<span class="op">,</span>f<span class="op">,</span>KGi<span class="op">);</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>tfel<span class="op">::</span>math<span class="op">::</span>tvector<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span> real<span class="op">&gt;</span> n_a <span class="op">=</span> <span class="op">{</span><span class="fl">1.</span><span class="op">,</span> <span class="fl">0.</span><span class="op">,</span> <span class="fl">0.</span><span class="op">};</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>tfel<span class="op">::</span>math<span class="op">::</span>tvector<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span> real<span class="op">&gt;</span> n_b <span class="op">=</span> <span class="op">{</span><span class="fl">0.</span><span class="op">,</span> <span class="fl">1.</span><span class="op">,</span> <span class="fl">0.</span><span class="op">};</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>OrientedDistribution<span class="op">&lt;</span>stress<span class="op">&gt;</span> distrib_O<span class="op">(</span>ellipsoid1<span class="op">,</span>f<span class="op">,</span>KGi<span class="op">,</span>n_a<span class="op">,</span>n_b<span class="op">);</span></span></code></pre></div>
<p>The <code>TransverseDistribution</code> is a special case which
requires to precise which axis of the ellipsoid (or spheroid) will
remain fixed when the two other axes rotate:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> <span class="dt">short</span> <span class="dt">int</span> index <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>TransverseIsotropicDistribution<span class="op">&lt;</span>stress<span class="op">&gt;</span> distrib_TI<span class="op">(</span>ellipsoid1<span class="op">,</span>f<span class="op">,</span>KGi<span class="op">,</span>n_a<span class="op">,</span>index<span class="op">);</span></span></code></pre></div>
<p>The index can be 0,1 or 2. For a spheroid, giving <code>2</code> for
the <code>index</code> is the same as giving <code>1</code>, because
these 2 axes have the same length.</p>
<p>Note that the <code>OrientedDistribution</code> can be instantiated
with a <code>Stensor4</code> object as elasticity. It is also possible
for a <code>SphereDistribution</code>. It can be useful for considering
anisotropic inclusions. However, the basis in which the
<code>Stensor4</code> elasticity is defined is the local basis for the
<code>OrientedDistribution</code>, that is, the basis defined by
<code>n_a</code> and <code>n_b</code> passed as arguments. For a
<code>SphereDistribution</code>, it is the global basis.</p>
<p>We can now construct our <code>ParticulateMicrostructure</code> by
adding some <code>InclusionDistribution</code> objects:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>micro_1<span class="op">.</span>addInclusionPhase<span class="op">(</span>distrib_sph<span class="op">);</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span> micro_1<span class="op">.</span>get_number_of_phases<span class="op">()&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span> micro_1<span class="op">.</span>get_matrix_fraction<span class="op">()&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>micro_1<span class="op">.</span>addInclusionPhase<span class="op">(</span>distrib_ell<span class="op">);</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span> micro_1<span class="op">.</span>get_number_of_phases<span class="op">()&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span> micro_1<span class="op">.</span>get_matrix_fraction<span class="op">()&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>or remove them:</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>micro_1<span class="op">.</span>removeInclusionPhase<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span> micro_1<span class="op">.</span>get_number_of_phases<span class="op">()&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span> micro_1<span class="op">.</span>get_matrix_fraction<span class="op">()&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>At this stage, we have added the distribution of spheres
<code>distrib_sph</code>, and added the isotropic distribution of
ellipsoids <code>distrib_ell</code>. Afterthat, we have removed the
first inclusion distribution (number <code>0</code>), which is the
distribution of spheres. Hence, only one
<code>InclusionDistribution</code> object remains in the microstructure.
We can get this distribution by doing:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> ell_dist<span class="op">=</span>micro_1<span class="op">.</span>get_inclusionPhase<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span></code></pre></div>
<p>Each <code>InclusionDistribution</code> object has three attributes:
<code>inclusion</code> (which is of type <code>Inclusion</code>, see
above), <code>fraction</code> and <code>stiffness</code> (because they
are attributes of <code>Phase</code> objects). It has also two methods.
The first just states if the distribution was instantiated with an
<code>IsotropicModuli</code> or with a <code>Stensor4</code> object.
Here, it was instantiated with a <code>KGModuli</code>, so that it is
considered isotropic. Hence,</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span> ell_dist<span class="op">.</span>is_isotropic<span class="op">()&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>prints <code>1</code>.</p>
<p>The second method of the distribution allows to compute the mean
strain localisation (or concentration) tensor in the inclusions when
they are embedded in a matrix:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>Ai<span class="op">=</span>ell_dist<span class="op">.</span>computeMeanLocalisator<span class="op">(</span>IM0<span class="op">);</span></span></code></pre></div>
<p>Note that in the latter case, passing <code>C0</code>, a
<code>Stensor4</code> object as an argument of the method will return an
error, because it will be considered that the matrix is not isotropic,
so that computing a average localisator of a distribution of ellipsoids
in an anisotropic matrix is impossible (too complicated). However, it
can be done for other kinds of distributions, like sphere distributions
or distributions of oriented inclusions:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>A1<span class="op">=</span>distrib_sph<span class="op">.</span>computeMeanLocalisator<span class="op">(</span>C0<span class="op">,</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>A2<span class="op">=</span>distrib_O<span class="op">.</span>computeMeanLocalisator<span class="op">(</span>C0<span class="op">,</span><span class="dv">10</span><span class="op">);</span></span></code></pre></div>
<p>Here, the integer <code>10</code> is the number of subdivisions in
the integration process in the computation of the Hill tensor relative
to the inclusions. It is <code>12</code> by default.</p>
<p>A last method of the <code>ParticulateMicrostructure</code> object
allows to replace the matrix phase:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>micro_1.replaceMatrixPhase(C0)<span class="op">;</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>std::cout<span class="op">&lt;&lt;</span> micro_1.get_matrix_elasticity()<span class="op">&lt;&lt;</span> std::endl<span class="op">;</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>std::cout<span class="op">&lt;&lt;</span> micro_1.is_isotropic_matrix()<span class="op">&lt;&lt;</span> std::endl<span class="op">;</span></span></code></pre></div>
<p>Here we see that the matrix is no more isotropic because it was
replaced via a <code>Stensor4</code> object <code>C0</code>.</p>
<p>Note that the 4 <code>InclusionDistribution</code> classes are
currently available in 3d only.</p>
<h3 id="computation-of-homogenization-schemes">Computation of
homogenization schemes</h3>
<p>The file <code>MicrostructureLinearHomogenization.ixx</code>
introduces the <code>HomogenizationScheme class</code> which has three
attributes:</p>
<ul>
<li><code>homogenized_stiffness</code></li>
<li><code>effective_polarisation</code></li>
<li><code>mean_strain_localisation_tensors</code></li>
</ul>
<p>This is the object that return the functions listed below:</p>
<ul>
<li><code>computeDilute</code> (dilute scheme)</li>
<li><code>computeMoriTanaka</code> (Mori-Tanaka scheme)</li>
<li><code>computeSelfConsistent</code> (Self-Consistent scheme)</li>
</ul>
<p>These functions take a <code>ParticulateMicrostructure</code> as an
argument and returns a <code>HomogenizationScheme</code> object.</p>
<p>Let us try:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> tfel<span class="op">::</span>material<span class="op">::</span>homogenization<span class="op">::</span>elasticity<span class="op">;</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> hmDS<span class="op">=</span>computeDilute<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span>stress<span class="op">&gt;(</span>micro_1<span class="op">);</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> hmMT<span class="op">=</span>computeMoriTanaka<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span>stress<span class="op">&gt;(</span>micro_1<span class="op">);</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> hmSC<span class="op">=</span>computeSelfConsistent<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span>stress<span class="op">&gt;(</span>micro_1<span class="op">,</span><span class="dv">10</span><span class="op">,</span><span class="kw">true</span><span class="op">);</span></span></code></pre></div>
<p>We note that <code>computeSelfConsistent</code> not only takes the
microstructure as an argument, but also takes one integer
(<code>10</code>) as a parameter, which is the maximum number of
iteration in the self-consistent iterative algorithm. Moreover, the
<code>bool</code> parameter (<code>true</code>) precises if the
computation considers an isotropic matrix when computing the Hill
tensors relative to the inclusions, at each iteration of the algorithm.
Indeed, the homogenized stiffness may be non isotropic, so that the user
can make the choice of isotropizing this homogenized stiffness at each
iteration. Otherwise, he can put <code>False</code>, so that a numerical
integration (resulting in a slower computation) will be performed to
compute the Hill tensors. Moreover, an integer parameter can be added
after the boolean, that indicates the number of subdivisions in the
numerical integration. This value is <code>12</code> by default:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>micro_2.addInclusionPhase(distrib_O)<span class="op">;</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>hmSC_iso<span class="op">=</span>computeSelfConsistent<span class="op">&lt;</span><span class="dv">3</span><span class="er">u</span>,stress<span class="op">&gt;</span>(micro_2,<span class="dv">10</span>,<span class="va">True</span>)<span class="op">;</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>hmSC_aniso<span class="op">=</span>computeSelfConsistent<span class="op">&lt;</span><span class="dv">3</span><span class="er">u</span>,stress<span class="op">&gt;</span>(micro_2,<span class="dv">10</span>,<span class="va">False</span>,<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>std::cout<span class="op">&lt;&lt;</span> <span class="st">&quot;SC iso: &quot;</span><span class="op">&lt;&lt;</span> hmSC_iso.homogenized_stiffness<span class="op">&lt;&lt;</span> std::endl<span class="op">;</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>std::cout<span class="op">&lt;&lt;</span> <span class="st">&quot;SC aniso: &quot;</span><span class="op">&lt;&lt;</span> hmSC_aniso.homogenized_stiffness<span class="op">&lt;&lt;</span> std::endl<span class="op">;</span></span></code></pre></div>
<p>(the “std::cout” does not work when using quantities). For the oter
schemes, the isotropic character of the matrix when computing the strain
localisators will depend on what returns
<code>micro_1.is_isotropic_matrix()</code>. Hence, it is important to
initialized the matrix or the microstructure with the appropriate
elastic moduli. If isotropic, it will works in all case, whereas if not
isotropic, it will fail depending on the distributions that are present
in the microstructure. Moreover, if anisotropic, another parameter can
be passed to specify the number of subdivisions in the numerical
integration (this value is <code>12</code> by default):</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode py"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>micro_1.replaceMatrixPhase(C0)<span class="op">;</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>micro_1.removeInclusionPhase(<span class="dv">0</span>)<span class="op">;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>micro_1.addInclusionPhase(distrib_O)<span class="op">;</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>auto hmDS_aniso<span class="op">=</span>computeDilute<span class="op">&lt;</span><span class="dv">3</span><span class="er">u</span>,stress<span class="op">&gt;</span>(micro_1,<span class="dv">10</span>)<span class="op">;</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>auto hmMT_aniso<span class="op">=</span>computeMoriTanaka<span class="op">&lt;</span><span class="dv">3</span><span class="er">u</span>,stress<span class="op">&gt;</span>(micro_1,<span class="dv">10</span>)<span class="op">;</span></span></code></pre></div>
<p>We can recover the strain localisation tensors as follows:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>A_i_DS<span class="op">=</span>hmDS<span class="op">.</span>mean_strain_localisation_tensors<span class="op">;</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>cout<span class="op">&lt;&lt;</span><span class="st">&quot;A_0_DS: &quot;</span><span class="op">&lt;&lt;</span> A_i_DS<span class="op">[</span><span class="dv">0</span><span class="op">]&lt;&lt;</span><span class="st">&quot;A_1_DS: &quot;</span><span class="op">&lt;&lt;</span> A_i_DS<span class="op">[</span><span class="dv">1</span><span class="op">]&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<p>We can also add a polarization on each phase:</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>micro_1<span class="op">.</span>replaceMatrixPhase<span class="op">(</span>IM0<span class="op">);</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> P0 <span class="op">=</span> Stensor<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span>stress<span class="op">&gt;::</span>zero<span class="op">();</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> Stensor<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span>stress<span class="op">&gt;</span> P1 <span class="op">=</span> <span class="op">{</span>stress<span class="op">(</span><span class="fl">6.e8</span><span class="op">),</span>stress<span class="op">(</span><span class="fl">6.e8</span><span class="op">),</span>stress<span class="op">(</span><span class="fl">6.e8</span><span class="op">),</span>stress<span class="op">(</span><span class="fl">0.</span><span class="op">),</span>stress<span class="op">(</span><span class="fl">0.</span><span class="op">),</span>stress<span class="op">(</span><span class="fl">0.</span><span class="op">)};</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="kw">auto</span> pola<span class="op">={</span>P0<span class="op">,</span>P1<span class="op">};</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> hmDS_pola<span class="op">=</span>computeDilute<span class="op">&lt;</span><span class="dv">3</span><span class="bu">u</span><span class="op">,</span>stress<span class="op">&gt;(</span>micro_1<span class="op">,</span><span class="dv">0</span><span class="op">,</span>pola<span class="op">);</span></span></code></pre></div>
<p>Note that here we must also precise the parameter
<code>max_iter_anisotropic_integration</code> before the optional
argument <code>pola</code>. Here this integer is 0 because it will not
be used, given that the matrix phase is isotropic (see first line). And
we can recover the effective polarization:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">auto</span> P_eff_DS<span class="op">=</span>hmDS_pola<span class="op">.</span>effective_polarisation<span class="op">;</span></span></code></pre></div>
<!-- Local IspellDict: english -->
<div id="refs" class="references csl-bib-body" role="list">
<div id="ref-barlat_linear_2005" class="csl-entry" role="listitem">
<div class="csl-left-margin">1. </div><div
class="csl-right-inline"><span class="smallcaps">Barlat</span>, F.,
<span class="smallcaps">Aretz</span>, H., <span
class="smallcaps">Yoon</span>, J. W., <span
class="smallcaps">Karabin</span>, M. E., <span
class="smallcaps">Brem</span>, J. C. and <span
class="smallcaps">Dick</span>, R. E. Linear transfomation-based
anisotropic yield functions. <em>International Journal of
Plasticity</em>. 1 May 2005. Vol. 21, no. 5, p. 1009–1039. DOI <a
href="https://doi.org/10.1016/j.ijplas.2004.06.004">10.1016/j.ijplas.2004.06.004</a>.
Available from: <a
href="http://www.sciencedirect.com/science/article/pii/S0749641904001160">http://www.sciencedirect.com/science/article/pii/S0749641904001160</a></div>
</div>
<div id="ref-cohen_pade_1991" class="csl-entry" role="listitem">
<div class="csl-left-margin">2. </div><div
class="csl-right-inline"><span class="smallcaps">Cohen</span>, A. A padé
approximant to the inverse langevin function. <em>Rheologica Acta</em>.
1 May 1991. Vol. 30, no. 3, p. 270–273. DOI <a
href="https://doi.org/10.1007/BF00366640">10.1007/BF00366640</a>.
Available from: <a
href="https://doi.org/10.1007/BF00366640">https://doi.org/10.1007/BF00366640</a></div>
</div>
<div id="ref-bergstrom_constitutive_1998" class="csl-entry"
role="listitem">
<div class="csl-left-margin">3. </div><div
class="csl-right-inline"><span class="smallcaps">Bergström</span>, J. S.
and <span class="smallcaps">Boyce</span>, M. C. Constitutive modeling of
the large strain time-dependent behavior of elastomers. <em>Journal of
the Mechanics and Physics of Solids</em>. 1 May 1998. Vol. 46, no. 5,
p. 931–954. DOI <a
href="https://doi.org/10.1016/S0022-5096(97)00075-6">10.1016/S0022-5096(97)00075-6</a>.
Available from: <a
href="https://www.sciencedirect.com/science/article/pii/S0022509697000756">https://www.sciencedirect.com/science/article/pii/S0022509697000756</a></div>
</div>
<div id="ref-jedynak_approximation_2015" class="csl-entry"
role="listitem">
<div class="csl-left-margin">4. </div><div
class="csl-right-inline"><span class="smallcaps">Jedynak</span>,
Radosław. Approximation of the inverse langevin function revisited.
<em>Rheologica Acta</em>. 1 January 2015. Vol. 54, no. 1, p. 29–39.
DOI <a
href="https://doi.org/10.1007/s00397-014-0802-2">10.1007/s00397-014-0802-2</a>.
Available from: <a
href="https://doi.org/10.1007/s00397-014-0802-2">https://doi.org/10.1007/s00397-014-0802-2</a></div>
</div>
<div id="ref-torquato_2002" class="csl-entry" role="listitem">
<div class="csl-left-margin">5. </div><div
class="csl-right-inline"><span class="smallcaps">Torquato</span>,
Salvatore. <a href="https://doi.org/10.1007/978-1-4757-6355-3">Random
heterogeneous materials. Microstructure and macroscopic properties</a>.
Springer, 2002. </div>
</div>
<div id="ref-eshelby_1957" class="csl-entry" role="listitem">
<div class="csl-left-margin">6. </div><div
class="csl-right-inline"><span class="smallcaps">Eshelby</span>, John
Douglas. The determination of the elastic field of an ellipsoidal
inclusion, and related problems. <em>Proceedings of the Royal Society
A</em>. 1957. Vol. 241, no. 1226. DOI <a
href="https://doi.org/10.1098/rspa.1957.0133">10.1098/rspa.1957.0133</a>.
</div>
</div>
</div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-62273823-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
