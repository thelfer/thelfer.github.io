<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-EN" xml:lang="en-EN">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>How to implement the Fichant-La Borderie damage behaviour</title>
        <meta name="author" content="Thomas Helfer, Alexandre Gagnant" />
            <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
    <style type="text/css">code{white-space: pre;}</style>
            <style type="text/css">
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {  background-color: #f8f8f8; }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ef2929; } /* Alert */
      code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #c4a000; } /* Attribute */
      code span.bn { color: #0000cf; } /* BaseN */
      code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4e9a06; } /* Char */
      code span.cn { color: #000000; } /* Constant */
      code span.co { color: #8f5902; font-style: italic; } /* Comment */
      code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
      code span.dt { color: #204a87; } /* DataType */
      code span.dv { color: #0000cf; } /* DecVal */
      code span.er { color: #a40000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #0000cf; } /* Float */
      code span.fu { color: #000000; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
      code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
      code span.ot { color: #8f5902; } /* Other */
      code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
      code span.sc { color: #000000; } /* SpecialChar */
      code span.ss { color: #4e9a06; } /* SpecialString */
      code span.st { color: #4e9a06; } /* String */
      code span.va { color: #000000; } /* Variable */
      code span.vs { color: #4e9a06; } /* VerbatimString */
      code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
    </style>
            <link rel="stylesheet" href="css/normalize.css"/>
    <link rel="stylesheet" href="css/main.css"/>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>
          </head>
  <body>
    <!--[if lt IE 7]>
        <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
    <![endif]-->
        <header>
      <ul id="nav">
	<li><a href="news.html">News</a></li>
	<li><a href="index.html">Overview</a>
	  <ul>
	    <li><a>Domain specific languages</a>
	      <ul>
		<li><a href="material-properties.html">Material properties</a></li>
		<li><a href="behaviours.html">Mechanical behaviours</a></li>
		<li><a href="models.html">Models</a></li>
	      </ul>
            </li>
	    <li><a href="interfaces.html">Available interfaces</a></li>
	    <li><a href="associated-projects.html">Associated projects</a></li>
     	    <li><a>Tools</a>
	      <ul>
	        <li><a href="mfront-doc.html">mfront-doc</a></li>
	        <li><a href="mtest.html">mtest</a></li>
	        <li><a href="mfm.html">mfm</a></li>
	        <li><a href="mfm-test-generator.html">mfm-test-generator</a></li>
	        <li><a href="tfel-check.html">tfel-check</a></li>
	      </ul>
	    </li>
	  </ul>
	</li>
	<li><a>Getting started</a>
	  <ul>
	    <li><a href="https://github.com/thelfer/tfel/">Github repository</a></li>
	    <li><a href="https://github.com/thelfer/tfel/releases">Download</a></li>
	    <li><a href="release-notes.html">Release notes</a>
	      <ul>
		<li><a>Versions 2.0.x</a>
                  <ul>
                    <li><a href="release-notes.html">Versions prior to 2.0.5</a></li>
	 	    <li><a href="release-notes-2.0.5.html">Version 2.0.5</a></li>
                  </ul>
		</li>
		<li><a>Versions 3.0.x</a>
                  <ul>
		    <li><a href="release-notes-3.0.html">Version 3.0.0</a></li>
		    <li><a href="release-notes-3.0.1.html">Version 3.0.1</a></li>
		    <li><a href="release-notes-3.0.2.html">Version 3.0.2</a></li>
		    <li><a href="release-notes-3.0.3.html">Version 3.0.3</a></li>
		    <li><a href="release-notes-3.0.4.html">Version 3.0.4</a></li>
		    <li><a href="release-notes-3.0.5.html">Version 3.0.5</a></li>
		    <li><a href="release-notes-3.0.6.html">Version 3.0.6</a></li>
		    <li><a href="release-notes-3.0.7.html">Version 3.0.7</a></li>
		    <li><a href="release-notes-3.0.8.html">Version 3.0.8</a></li>
		    <li><a href="release-notes-3.0.9.html">Version 3.0.9</a></li>
		    <li><a href="release-notes-3.0.10.html">Version 3.0.10</a></li>
		    <li><a href="release-notes-3.0.11.html">Version 3.0.11</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.1.x</a>
		  <ul>
		    <li><a href="release-notes-3.1.html">Version 3.1.0</a></li>
		    <li><a href="release-notes-3.1.1.html">Version 3.1.1</a></li>
		    <li><a href="release-notes-3.1.2.html">Version 3.1.2</a></li>
		    <li><a href="release-notes-3.1.3.html">Version 3.1.3</a></li>
		    <li><a href="release-notes-3.1.4.html">Version 3.1.4</a></li>
		    <li><a href="release-notes-3.1.5.html">Version 3.1.5</a></li>
		    <li><a href="release-notes-3.1.6.html">Version 3.1.6</a></li>
		    <li><a href="release-notes-3.1.7.html">Version 3.1.7</a></li>
		    <li><a href="release-notes-3.1.8.html">Version 3.1.8</a></li>
		    <li><a href="release-notes-3.1.9.html">Version 3.1.9</a></li>
		    <li><a href="release-notes-3.1.10.html">Version 3.1.10</a></li>
		    <li><a href="release-notes-3.1.11.html">Version 3.1.11</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.2.x</a>
		  <ul>
		    <li><a href="release-notes-3.2.html">Version 3.2.0</a></li>
		    <li><a href="release-notes-3.2.1.html">Version 3.2.1</a></li>
		    <li><a href="release-notes-3.2.2.html">Version 3.2.2</a></li>
		    <li><a href="release-notes-3.2.3.html">Version 3.2.3</a></li>
		    <li><a href="release-notes-3.2.4.html">Version 3.2.4</a></li>
		    <li><a href="release-notes-3.2.5.html">Version 3.2.5</a></li>
		    <li><a href="release-notes-3.2.6.html">Version 3.2.6</a></li>
		    <li><a href="release-notes-3.2.7.html">Version 3.2.7</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.3.x</a>
		  <ul>
		    <li><a href="release-notes-3.3.html">Version 3.3.0</a></li>
		    <li><a href="release-notes-3.3.1.html">Version 3.3.1</a></li>
		    <li><a href="release-notes-3.3.1.html">Version 3.3.2</a></li>
		    <li><a href="release-notes-3.3.2.html">Version 3.3.2</a></li>
		    <li><a href="release-notes-3.3.3.html">Version 3.3.3</a></li>
		  </ul>
		</li>
		<li><a>Versions 3.4.x</a>
		  <ul>
		    <li><a href="release-notes-3.4.html">Version 3.4.0</a></li>
		    <li><a href="release-notes-3.4.1.html">Version 3.4.1</a></li>
		    <li><a href="release-notes-3.4.2.html">Version 3.4.2</a></li>
		    <li><a href="release-notes-3.4.3.html">Version 3.4.3</a></li>
		    <li><a href="release-notes-3.4.4.html">Version 3.4.4</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.0.x</a>
		  <ul>
		    <li><a href="release-notes-4.0.html">Version 4.0.0</a></li>
		    <li><a href="release-notes-4.0.1.html">Version 4.0.1</a></li>
		  </ul>
		</li>
		<li><a>Versions 4.1.x</a>
		  <ul>
		    <li><a href="release-notes-4.1.html">Version 4.1.0</a></li>
		  </ul>
		</li>
	      </ul>
	    </li>
	    <li><a href="coverity-scan.html">Coverity scan</a></li>
	    <li><a href="install.html">Installation</a></li>
	  </ul>
	</li>
	<li><a>Documentation</a>
	  <ul>
	    <li><a href="documentations.html">General documentation</a></li>
	    <li><a href="gallery.html">Gallery</a></li>
	    <li><a href="http://tfel.sourceforge.net/doxygen/index.html">Doxygen documentation</a></li>
	    <li><a>Behaviours</a>
	      <ul>
		<li><a href="tutorial.html">Tutorial</a></li>
		<li><a href="implicit-dsl.html">The Implicit DSL</a></li>
		<li><a href="benchmark.html">Benchmark</a></li>
		<li><a href="parameters.html">Parameters</a></li>
		<li><a href="BehaviourBricks.html">Behaviour bricks</a></li>
		<li><a href="interfaces.html">Solver interfaces</a>
		  <ul>
		    <li><a href="castem.html">Cast3M</a></li>
		    <li><a href="amitex.html">AMITEX_FFTP</a></li>
		    <li><a href="aster.html">Code-Aster</a></li>
    		    <li><a href="abaqus.html">Abaqus</a></li>
    		    <li><a href="epx.html">EUROPLEXUS</a></li>
		    <li><a href="zmat.html">ZeBuLoN</a></li>
   		    <li><a href="calculix.html">CalculiX</a></li>
		    <!-- <li><a >TMFFT</a></li> -->
		    <li><a href="cyrano.html">Cyrano</a></li>
   		    <li><a href="generic-behaviours-interface.html">Generic Behaviour Interface</a></li>
		  </ul>
		</li>
	      </ul>
	    </li>
	    <li><a>TFEL libraries</a>
	      <ul>
		<li><a href="tfel-math.html">TFEL/Math</a></li>
		<li><a href="tfel-material.html">TFEL/Material</a></li>
	      </ul>
	    </li>
	    <li><a>Python modules</a>
	      <ul>
		<li><a href="tfel-python.html">TFEL modules</a></li>
		<li><a href="mfront-python.html">mfront module</a></li>
		<li><a href="mtest-python.html">mtest module</a></li>
	      </ul>
	    </li>
	    <li><a>MFront keywords</a>
	      <ul>
		<li><a href="DefaultDSL-keywords.html">DefaultDSL</a></li> 
		<li><a href="DefaultCZMDSL-keywords.html">DefaultCZMDSL</a></li> 
		<li><a href="DefaultFiniteStrainDSL-keywords.html">DefaultFiniteStrainDSL</a></li> 
		<li><a href="Implicit-keywords.html">Implicit</a></li> 
		<li><a href="ImplicitFiniteStrain-keywords.html">ImplicitFiniteStrain</a></li> 
		<li><a href="ImplicitII-keywords.html">ImplicitII</a></li> 
		<li><a href="IsotropicMisesCreep-keywords.html">IsotropicMisesCreep</a></li> 
		<li><a href="IsotropicPlasticMisesFlow-keywords.html">IsotropicPlasticMisesFlow</a></li> 
		<li><a href="IsotropicStrainHardeningMisesCreep-keywords.html">IsotropicStrainHardeningMisesCreep</a></li> 
		<li><a href="MaterialLaw-keywords.html">MaterialLaw</a></li> 
		<li><a href="Model-keywords.html">Model</a></li> 
		<li><a href="MultipleIsotropicMisesFlows-keywords.html">MultipleIsotropicMisesFlows</a></li> 
		<li><a href="RungeKutta-keywords.html">RungeKutta</a></li> 
	      </ul>
	    </li>
	    <li><a href="MTest-keywords.html">MTest keywords</a></li>
	    <li><a href="physical-constants.html">Physical constants</a></li>
	    <li><a href="glossary.html">Glossary</a></li>
	    <li><a href="publications.html">Publications</a></li>
	    <li><a href="faq.html">FAQ</a></li>
	    <li><a href="about.html">About</a></li>
	  </ul>
	</li>
	<li><a>Contributing</a>
	  <ul>
	    <li><a href="svn.html">Access to source repositories</a></li>
	    <li><a href="devel.html">Development guidelines</a></li>
	    <li><a href="https://github.com/thelfer/tfel/issues">Report bugs</a></li>
	  </ul>
	</li>
	<li><a>Getting Help</a>
	  <ul>
	    <li><a href="search.html">Search on this site</a></li>
	    <li><a href="https://github.com/thelfer/tfel/discussions">Forum</a></li>
	    <li><a href="http://sourceforge.net/p/tfel/tfel">Mailing lists</a></li>
	    <li><a href="mailto:tfel-contact@cea.fr">Contact</a></li>
	  </ul>
	</li>
      </ul>
    </header>
<div id="header">
<h1 class="title">How to implement the Fichant-La Borderie damage behaviour</h1>
<h2 class="author">Thomas Helfer, Alexandre Gagnant</h2>
<h3 class="date">12/2019</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#description-of-the-fichant-la-borderie-damage-law">Description of the Fichant-La Borderie damage law</a>
<ul>
<li><a href="#equivalent-strain">Equivalent strain</a></li>
<li><a href="#damage-evolution">Damage evolution</a></li>
<li><a href="#computation-of-the-stress">Computation of the stress</a></li>
</ul></li>
<li><a href="#implementation">Implementation</a>
<ul>
<li><a href="#choice-of-the-domain-specific-language">Choice of the domain specific language</a></li>
<li><a href="#name-of-the-behaviour">Name of the behaviour</a></li>
<li><a href="#metadata">Metadata</a></li>
<li><a href="#material-properties">Material properties</a></li>
<li><a href="#state-variable">State variable</a></li>
<li><a href="#local-variables">Local variables</a></li>
<li><a href="#initialization-of-the-local-variables">Initialization of the local variables</a></li>
<li><a href="#prediction-operator">Prediction operator</a></li>
<li><a href="#behaviour-integration">Behaviour integration</a></li>
</ul></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<!--
pandoc -f markdown-markdown_in_html_blocks+tex_math_single_backslash+grid_tables --filter pandoc-crossref  --mathjax --email-obfuscation=javascript --default-image-extension=svg FLB.md -o FLB.pdf
-->
<p>This document describes how to implement the Fichant-La Borderie damage behaviour. See <span class="citation" data-cites="fichant_endommagement_1996 gangnant_etude_2016">[<a href="#ref-fichant_endommagement_1996" role="doc-biblioref">1</a>, <a href="#ref-gangnant_etude_2016" role="doc-biblioref">2</a>]</span> for a detailed description.</p>
<p>The Fichant-La Borderie (FLB) model is an extension of the Mazars model, which:</p>
<ul>
<li>simplifies the number of input parameters defining the tensile and compressive asymmetry.</li>
<li>handles unilateral effects (i.e., crack closure).</li>
<li>features an energy based regularisation method, thus allowing a fracture finite energy in a finite element implementation</li>
</ul>
<figure>
<img src="./img/FichantLaBorderieDamageBehaviourUniaxialTensileTest.png" alt="The Fichant La Borderie damage behaviour under uniaxial tension and compression" /><figcaption aria-hidden="true">The Fichant La Borderie damage behaviour under uniaxial tension and compression</figcaption>
</figure>
<p>The implementation is available <a href="gallery/damage/FichantLaBorderieDamageBehaviour.mfront">here</a></p>
<h1 id="description-of-the-fichant-la-borderie-damage-law">Description of the Fichant-La Borderie damage law</h1>
<h2 id="equivalent-strain">Equivalent strain</h2>
<p>The equivalent strain <span class="math inline">\(\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\)</span> is defined as:</p>
<p><span class="math display">\[
\varepsilon^{\mathrm{to}}_{\mathrm{eq}}=\sqrt{{\left&lt;\underline{\varepsilon}^{\mathrm{to}}\right&gt;_{+}}\,\colon\,{\left&lt;\underline{\varepsilon}^{\mathrm{to}}\right&gt;_{+}}}=
\sqrt{\sum_{I=1}^{3}{\left&lt;\varepsilon^{\mathrm{to}}_{I}\right&gt;_{+}}^2}
\]</span></p>
<p>where <span class="math inline">\({\left&lt;\underline{\varepsilon}^{\mathrm{to}}\right&gt;_{+}}\)</span> is the positive part of the total strain and <span class="math inline">\(\left(\varepsilon^{\mathrm{to}}_{I}\right)_{i \in [1:3]}\)</span> are its eigenvalues.</p>
<blockquote>
<p><strong>Derivative of the equivalent strain</strong></p>
<p>The following expression of the derivative of the equivalent strain with respect to the total strain will be useful:</p>
<p><span id="eq:deeq"><span class="math display">\[
{\displaystyle \frac{\displaystyle \mathrm{d} \varepsilon^{\mathrm{to}}_{\mathrm{eq}}}{\displaystyle \mathrm{d} \underline{\varepsilon}^{\mathrm{to}}}}={{\displaystyle \frac{\displaystyle 1}{\displaystyle \varepsilon^{\mathrm{to}}_{\mathrm{eq}}}}}\,{\left&lt;\underline{\varepsilon}^{\mathrm{to}}\right&gt;_{+}}\,\colon\,{\displaystyle \frac{\displaystyle \mathrm{d} {\left&lt;\underline{\varepsilon}^{\mathrm{to}}\right&gt;_{+}}}{\displaystyle \mathrm{d} \underline{\varepsilon}^{\mathrm{to}}}}
\qquad(1)\]</span></span></p>
</blockquote>
<h2 id="damage-evolution">Damage evolution</h2>
<p>The damage evolution is a function of the equivalent strain <span class="math inline">\(\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\)</span>:</p>
<ul>
<li>Under a given threshold <span class="math inline">\(\epsilon_{0}\)</span>, no damage occurs.</li>
<li>Once this threshold is reached, the damage <span class="math inline">\(d\)</span> is defined as follows: <span id="eq:d"><span class="math display">\[
d=1-{{\displaystyle \frac{\displaystyle \epsilon_{0}}{\displaystyle \varepsilon^{\mathrm{to}}_{\mathrm{eq}}}}}\,\exp{\left(B_{t}\,{\left(\epsilon_{0}-\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right)}\right)}
\qquad(2)\]</span></span></li>
</ul>
<p>However, the latter expression must be modified to take into account the irreversibility of the damage evolution. Let <span class="math inline">\({\left.d\right|_{t}}\)</span> be the value of the damage at the beginning of the time step and <span class="math inline">\({\left.d\right|_{t+\Delta\,t}}\)</span> its value at the end of the time step, <span class="math inline">\({\left.d\right|_{t+\Delta\,t}}\)</span> is determined as follows:</p>
<p><span class="math display">\[
{\left.d\right|_{t+\Delta\,t}}=\max{\left({\left.d\right|_{t}},1-{{\displaystyle \frac{\displaystyle \epsilon_{0}}{\displaystyle {\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}}}}\,\exp{\left(B_{t}\,{\left(\epsilon_{0}-{\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}\right)}\right)}\right)}
\]</span></p>
<p>where <span class="math inline">\({\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}\)</span> is the value of the equivalent strain at the end of the time step.</p>
<blockquote>
<p><strong>Hillerborg regularisation (see <span class="citation" data-cites="hillerborg_analysis_1976">[<a href="#ref-hillerborg_analysis_1976" role="doc-biblioref">3</a>]</span>)</strong></p>
<p>Local damage models suffers from spurious mesh dependency. In particular, the dissipated energy tends to <span class="math inline">\(0\)</span> as the mesh size decreases.</p>
<p>The Hillerborg regularisation consists in introducing the mesh size in the material parameter to get a constant dissipated energy.</p>
<p>In the FLB case, <span class="math inline">\(B_{t}\)</span> can be deduced from the fracture energy <span class="math inline">\(G_{f}\)</span> and the mesh size <span class="math inline">\(h\)</span> as follows:</p>
<p><span class="math display">\[
B_{t} ={{\displaystyle \frac{\displaystyle h\,E\,\epsilon_{0}}{\displaystyle G_{f} −{{\displaystyle \frac{\displaystyle 1}{\displaystyle 2}}}\,E\,\epsilon_{0}^{2}\,h}}}
\]</span></p>
<p>where <span class="math inline">\(E\)</span> is the Young modulus</p>
<p>Note that <span class="math inline">\(B_{t}\)</span> must be positive, which, for a given fracture energy <span class="math inline">\(G_{f}\)</span>, imposes a maximal value for the mesh size <span class="math inline">\(h\)</span>.</p>
<p><span class="math display">\[
h &lt; {{\displaystyle \frac{\displaystyle 2\,G_{f}}{\displaystyle E\,\epsilon_{0}^{2}}}}
\]</span></p>
<p>A condition which states that the elastic energy stored inside an element at the onset of damage must be less than dissipated energy by damage.</p>
</blockquote>
<blockquote>
<p><strong>Derivatives of the damage</strong></p>
<p>In case of a growing damage, the derivative of the damage with respect to the equivalent plastic strain is:</p>
<p><span id="eq:dd"><span class="math display">\[
{\displaystyle \frac{\displaystyle \mathrm{d} {\left.d\right|_{t+\Delta\,t}}}{\displaystyle \mathrm{d} {\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}}}={{\displaystyle \frac{\displaystyle \epsilon_{0}}{\displaystyle {\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}}}}\exp{\left(B_{t}\,{\left(\epsilon_{0}-{\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}\right)}\right)}\left(B_{t}+{{\displaystyle \frac{\displaystyle 1}{\displaystyle {\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}}}}\right)
\qquad(3)\]</span></span></p>
<p>Combined with Equation (1), Equation (3) allows computing the derivative of the damage with respect to the total strain.</p>
</blockquote>
<h2 id="computation-of-the-stress">Computation of the stress</h2>
<p>The effective stress tensor <span class="math inline">\(\underline{\sigma}^{\mathrm{eff}}\)</span> is computed using the standard Hooke law: <span class="math display">\[
{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}={\left.\underline{\underline{\mathbf{D}}}\right|_{t+\Delta\,t}}\,\colon\,{\left.\underline{\varepsilon}^{\mathrm{to}}\right|_{t+\Delta\,t}}
\]</span></p>
<p>The behaviour is assumed isotropic, so that the stiffness tensor <span class="math inline">\({\left.\underline{\underline{\mathbf{D}}}\right|_{t+\Delta\,t}}\)</span> can be related to the first and second Lamé coefficients, denoted respectively <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(\mu\)</span>, as follows:</p>
<p><span class="math display">\[
{\left.\underline{\underline{\mathbf{D}}}\right|_{t+\Delta\,t}}={\left.\lambda\right|_{t+\Delta\,t}}\,\underline{I}\,\otimes\,\underline{I}+2\,{\left.\mu\right|_{t+\Delta\,t}}\,\underline{\underline{\mathbf{I}}}
\]</span></p>
<blockquote>
<p><strong>Note</strong></p>
<p>The restriction to isotropy has an important pratical consequence: <span class="math inline">\(\underline{\sigma}^{\mathrm{eff}}\)</span> and <span class="math inline">\(\underline{\varepsilon}^{\mathrm{to}}\)</span> have the same egein basis.</p>
</blockquote>
<p>The stress tensor <span class="math inline">\(\underline{\sigma}\)</span> is then computed as follows: <span class="math display">\[
{\left.\underline{\sigma}\right|_{t+\Delta\,t}}={\left(1-{\left.d\right|_{t+\Delta\,t}}\right)}\,{\left&lt;{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}\right&gt;_{+}}+{\left(1-{\left.d\right|_{t+\Delta\,t}}^{a}\right)}\,{\left&lt;{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}\right&gt;_{-}}
\]</span></p>
<blockquote>
<p><strong>Derivative of the stress with respect to the total strain</strong></p>
<p>In case of damage growth, the derivative of the stress with respect to the total strain is given by: <span id="eq:Dt"><span class="math display">\[
\begin{aligned}
{\displaystyle \frac{\displaystyle \mathrm{d} {\left.\underline{\sigma}\right|_{t+\Delta\,t}}}{\displaystyle \mathrm{d} {\left.\underline{\varepsilon}^{\mathrm{to}}\right|_{t+\Delta\,t}}}}&amp;=
\left[{\left(1-{\left.d\right|_{t+\Delta\,t}}\right)}\,    {\displaystyle \frac{\displaystyle \mathrm{d} {\left&lt;{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}\right&gt;_{+}}}{\displaystyle \mathrm{d} {\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}}}+
      {\left(1-{\left.d\right|_{t+\Delta\,t}}^{a}\right)}\,{\displaystyle \frac{\displaystyle \mathrm{d} {\left&lt;{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}\right&gt;_{-}}}{\displaystyle \mathrm{d} {\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}}}\right]\,\colon\,{\left.\underline{\underline{\mathbf{D}}}\right|_{t+\Delta\,t}}\\
&amp;- {\left&lt;{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}\right&gt;_{+}}\,\otimes\,{\displaystyle \frac{\displaystyle \mathrm{d} {\left.d\right|_{t+\Delta\,t}}}{\displaystyle \mathrm{d} {\left.\underline{\varepsilon}^{\mathrm{to}}\right|_{t+\Delta\,t}}}}
 - a\,{\left.d\right|_{t+\Delta\,t}}^{a-1}\,{\left&lt;{\left.\underline{\sigma}^{\mathrm{eff}}\right|_{t+\Delta\,t}}\right&gt;_{-}}\,\otimes\,{\displaystyle \frac{\displaystyle \mathrm{d} {\left.d\right|_{t+\Delta\,t}}}{\displaystyle \mathrm{d} {\left.\underline{\varepsilon}^{\mathrm{to}}\right|_{t+\Delta\,t}}}}
\end{aligned}
\qquad(4)\]</span></span></p>
<p>This expression gives the so-called consistent tangent operator.</p>
</blockquote>
<h1 id="implementation">Implementation</h1>
<h2 id="choice-of-the-domain-specific-language">Choice of the domain specific language</h2>
<p>The Fichant-La Borderie damage behaviour does not require any specific integration scheme as the damage evolution is an explicit function of the total strain. The <code>Default</code> domain specific language is suitable for treating that kind of behaviours.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>DSL Default;</span></code></pre></div>
<h2 id="name-of-the-behaviour">Name of the behaviour</h2>
<p>The <code>@Behaviour</code> keyword defines the name of the behaviour:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Behaviour FichantLaBorderieDamageBehaviour;</span></code></pre></div>
<h2 id="metadata">Metadata</h2>
<p>The implementation starts by defining somme metadata associated with the behaviour:</p>
<ul>
<li>the date.</li>
<li>the names of the authors.</li>
<li>a short description.</li>
</ul>
<div class="sourceCode" id="cb3"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Date <span class="dv">7</span>/<span class="dv">12</span>/<span class="dv">2019</span>;</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Author A. Gangnant, T. Helfer;</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Description{</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Implementation of the Fichant-La Borderie damage behaviour&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h2 id="material-properties">Material properties</h2>
<h3 id="elastic-material-properties">Elastic material properties</h3>
<p>Most solvers uses the Young modulus and the Poisson ratio to characterize the elasticity of an isotropic material. Here we adopt this convention by defining them as two material properties named <code>young</code> and <code>nu</code> and associate those variables with the appropriate glossary names:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>MaterialProperty stress young;</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>young.setGlossaryName(<span class="st">&quot;YoungModulus&quot;</span>);</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>MaterialProperty real nu;</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>nu.setGlossaryName(<span class="st">&quot;PoissonRatio&quot;</span>);</span></code></pre></div>
<blockquote>
<p><strong>About glossary names</strong></p>
<p>Associating a glossary name is a way to define the so-called external name of this variable, i.e. the name that will appear on the calling solver side. It also allows <code>MFront</code> to make assumptions about the real meaning of those variables.</p>
<p>The case of the <code>Cast3M</code> solver is a noteworthy example. This solver requires <span class="math inline">\(4\)</span> elastic properties to be defined for its own use in the case of an isotropic material properties: the Young modulus, the Poisson ratio, the density and the thermal expansion coefficient. Normally, the <code>MFront</code> material properties are appended to those four properties. However, by associating the <code>YoungModulus</code> and the <code>PoissonRatio</code> glossary names to the <code>young</code> and <code>nu</code> material properties respectively, <code>MFront</code> will identify them with the ones required by <code>Cast3M</code>.</p>
<p>For details about the glossary names, the reader may refer to the <a href="glossary.html">following page</a>.</p>
</blockquote>
<h3 id="material-properties-associated-with-damage">Material properties associated with damage</h3>
<p>The damage evolution given by Equation (2) requires three material properties <span class="math inline">\(Bt\)</span>, <span class="math inline">\(e_{0}\)</span> and <span class="math inline">\(a\)</span>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>MaterialProperty real Bt;</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>MaterialProperty strain e0;</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>MaterialProperty real a;</span></code></pre></div>
<h2 id="state-variable">State variable</h2>
<p>The only state variable of this behaviour is the damage variable <span class="math inline">\(d\)</span> which we declare as follows:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>StateVariable real d;</span></code></pre></div>
<p>For post-processing purposes, we associate this variable with the <code>Damage</code> glossary name.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>d.setGlossaryName(<span class="st">&quot;Damage&quot;</span>);</span></code></pre></div>
<h2 id="local-variables">Local variables</h2>
<p>In <code>MFront</code>, a local variable are variables in each code blocks. They are usually evaluated once for all in the <code>@InitLocalVariables</code> code block which is called before the behaviour integration (as defined by the <code>@Integrator</code> code block) or before the computation of the prediction operator (as defined in the <code>@PredictionOperator</code> code block).</p>
<p>In the following, we will use two local variables <code>lambda</code> and <code>mu</code> associated respectively with the first and second Lamé coefficients.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>LocalVariable stress lambda, mu;</span></code></pre></div>
<h2 id="initialization-of-the-local-variables">Initialization of the local variables</h2>
<p>The initialization of the local variables is performed in the <code>@InitLocalVariables</code> code block, as follows:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>InitLocalVariables {</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  lambda = computeLambda(young, nu);</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  mu = computeMu(young, nu);</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Here, we use two functions provided by the <code>TFEL/Material</code> library: <code>computeLambda</code> and <code>computeMu</code>.</p>
<h2 id="prediction-operator">Prediction operator</h2>
<p>The prediction operator is used by the <code>Code_Aster</code> finite element solver at the beginning of each new time step. It is also used by the <code>Abaqus/Explicit</code> solver to retrieve the elastic properties at the packaging step.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>PredictionOperator {</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">static_cast</span>&lt;<span class="dt">void</span>&gt;(smt);</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  Dt = lambda * Stensor4::IxI() + <span class="dv">2</span> * mu * Stensor4::Id();</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Here, we only provide the elastic prediction operator. Thus, we discarded the <code>smt</code> variable by casting it to <code>void</code> to avoid a compiler warning.</p>
<h2 id="behaviour-integration">Behaviour integration</h2>
<p>The behaviour integration is performed in the <code>@Integrator</code> code block which is meant to:</p>
<ul>
<li>update the damage state variable.</li>
<li>compute the stress at the end of the time step.</li>
<li>compute the consistent tangent operator if required.</li>
</ul>
<blockquote>
<p><strong>Note</strong></p>
<p>The computation of the consistent tangent operator is usually performed in the <code>@TangentOperator</code> code block. However, in the case of the Fichant-La Borderie behaviour, this would lead to an unneccessary complexity as a lot of local variables would have been required to store the results of complex computations required in both the <code>@Integrator</code> and the <code>@TangentOperator</code> code blocks.</p>
<p>To state that the consistent tangent operator is indeed computed in the <code>@Integrator</code> code block, one shall use the <code>@ProvidesTangentOperator</code> keyword. Note that this keyword explicitly states that the consistent tangent operator is <em>not</em> symmetric. See the <code>@ProvidesSymmetricTangentOperator</code> keyword to state that the consistent tangent operator is symmetric.</p>
</blockquote>
<div class="sourceCode" id="cb11"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>ProvidesTangentOperator;</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="er">@</span>Integrator{</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// a simple alias for the identity</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="at">const</span> <span class="kw">auto</span> id = Stensor::Id();</span></code></pre></div>
<p>At the beginning of this block, we define two constant used in the following to decide if two eigenvalues are equal:</p>
<ul>
<li>The first constant <code>eeps</code> is used when dealing a tensor of the strain type.</li>
<li>The second constant <code>seps</code> is used when dealing a tensor of the stress type.</li>
</ul>
<div class="sourceCode" id="cb12"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">constexpr</span> <span class="at">const</span> strain eeps = <span class="fl">1.e-12</span>;</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> seps = eeps * young;</span></code></pre></div>
<p>Then we define two local functions called <code>pp</code> and <code>square_pp</code>:</p>
<ul>
<li><code>pp</code> computes the positive part of a scalar.</li>
<li><code>square_pp</code> computes the square of the positive part of a scalar.</li>
</ul>
<div class="sourceCode" id="cb13"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// positive part</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> pp = [](<span class="at">const</span> real x) { <span class="cf">return</span> x &gt; <span class="dv">0</span> ? x : <span class="dv">0</span>; };</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">// square of the posititve part</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> square_pp = [](<span class="at">const</span> strain v) { <span class="cf">return</span> v &gt; <span class="dv">0</span> ? v * v : <span class="dv">0</span>; };</span></code></pre></div>
<blockquote>
<p><strong>Note</strong></p>
<p>In <code>C++</code>, those local functions are called <code>lambda</code> functions.</p>
</blockquote>
<p>We now compute the total strain and stores it in a variable called <code>e</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// total strain</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> e = eval(eto + deto);</span></code></pre></div>
<p>where <code>eto</code> and <code>deto</code> are respectively the total strain at the beginning of the time step and its increment over the time step.</p>
<p>Tensorial operations in the <code>TFEL/Math</code> library are lazy, which means that their evaluation is delayed until it is really needed. This technique is called <code>expression template</code> in <code>C++</code> and is based on the definition of intermediate objects which hold the operation to be performed.</p>
<p>The <code>eval</code> function is used to force the evaluation of this operation. This is required for the computation of the eigenvalues and the eigenvectors which is done by calling the <code>computeEigenVectors</code> tensor of the <code>stensor</code> class.</p>
<p>In <code>C++-17</code>, this can be called as follows:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// eigen values and eigen tensors of the total strain</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> [e_vp, m] = </span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    e.<span class="kw">template</span> computeEigenVectors&lt;Stensor::FSESJACOBIEIGENSOLVER&gt;();</span></code></pre></div>
<p>In previous <code>C++</code> version, one must use a more verbose code:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// eigen values and eigen tensors of the total strain</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> e_vp = tvector&lt;<span class="dv">3</span><span class="bu">u</span>, strain&gt;{};</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">auto</span> m = tmatrix&lt;<span class="dv">3</span><span class="bu">u</span>, <span class="dv">3</span><span class="bu">u</span>, strain&gt;{};</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>  e.<span class="kw">template</span> computeEigenVectors&lt;Stensor::FSESJACOBIEIGENSOLVER&gt;(e_vp, m);</span></code></pre></div>
<p>Here, we must make some important comments:</p>
<ul>
<li>We use the Jacobi eigen solver which is very accurate but is more expensive than the default eigen solver.</li>
<li>The computation of the equivalent strain only requires the eigenvalues of the total strain. We also compute its eigen vectors because they also are the eigen vectors of the effective stress and its positive part.</li>
</ul>
<p>The computation of the equivalent strain is then straightforward:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> e_eq = sqrt(square_pp(e_vp[<span class="dv">0</span>]) + <span class="co">//</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>                         square_pp(e_vp[<span class="dv">1</span>]) + <span class="co">//</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>                         square_pp(e_vp[<span class="dv">2</span>]));</span></code></pre></div>
<p>We are now able to compute the damage at the end of the time step as follows:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// update the damage, taking irreversibility into account</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> Cd = (e0 / e_eq) * exp(Bt * (e0 - e_eq));</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> d_p = (e_eq &gt; e0) ? <span class="dv">1</span> - Cd : <span class="dv">0</span>;</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> bp = d_p &gt; d;</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (bp) {</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    d = d_p;</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The previous lines also defines two additional variables:</p>
<ul>
<li><code>Cd</code> which is used to compute the expression <span class="math inline">\({{\displaystyle \frac{\displaystyle \epsilon_{0}}{\displaystyle {\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}}}}\exp{\left(B_{t}\,{\left(\epsilon_{0}-{\left.\varepsilon^{\mathrm{to}}_{\mathrm{eq}}\right|_{t+\Delta\,t}}\right)}\right)}\)</span> only once.</li>
<li><code>bp</code> which is a boolean stating if the damage increases over the time step. This boolean will be used in the computation of the consistent tangent operator.</li>
</ul>
<p>The next two lines computes the effective stress:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// effective stress at the end of the time step</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> l_tr_e = lambda * trace(e);</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> s = eval(l_tr_e * id + <span class="dv">2</span> * mu * e);</span></code></pre></div>
<p>The next lines computes the positive part of the effective stress:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// positive part of the effective stress</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> <span class="va">s_vp</span> = tvector&lt;<span class="dv">3</span><span class="bu">u</span>, real&gt;{l_tr_e + <span class="dv">2</span> * mu * e_vp[<span class="dv">0</span>],  <span class="co">//</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>                                      l_tr_e + <span class="dv">2</span> * mu * e_vp[<span class="dv">1</span>],  <span class="co">//</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>                                      l_tr_e + <span class="dv">2</span> * mu * e_vp[<span class="dv">2</span>]};</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> sp = StressStensor::computeIsotropicFunction(pp, <span class="va">s_vp</span>, m);</span></code></pre></div>
<p>Those lines uses the <code>computeIsotropicFunction</code> which takes the function computing the positive part, the eigenvalues of the effective stress and its eigen vectors.</p>
<p>Finally, the final stress is computed:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>  <span class="co">// function of the damage to simplify expressions</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> d_a = pow(d, a);</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> fpd = (<span class="dv">1</span> - d);</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> <span class="kw">auto</span> fpn = (<span class="dv">1</span> - d_a);</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">// final stress</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  sig = (fpd - fpn) * sp + fpn * s;</span></code></pre></div>
<h4 id="computation-of-the-tangent-operator">Computation of the tangent operator</h4>
<p>If one computes the tangent operator in the <code>@Integrator</code> code block, one shall check if this operator was requested using the <code>computeTangentOperator_</code> boolean value.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="va">computeTangentOperator_</span>) {</span></code></pre></div>
<p>Next, we define a local function called <code>dpp</code> which computes the derivative of the positive part:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">// derivative of the positive part</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="at">const</span> <span class="kw">auto</span> dpp = [&amp;seps](<span class="at">const</span> stress x) {</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="bu">std::</span>abs(x) &lt; seps ? <span class="fl">0.5</span> : ((x &lt; <span class="dv">0</span>) ? <span class="dv">0</span> : <span class="dv">1</span>);</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    };</span></code></pre></div>
<p>Various kind of tangent operator can be computed. To see which one was requested by the calling solver, one must check the value of the <code>smt</code> variable (<code>smt</code> stands “stiffness matrix type”):</p>
<p>The first case corresponds to the <code>ELASTIC</code> value:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (smt == ELASTIC) {</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>      Dt = lambda * Stensor4::IxI() + <span class="dv">2</span> * mu * Stensor4::Id();</span></code></pre></div>
<p>The second case corresponds to the <code>SECANTOPERATOR</code> value. This case also corresponds to the consistent tangent operator was no damage increase occurs (i.e. the <code>bp</code> variable’ value is <code>false</code>):</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> <span class="cf">if</span> ((smt == SECANTOPERATOR) || (!bp)) {</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>      <span class="co">// elastic stiffness</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> De = lambda * Stensor4::IxI() + <span class="dv">2</span> * mu * Stensor4::Id();</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">// derivative of the positive part of the stress</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dsp =</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>          StressStensor::computeIsotropicFunctionDerivative(pp, dpp, <span class="va">s_vp</span>, m, seps * <span class="fl">0.1</span>);</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>      Dt = ((fpd * dsp + fpn * (Stensor4::Id() - dsp)) + eeps * Stensor4::Id()) * De;</span></code></pre></div>
<p>This code uses the <code>computeIsotropicFunctionDerivative</code> which computes <span class="math inline">\({\displaystyle \frac{\displaystyle \partial {\left&lt;\underline{\sigma}\right&gt;_{+}}}{\displaystyle \partial \underline{\sigma}}}\)</span>. We also added the <code>eeps * Stensor4::Id()</code> to avoid singular stiffness matrices and add some coercivity to the global problem.</p>
<p>The last case corresponds to the <code>CONSISTENTANGENTOPERATOR</code> value in case of damage increase</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode cxx"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>      <span class="co">// elastic stiffness</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> De = lambda * Stensor4::IxI() + <span class="dv">2</span> * mu * Stensor4::Id();</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>      <span class="co">// derivative of the positive part of the stress</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dsp =</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>          StressStensor::computeIsotropicFunctionDerivative(pp, dpp, <span class="va">s_vp</span>, m, seps * <span class="fl">0.1</span>);</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>      <span class="co">// derivative with respect to the damage</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dfpd_dd = -<span class="dv">1</span>;</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> id = <span class="dv">1</span> / max(eeps, d);</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dfpn_dd = -a * d_a * id;</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>      <span class="co">// positive part of the total strain</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> ep = StrainStensor::computeIsotropicFunction(pp, e_vp, m);</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>      <span class="co">// derivative of the damage</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dd_deq = Cd * (Bt + <span class="dv">1</span> / e_eq);</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dep_de =</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>          StrainStensor::computeIsotropicFunctionDerivative(pp, dpp, e_vp, m, eeps * <span class="fl">0.1</span>);</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> deq_dep = ep / e_eq;</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>      <span class="at">const</span> <span class="kw">auto</span> dd_de = dd_deq * deq_dep * dep_de;</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>      Dt = ((fpd * dsp + fpn * (Stensor4::Id() - dsp)) + eeps * Stensor4::Id()) * De  <span class="co">//</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>           + (((dfpd_dd - dfpn_dd) * sp + dfpn_dd * s) ^ dd_de);</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<!--
\[
\
\]
  const auto e_vp = e.computeEigenValues();
  const auto e_eq = sqrt(square_pp(e_vp[0]) + square_pp(e_vp[1]) + square_pp(e_vp[2]));
  // effective stress at t+theta*dt
  const auto de = (e_eq > e0) ? max(d, 1 - (e0 / e_eq) * exp(Bt * (e0 - e_eq))) : d;
  // function of the damage to simplify expressions
  const auto fpd = (1 - de);
  const auto fpn = (1 - pow(de, a));
  // effective stress at the end of the time step
  const auto s = eval(lambda * trace(e) * id + 2 * mu * e);
  // positive part
  const auto pp = [](const real x) { return x > 0 ? x : 0; };
  // derivative of the positive part
  const auto dpp = [&seps](const real x) { return std::abs(x) < seps ? 0.5 : ((x < 0) ? 0 : 1); };
  const auto sp_dsp =
      s.template computeIsotropicFunctionAndDerivative<stensor_common::FSESANALYTICALEIGENSOLVER>(
          pp, dpp, seps * 0.1);
  const auto& sp = sp_dsp.first;
  const auto& dsp = sp_dsp.second;  // derivative of sp with respect to s
  const auto sn = s - sp;
  // final stress
  sig = fpd * sp + fpn * sn;
-->
<h1 class="unnumbered" id="references">References</h1>
<div id="refs" class="references csl-bib-body" role="doc-bibliography">
<div id="ref-fichant_endommagement_1996" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">1. </div><div class="csl-right-inline"><span class="smallcaps">Fichant</span>, Stéphanie. Endommagement et anisotropie induite du béton de structures : Modélisations approchées. thesis. Cachan, Ecole normale supérieure, 1996. Available from: <a href="http://www.theses.fr/1996DENS0015">http://www.theses.fr/1996DENS0015</a></div>
</div>
<div id="ref-gangnant_etude_2016" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">2. </div><div class="csl-right-inline"><span class="smallcaps">Gangnant</span>, Alexandre. Étude de la rupture quasi-fragile d’un béton à l’échelle mésoscopique : Aspects expérimentaux et modélisation. thesis. Bordeaux, 2016. Available from: <a href="http://www.theses.fr/2016BORD0401">http://www.theses.fr/2016BORD0401</a></div>
</div>
<div id="ref-hillerborg_analysis_1976" class="csl-entry" role="doc-biblioentry">
<div class="csl-left-margin">3. </div><div class="csl-right-inline"><span class="smallcaps">Hillerborg</span>, A., <span class="smallcaps">Modéer</span>, M. and <span class="smallcaps">Perterson</span>, P.-E. Analysis of crack formation and crack growth in concrete by means of fracture mechanics and finite elements. <em>Cement and Concrete Research</em>. 1976. Vol. 6, p. 779–782. </div>
</div>
</div>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-62273823-1', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
